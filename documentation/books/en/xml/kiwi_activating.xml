<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE sect1 PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN"
  "http://www.docbook.org/xml/4.4/docbookx.dtd"
[
 <!ENTITY % entities SYSTEM "entity-decl.ent">
 %entities;
]>

<!--
 ***************************************************
 Please see license.xml for this document's license.
 ***************************************************
-->

<sect1 id="sec.kiwi.activating" xml:base="kiwi_activating.xml">
 <title>Activating an Image</title>
 <para>
  After a logical extend (an image) has been created from a physical extend
  there are in principal four possibilities to activate the image:
 </para>
 <itemizedlist>
  <listitem>
   <para>
    On a <emphasis>local system</emphasis> the image can be installed by
    dumping (with the command <command>dd</command>) the image file on a
    previously created partition on a local harddisk. To activate the system a
    boot manager like grub or lilo needs to be used. An USB stick system
    is also treated as a local system but kiwi supports you with the
    installation of such a system by its own --bootstick option.
   </para>
  </listitem>
  <listitem>
   <para>
    In case of a <emphasis>network enabled system</emphasis> (netboot client)
    the image can be installed via a special boot image. The boot image which
    serves as initial ramdisk (<filename>initrd</filename>) and the
    appropriate kernel are downloaded from a network service. The linux kernel
    automatically calls a program named <command>linuxrc</command> which takes
    over all tasks needed to download and install the system image. The
    installation can be done persistently on disk or temporary into the RAM of
    the machine. The network boot protocol supported by kiwi is PXE
   </para>
  </listitem>
  <listitem>
   <para>
    In case of a <emphasis>para virtualized target system</emphasis> like Xen,
    the image can be be installed by copying the image file and the kiwi created
    xen configuration file onto the target system. To activate the virtual
    system the command <screen> xm create -c <replaceable>&lt;xen config file&gt;</replaceable></screen> is used.
   </para>
  </listitem>
  <listitem>
   <para>
    In case of a <emphasis>full virtualized target system</emphasis> like
    VMware, or QEMU the image represents a virtual disk which can be
    <quote>played</quote> by the virtualisation system.
   </para>
  </listitem>
 </itemizedlist>
 <para>
  No matter which of the above mentioned scenarios applies, there is always
  a special image which takes over control of the activation or deployment
  process. These images are called boot images and the following sections
  will explain the kiwi provided boot images in detail. 
 </para>
 <sect2 id="sec.kiwi.activating.netboot">
  <title>The KIWI netboot image</title>
  <para>
   The KIWI netboot boot image can be used to install an operating system
   image to a
   network client. To establish communication with the client, a boot server
   infrastructure with the following services is required:
  </para>
  <itemizedlist>
   <listitem>
    <para>
     a DHCP server to provide an IP address for the client
    </para>
   </listitem>
   <listitem>
    <para>
     a TFTP server to allow file transfer from and to the client
    </para>
   </listitem>
  </itemizedlist>
  <sect3 id="sec.kiwi.activating.netboot.process">
   <title>The Boot Process of a Netboot System</title>
   <para>
    The following graphic illustrates a simplified boot process of a netboot
    client.
   </para>
   <figure id="fig.kiwi.activating.netboot.process">
    <title>The Boot Process of a Netboot Client</title>
    <mediaobject>
     <imageobject role="fo">
      <imagedata width="75%" fileref="nbboot.svg" format="SVG"/>
     </imageobject>
     <imageobject role="html">
      <imagedata width="75%" fileref="nbboot.png" format="PNG"/>
     </imageobject>
    </mediaobject> 
   </figure>
   <para>
    If the system is able to boot via a network, it will load the kernel and
    the compressed boot image from the network. The <quote>brain</quote> of
    the boot image is the <command>linuxrc</command> script, which does all
    the stuff controlled by an image configuration file also obtained from the
    network. The major task is to download and activate the operating system
    image. The boot image is exchanged for the operating system image to be
    activated. The following overview describes the steps that take place when
    the netboot client is booted:
   </para>
   <itemizedlist>
    <listitem>
     <para>
      Via PXE network boot or boot manager (GRUB), the client boots the initrd
      (<filename>initrd.gz</filename>) which is served by the TFTP server. If
      no PXE boot is possible, the client tries to boot from a local hard disk.
     </para>
    </listitem>
    <listitem>
     <para>
      Running <command>linuxrc</command> starting the following process:
     </para>
    </listitem>
   </itemizedlist>
   <orderedlist>
    <listitem>
     <para>
      The file systems required to receive system data, are mounted, for
      example the <filename>/proc</filename> file system.
     </para>
    </listitem>
    <listitem>
     <para>
      The kernel parameters are imported. If there is an IMAGE parameter it is
      assumed the system boots locally and the variable
      <varname>LOCAL_BOOT</varname> is set.
     </para>
    </listitem>
    <listitem>
     <para>
      If <varname>LOCAL_BOOT</varname> is not set, network support is
      activated. The network card is probed by using the
      <command>hwinfo</command> command. The appropriate module is loaded
      using <command>modprobe</command>. Any dependencies to other modules
      will be resolved.
     </para>
    </listitem>
    <listitem>
     <para>
      If <varname>LOCAL_BOOT</varname> is not set, the network interface is
      set up via DHCP. After the interface has been established, the DHCP
      variables are exported into the file
      <filename>/var/lib/dhcpcd/dhcpcd-eth0.info</filename> and the contents
      of DOMAIN<varname></varname> and DNS<varname></varname> are used to
      generate a <filename>/etc/resolv.conf</filename>.
     </para>
    </listitem>
    <listitem>
     <para>
      If <varname>LOCAL_BOOT</varname> is not set, The TFTP server address is
      acquired. During this step, a check is made to determine whether the
      kiwitftp <emphasis>kernel</emphasis> parameter is set. If this is not
      the case a check whether the host name tftp.<varname>$DOMAIN</varname>
      can be resolved is made. If both tests fail, the DHCP server is used as
      the TFTP server. For more infomation about the TFTP server structure,
      refer to <xref
       linkend="sec.kiwi.activating.netboot.tftp"/>.
     </para>
    </listitem>
    <listitem>
     <para>
      If <varname>LOCAL_BOOT</varname> is not set, the configuration file is
      loaded from the server directory
      <filename>/var/lib/tftpboot/KIWI</filename> via TFTP. At this point, the
      client expects the file <filename> config.<replaceable>&lt;MAC
	Address&gt;</replaceable></filename>. If this file is not available and
      cannot be loaded, it is assumed that the client hasn't existed before and can be immediately
      registered by uploading a control file to the
      TFTP server's upload directory
      <filename>/var/lib/tftpboot/upload</filename>. After the upload, the
      client branches off into a loop in which the following steps are taken:
     </para>
     <itemizedlist>
      <listitem>
       <para>
	the DHCP lease file is restarted (<command>dhcpcd -n</command>).
       </para>
      </listitem>
      <listitem>
       <para>
	a new attempt is made to load the file
	<filename>config.<replaceable>&lt;MAC
	  address&gt;</replaceable></filename> from the TFTP server.
       </para>
      </listitem>
      <listitem>
       <para>
	if the file does not exist, there is a 60 second time-out before a new
	run begins.
       </para>
      </listitem>
     </itemizedlist>
     <para>
      If the configuration file does load, it contains data on image,
      configuration, synchronization, or partition parameters. For more
      infomation about the file format of the configuration file, refer to
      <xref linkend="sec.kiwi.activating.netboot.configfile"/>.
     </para>
    </listitem>
    <listitem>
     <para>
      All registered kernel modules are loaded. The kernel provides a system
      which allows to check for a module alias registered automatically by the
      kernel during boot time. If such an alias matches the modinfo information
      from a kernel module it will be loaded.
     </para>
    </listitem>
    <listitem>
     <para>
      If<varname> LOCAL_BOOT</varname> is not set, the <code>PART:</code> line
      in the configuration is analyzed. If it is found a check is performed to see whether any local
	system needs to be updated. If not, the local boot process continues
	immediately. No image download occurs. If an update is required (or no
      operating system can be found), the client's hard disk is partitioned.
     </para>
    </listitem>
    <listitem>
     <para>
      If <varname>NFSROOT</varname> and <varname>NBDROOT</varname>
      and <varname>LOCAL_BOOT</varname> is not set, the images are
      downloaded with TFTP. If <varname>LOCAL_BOOT</varname> is set this part
      of the initrd will only read the IMAGE information for later usage.
      If <varname>NFSROOT</varname> is set the image root device is set
      to a remote NFS path. If <varname>NBDROOT</varname> is set the nbd
      kernel module is loaded and the nbd-client program setup a new
      network block device called /dev/nd0. The image root device is then
      set to the network block device
     </para>
    </listitem>
    <listitem>
     <para>
      If <varname>LOCAL_BOOT</varname> is not set, the checksums are
      checked. If the check fails another download attempt is started.
     </para>
    </listitem>
    <listitem>
     <para>
      If <varname>LOCAL_BOOT</varname> is not set, a check for
      <varname>RELOAD_CONFIG</varname> is performed
     </para>
    </listitem>
    <listitem>
     <para>
      The operating system image is mounted.
     </para>
    </listitem>
    <listitem>
     <para>
      If <varname>LOCAL_BOOT</varname> is not set, the <code>CONF:</code>
      line is evaluated. All the specified files are loaded from the TFTP
      server and stored in a <filename>/config/</filename> path. Additionally
      the <code>KIWI_INITRD:</code> line is evaluated. The specified
      initrd file will be downloaded from the tftp server and stored in the
      system image as file <filename>/boot/initrd</filename>.
     </para>
    </listitem>
    <listitem>
     <para>
      If <varname>LOCAL_BOOT</varname> is not set, all the user-land
      processes based on the boot image (<command>dhcpcd -k</command>) will be
      terminated.
     </para>
    </listitem>
    <listitem>
     <para>
      Check if the image is a splitted image by evaluating the contents of the
      <varname>COMBINED_IMAGE</varname> variable. Both image partsare combined
      into one system by creating the appropriate filesystem links.
     </para>
    </listitem>
    <listitem>
     <para>
      If <varname>LOCAL_BOOT</varname> is not set, the filesystem type of the
      system image as well as the available kernels are determined.
     </para>
    </listitem>
    <listitem>
     <para>
      If <varname>LOCAL_BOOT</varname> is not set, important configuration
      files like <filename>/etc/fstab</filename>,
      <filename>/boot/grub/menu.lst</filename>,
      <filename>/etc/grub.conf</filename>, and
      <filename>/etc/sysconfig/kernel</filename> are created.
     </para>
    </listitem>
    <listitem>
     <para>
      If <varname>LOCAL_BOOT</varname> is not set, the configuration files
      stored in the <filename>/config/</filename> directory are
      copied into the mounted operating system image.
     </para>
    </listitem>
    <listitem>
     <para>
      The system switches to the mounted operating system image. The root file
      system is converted to the operating system image via
      <command>pivot_root</command> or <command>mount
       <option>--move</option></command>. All required configuration files
      are now present, because they had been stored in the operating system
      image or have been downloaded via TFTP.
     </para>
    </listitem>
    <listitem>
     <para>
      The boot image is unmounted using an <command>exec umount</command> call.
     </para>
    </listitem>
    <listitem>
     <para>
      At termination of <command>linuxrc</command> or the exec call, the
      kernel initiates the <command>init</command> process that starts
      processing the boot scripts as specified in
      <filename>/etc/inittab</filename>, for example, to configure the network
      interface.
     </para>
    </listitem>
   </orderedlist>
  </sect3>
  <sect3 id="sec.kiwi.activating.netboot.tftp">
   <title>The TFTP Server Structure</title>
   <para>
    The TFTP server directory structure is divided into the following main
    areas:
   </para>
   <variablelist>
    <varlistentry>
     <term>Image configurations</term>
     <listitem>
      <para>
       The <filename>/var/lib/tftpboot/KIWI/</filename> directory contains the
       various <filename>config.<replaceable>&lt;MAC
	 Address&gt;</replaceable></filename> image configuration files.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Configuration files</term>
     <listitem>
      <para>
       The <filename>/var/lib/tftpboot/KIWI/<replaceable>&lt;MAC
	 Address&gt;</replaceable>/</filename> directory contains the various
       system configuration files, such as <filename>xorg.conf</filename>.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Boot files</term>
     <listitem>
      <para>
       The <filename>/var/lib/tftpboot/boot/</filename> directory is where the
       <filename>initrd.gz</filename>, and the kernel to boot are kept.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>PXE second stage boot loader(s)</term>
     <listitem>
      <para>
       The <filename>/var/lib/tftpboot/</filename> directory is where the boot
       loaders for PXE are kept (<filename>pxelinux.0</filename>,
       <filename>mboot.c32</filename>)
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>PXE configuration file</term>
     <listitem>
      <para>
       <filename>/var/lib/tftpboot/pxelinux.cfg</filename> is the location of
       the PXE configuration file.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Image files and checksums</term>
     <listitem>
      <para>
       The <filename>/var/lib/tftpboot/image/</filename> directory is where all
       the image files and their checksums are kept.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Upload area</term>
     <listitem>
      <para>
       The directory <filename>/var/lib/tftpboot/upload/</filename> is the
       directory into which the <filename>hwtype.<replaceable>&lt;MAC
	 Address&gt;</replaceable></filename> files for registering new netboot
       clients are uploaded.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </sect3>
  <sect3 id="sec.kiwi.activating.netboot.configfile">
   <title>The Netboot Client Configuration File <filename>config.<replaceable>&lt;MAC Address&gt;</replaceable></filename></title>
   <para>
    The configuration file contains data about image, configuration,
    synchronization, and partition parameters. The configuration file is
    loaded from the TFTP server directory
    <filename>/var/lib/tftpboot/KIWI</filename> via TFTP for previously
    installed netboot clients. New netboot clients are immediately registered
    and a new configuration file with the corresponding MAC address is
    created. This is an example for a cash register configuration file:
   </para>
<screen>
IMAGE=/dev/hda2;image/browser;1.1.1;192.168.1.1;4096
CONF=/KIWI/00:30:05:1D:75:D2/ntp.conf;/etc/ntp.conf;192.168.1.1;1024,     \
     /KIWI/00:30:05:1D:75:D2/xorg.xonf;/etc/X11/xorg.xonf;192.168.1.1;1024
PART=200;S;x,300;L;/,500;L;/opt,x;L;/home
DISK=/dev/hda</screen>
   <para>The following format is used:</para>
   <simplelist>
    <member>
     <code>IMAGE=<replaceable>device;name;version;srvip;bsize;compressed,...</replaceable></code>
    </member>
    <member>
     <code>SYNC=<replaceable>syncfilename;srvip;bsize</replaceable></code>
    </member>
    <member>
     <code>CONF=<replaceable>src;dest;srvip;bsize,...,src;dest;srvip;bsize</replaceable></code>
    </member>
    <member>
     <code>PART=<replaceable>size;id;Mount,...,size;id;Mount</replaceable></code>
    </member>
    <member>
     <code>JOURNAL=<replaceable>ext3</replaceable></code>
    </member>
    <member>
     <code>DISK=<replaceable>device</replaceable></code>
    </member>
   </simplelist>
   <variablelist>
    <varlistentry>
     <term><code>IMAGE</code></term>
     <listitem>
      <para>
       Specifies which image (<literal>name</literal>) should be loaded with
       which version (<literal>version</literal>) and to which storage device
       (<literal>device</literal>) it should be linked to (e.g.,
       <filename>/dev/ram1</filename> or <filename>/dev/hda2</filename>). The
       netboot client partition (<literal>device</literal>)
       <systemitem>hda2</systemitem> defines the root file system
       <filename>/</filename> and <systemitem>hda1</systemitem> is used for the
       swap partition. The numbering of the hard disk device should not be
       confused with the RAM disk device, where <filename>/dev/ram0</filename>
       is used for the initial RAM disk and can not be used as storage device
       for the second stage system image. SUSE recommends to use the device
       <filename>/dev/ram1</filename> for the RAM disk. If the hard drive is
       used, a corresponding partitioning must be performed.
      </para>
      <para>
       <literal>srvrip</literal> specifies the server IP address for the TFTP
       download. It must always be specified, except in
       <literal>PART</literal>.
      </para>
      <para>
       <literal>bsize</literal> specifies the block size for the TFTP download.
       Must always be specified, except in <literal>PART</literal>. If the
       block size is too small according to the maximum number of data packages
       (32768), <command>linuxrc</command> will automatically calculate a new
       blocksize for the download. 
      </para>
      <para>
       <literal>compressed</literal> Specifies if the image file on the TFTP
       server is compressed. If <literal>compressed</literal> is not specified
       the standard download workflow is used.
      </para>
      <note>
       <para>
	The download will fail if you specify <literal>compressed</literal> and
	the image isn't compressed. It will also fail if you do not specify
	<literal>compressed</literal> but the image is compressed. The name of
	the compressed image has to contain the suffix <filename>.gz</filename>
	and needs to be compressed with the <command>gzip</command> tool. Using
	a compressed image will automatically deactivate the multicast download
	option of a TFTP.
       </para>
      </note>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><code>CONF</code></term>
     <listitem>
      <para>
       Specifies a comma-separated list of source:target configuration files.
       The source (<literal>src</literal>) corresponds to the path on the TFTP
       server and is loaded via TFTP. The download is made to the file on the
       netboot client indicated by the target (<literal>dest</literal>).
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><code>PART</code></term>
     <listitem>
      <para>
       Specifies the partitioning data. The comma-separated list must contain
       the size (<literal>size</literal>), the type number
       (<literal>id</literal>), and the mount point
       (<literal>Mount</literal>). The size is measured in MB by default.
       Additionally all size specifications supported by the sfdisk program
       are allowed as well. The type number specifies the ID of the partition.
       Valid ID's are listed via the <command>sfdisk
	<option>--list-types</option></command> command. Mount specifies the
       partition's mount point.
      </para>
      <itemizedlist>
       <listitem>
	<para>
	 The first element of the list must define the swap partition. The
	 swap partition must not contain a mount point. A lowercase letter
	 <literal>x</literal> must be set instead.
	</para>
       </listitem>
       <listitem>
	<para>
	 The second element of the list must define the
	 <systemitem>root</systemitem> partition.
	</para>
       </listitem>
       <listitem>
	<para>
	 If a partition should take all the space left on a disk, use a
	 lowercase <literal>x</literal> letter as size specification.
	</para>
       </listitem>
      </itemizedlist>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><code>DISK</code></term>
     <listitem>
      <para>
       Specifies the hard disk. Used only with PART and defines the device the
       hard disk can be addressed with, e.g., <filename>/dev/hda</filename>.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><code>RELOAD_IMAGE</code></term>
     <listitem>
      <para>
       If set to a non-empty string, <code>RELOAD_IMAGE</code> forces
       the configured image to be loaded from the server even if the image on
       the disk is up-to-date. Used mainly for debugging purposes, this option
       only makes sense on diskful systems.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><code>RELOAD_CONFIG</code></term>
     <listitem>
      <para>
       If set to an non-empty string, forces all configuration files to be
       loaded from the server. Used mainly for debugging purposes, this option
       only makes sense on diskful systems.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><code>COMBINED_IMAGE</code></term>
     <listitem>
      <para>
       If set to an non-empty string, <code>COMBINED_IMAGE</code>
       indicates that the two images specified need to be combined into one
       bootable image, where the first image defines the read-write part and
       the second image defines the read-only part.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><code>KIWI_INITRD</code></term>
     <listitem>
      <para>
       Specifies the kiwi initrd to be used for a local boot of the system.
       The variable's value must be set to the name of the initrd file which
       is used via PXE network boot. If the standard tftp setup suggested with
       the kiwi-pxeboot package is used, all initrd files reside in
       <filename>/var/lib/tftpboot/boot/</filename> directory. Because the
       tftpserver does a <command>chroot</command> into the tftp server path
       you need to specify the initrd file as follows:
      </para>
<screen>
KIWI_INITRD=/boot/<replaceable>&lt;name-of-initrd-file&gt;</replaceable></screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><code>NFSROOT</code></term>
     <listitem>
      <para>
       For netboot images there is the possibility to mount the system
       image root filesystem remotely via NFS (Network File System).
       This means there is a server which
       exports the root filesystem of the network client in a way that
       the client can mount it read/write. In order to do that the boot
       image needs to know the server IP address and the path name on
       where the root directory exists on this server. The information
       must be provided like the following example shows:
      </para>
<screen>
NFSROOT=<replaceable>&lt;NFS.Server.IP.address&gt;</replaceable>;<replaceable>&lt;/path/to/root/tree&gt;</replaceable>
</screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><code>NBDROOT</code></term>
     <listitem>
      <para>
       For netboot images there is the possibility to mount the system image
       image root filesystem remotely via NBD (Network Block Device). This
       means there is a server which exports the root directory of the system
       image via a specified port. The kernel provides the block layer together
       with a remote port using the program <command>nbd-server</command>.
       For detailed information how to setup the server please consult the
       man page of nbd-server. The kernel on the remote client can setup a
       special network block device named <command>/dev/nd0</command> using
       the command <command>nbd-client</command>. Once this device exists
       the <command>mount</command> program is used to mount the root
       filesystem. In order to allow the kiwi boot image to that the
       following information must be provided:
<screen>
NBDROOT=<replaceable>&lt;NBD.Server.IP.address&gt;</replaceable>;<replaceable>&lt;NBD-Port-Number&gt;</replaceable>;/dev/<replaceable>&lt;NBD-Device&gt;</replaceable>
</screen>
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><code>UNIONFS_CONFIG</code></term>
     <listitem>
      <para>
       For netboot and usbboot images there is the possibility to use
       <systemitem>unionfs</systemitem> or <systemitem>aufs</systemitem> as a
       container filesystem in combination with a compressed system image. The
       recommended compressed filesystem type for the system image is
       <filename>squashfs</filename>. In case of a usb-stick system the
       usbboot image will automatically setup the
       <systemitem>unionfs</systemitem>/<systemitem>aufs</systemitem>
       filesystem. In case of a PXE network image the netboot image requires a
       <filename>config.<replaceable>&lt;MAC&gt;</replaceable></filename>
       setup like the following example shows:
      </para>
<screen>
UNIONFS_CONFIG=/dev/sda2,/dev/sda3,aufs
</screen>
      <para>
       In this example the first device <filename>/dev/sda2</filename>
       represents the read/write filesystem and the second device
       <filename>/dev/sda3</filename> represents the compressed system image
       filesystem. The container filesystem aufs is used to cover the
       read/write layer with the read-only device to one read/write filesystem.
       If a file on the read-only device is going to be written the changes
       inodes are part of the read/write filesystem. Please note the device
       specifications in <code>UNIONFS_CONFIG</code> must correspond with
       the <code>IMAGE</code> and <code>PART</code> information.
       The following example explains the interconnections:
      </para>
<screen>
IMAGE=/dev/sda3;image/browser;1.1.1;192.168.1.1;4096
PART=200;S;x,300;L;/,x;L;x
UNIONFS_CONFIG=/dev/sda2,/dev/sda3,aufs
DISK=/dev/sda</screen>
      <para>
       Since the second element of the <code>PART</code> list must define
       the <systemitem>root</systemitem> partition, it is absolutely important
       that the first device in <code>UNIONFS_CONFIG</code> references
       this device as read/write device. The second device of
       <code>UNIONFS_CONFIG</code> has to reference the given
       <code>IMAGE</code> device name.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><code>KIWI_KERNEL_OPTIONS</code></term>
     <listitem>
      <para>
       Specifies additional command line options to be passed to the kernel
       when booting from disk.  For instance, to enable a splash screen, use
       <literal>vga=0x317 splash=silent</literal>.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><code>KIWI_BOOT_TIMEOUT</code></term>
     <listitem>
      <para>
       Specifies the number of seconds to wait at the grub boot screen when
       doing a local boot. The default is 10.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </sect3>
  <sect3 id="sec.kiwi.activating.netboot.controlfile">
   <title>
    The netboot client Control File <filename>hwtype.<replaceable>&lt;MAC
      Address&gt;</replaceable></filename>
   </title>
   <para>
    The control file is primarily used to set up new netboot clients. In this
    case, there is no configuration file corresponding to the client MAC
    address available. Using the MAC address information, the control file is
    created and uploaded to the TFTP servers upload directory
    <filename>/var/lib/tftpboot/upload</filename>.
   </para>
  </sect3>
  <sect3 id="sec.kiwi.activating.netboot.hwinfofile">
   <title>
    The netboot client Hardware-Info File <filename>hwinfo.<replaceable>&lt;MAC
      Address&gt;</replaceable></filename>
   </title>
   <para>
    The hardware info file is primarily used to inform about hardware details
    of new netboot clients. In this case, there is no configuration file
    corresponding to the client MAC address available. Using the MAC address
    information, the hardware info file is created and uploaded to the
    TFTP servers upload directory
    <filename>/var/lib/tftpboot/upload</filename>.
   </para>
  </sect3>
 </sect2>
 <sect2 id="sec.kiwi.activating.xennetboot">
  <title>The KIWI xennetboot image</title>
  <para>
   The KIWI xennetboot boot image works exactly the same way than the netboot
   boot image. The only difference is the kernel which is used to boot the
   client machine. With netboot a standard kernel is used whereas the 
   xennetboot image uses the Xen kernel within the boot image. This allows
   to boot the system image directly with an enabled Xen kernel and therefore
   turn the system image into a hypervisor without reboot. In order to be
   able to boot a Xen kernel via PXE over the network an additional boot
   loader called mboot.c32 is required. mboot.c32 is a COM32 module for
   H. Peter Anvin's fine SYSLINUX bootloader, to load multiboot kernels
   and modules. This allows Xen to be network-booted. Instructions for
   using mboot.c32 can be found here:
   <ulink url="http://www.kernel.org/git/?p=boot/syslinux/syslinux.git;a=blob;f=com32/modules/mboot.doc"><guilabel>com32/modules/mboot.doc</guilabel></ulink>
  </para>
 </sect2>
 <sect2 id="sec.kiwi.activating.isoboot">
  <title>The KIWI isoboot image</title>
  <para>
   Normally an image will be installed on a disk or into the main memory of a
   computer. This is done by a deployment architecture which transfers the
   image via a boot image into its final destination. such a boot image can
   also exist on a CD. In terms of kiwi this is handled by the isoboot image.
   Booting a live system can happen by using two techniques:
   </para>
   <itemizedlist>
   <listitem>
    <para>
     Using the <emphasis>old</emphasis> style will split the system image
     into a Read-Only and a Read/Write. The Read/Write image is pushed
     into main memory whereas the Read-Only part will make it on the CD.
     (optional compression of the Read-Only part is possible)
     The isoboot image will take care to make one root tree from both
     parts by using symbolic links. The CD-Boot structure of KIWI will put
     the directories
     <filename>/bin</filename>, <filename>/boot</filename>,
     <filename>/lib</filename>, <filename>/opt</filename>,
     <filename>/sbin</filename> and <filename>/usr</filename> on the CD and the
     rest into the main memory of the system.
    </para>
   </listitem>
   <listitem>
    <para>
      Using the <emphasis>new</emphasis> style will make use of the new
      overlay filesystems like aufs or unionfs. In this case the
      system image is not divided and the isoboot boot image will create
      a writable RAM space which is overlayed into one root filesystem.
      The result is one filesystem which is completely Read/Write.
      Optionally one can compress the system image which allows to put
      more data on the CD. The new style is preferred over the old
      style
    </para>
   </listitem>
   </itemizedlist>
   <para>
    Each isoboot description contains a directory named
    <emphasis>cdboot</emphasis>. In there the files
    <emphasis>isolinux.cfg</emphasis> and <emphasis>isolinux.msg</emphasis>
    The first one defines which boot parameters are used for booting
    the kernel and the second defines the message which is displayed if
    isolinux doesn't boot in graphics mode. The additional file named
    <emphasis>isolinux.sh</emphasis> is a link to the standard
    suse-isolinux script which creates an iso image from a specified
    CD tree. The script will work for non SUSE distributions as well
    but in CD header of such an image contains information which should
    be replaced if the distribution is no SUSE based.
   </para>
  </sect2>
 <sect2 id="sec.kiwi.activating.vmxboot">
  <title>The KIWI vmxboot image</title>
  <para>
   The KIWI vmxboot boot image is used for <emphasis>full</emphasis>
   virtualized machines like they are provided by VMware or Qemu.
   The result of an image created with the vmx type is always a virtual
   disk containing the vmxboot image the system image a virtual disk
   geometry and a boot loader (grub) to boot the vmxboot boot image.
   The vmxboot boot image takes over the task of detecting the device
   of the virtual disk and activates the system on the virtual disk.
   The boot image also writes some default files like /etc/fstab in order
   to allow the system default initrd to be created and used. This on
   the other means that the vmxboot image is replaced during first boot
   by the default system initrd. The replacement only takes place if the
   default system initrd is able to boot the image which is not the case
   if for example a compressed image solution with overlay filesystem
   like aufs is used.
  </para>
 </sect2>
 <sect2 id="sec.kiwi.activating.oemboot">
  <title>The KIWI oemboot image</title>
  <para>
   The KIWI oemboot boot image works only with the <emphasis>vmx</emphasis>
   boot type and therefore only with virtual disks. The oemboot was
   designed for OEM customers who want to have a pre-installed linux
   delivered to their customers. The idea is to have a virtual disk image
   which is simply copied on the real disk of a computer. As soon as the
   first boot takes place the oemboot boot image takes over the task of
   repartitioning the real disk which it detects first followed by
   preparing the system to activate the YaST second stage process. At the 
   end the oemboot image boots into the system and YaST starts with
   a special configuration sequence made for pre installed systems.
  </para>
 </sect2>
 <sect2 id="sec.kiwi.activating.xenboot">
  <title>The KIWI xenboot image</title>
  <para>
   The KIWI xenboot boot image works only with the <emphasis>xen</emphasis>
   boot type. The xen boot type creates all information needed to run a
   Xen virtual machine with the previosly created image. All files in this
   case means the system image itself which is just a file containing the
   operating system data and the filesystem, the xenboot boot image as
   compressed initrd file, the xen kernel and the xen configuration file
   which references the previosly mentioned files. After kiwi has finished
   its image creation process a user only needs to call:
<screen>
xm create -c xen-configuration-file
</screen> 
   The primary task of the xenboot boot image is to load the required
   xen modules and to find out how the disk appears in the kernel. Once
   this is done the system can be activated.
  </para>
 </sect2>
 <sect2 id="sec.kiwi.activating.usbboot">
  <title>The KIWI usbboot image</title>
  <para>
   The KIWI usbboot image works only with the <emphasis>usb</emphasis>
   boot type. The usb boot type creates all files needed to install
   a USB stick with an operating system. The installation is done by
   using the kiwi options <option>--bootstick , --bootstick-system</option>.
   The files needed in this case are the system image itself and
   the usboot boot image (initrd). The primary task of the usbboot
   boot image is to find out how the BIOS mapped the USB stick. Once
   the device was found the system can be activated. kiwi also installs the
   boot manager to the USB stick so that each systen could use the stick
   as main operating system as soon as the BIOS is able to boot from
   a USB stick.
  </para>
 </sect2>
</sect1>

<!-- Keep this comment at the end of the file
Local variables:
coding:utf-8
mode:xml
sgml-indent-step:1
sgml-omittag:nil
sgml-shorttag:nil
End:
-->
