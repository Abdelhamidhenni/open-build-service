#!/usr/bin/perl -w
#
# Copyright (c) 2006, 2007 Michael Schroeder, Novell Inc.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License version 2 as
# published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program (see the file COPYING); if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA
#
################################################################
#
# The Job Dispatcher
#

BEGIN {
  unshift @INC, 'build';
}

use POSIX;
use Data::Dumper;
use Digest::MD5 ();
use List::Util;
use XML::Structured ':bytes';

use BSConfig;
use BSRPC;
use BSUtil;
use BSXML;

use strict;

my $user = $BSConfig::bsuser;
my $group = $BSConfig::bsgroup;

!defined($user) || defined($user = (getpwnam($user))[2]) || die("unknown user\n");
!defined($group) || defined($group = (getgrnam($group))[2]) || die("unknown group\n");
if (defined $group) {
  ($(, $)) = ($group, $group);
  die "setgid: $!\n" if ($) != $group);
}
if (defined $user) {
  ($<, $>) = ($user, $user); 
  die "setuid: $!\n" if ($> != $user); 
}

my $port = 5252;        #'RR'
$port = $1 if $BSConfig::reposerver =~ /:(\d+)$/;

my %cando = (
  'i586'   => ['i586'],
  'i686'   => ['i586', 'i686'],
  'x86_64' => ['x86_64', 'i586', 'i686'],
  'ppc'    => ['ppc'],
  'ppc64'  => ['ppc64', 'ppc'],
  'sh4'    => ['sh4'],
);

my $workersdir = "$BSConfig::bsdir/workers";
my $jobsdir = "$BSConfig::bsdir/jobs";

my $reporoot = "$BSConfig::bsdir/build";

sub getcodemd5 {
  my ($dir, $cache) = @_;
  my $md5 = '';
  my %new;
  my $doclean;
  my @files = grep {!/^\./} ls($dir);
  my @bfiles = grep {!/^\./} ls("$dir/Build");
  my %bfiles = map {$_ => 1} @bfiles;
  @files = sort(@files, @bfiles);
  $cache ||= {};
  for my $file (@files) {
    my $f = $bfiles{$file} ? "$dir/Build/$file" : "$dir/$file";
    next unless -f $f;
    my @s = stat _;
    my $id = "$s[9]/$s[7]/$s[1]";
    $new{$id} = 1; 
    if ($cache->{$id}) {
      $md5 .= "$cache->{$id}  $file\n";
      next;
    }    
    $cache->{$id} = Digest::MD5::md5_hex(readstr($f));
    $md5 .= "$cache->{$id}  $file\n";
    $doclean = 1; 
  }
  if ($doclean) {
    for (keys %$cache) {
      delete $cache->{$_} unless $new{$_};
    }    
  }
  return Digest::MD5::md5_hex($md5);
}

my $workerdircache = {};
my $builddircache = {};

sub assignjob {
  my ($job, $idlename, $arch) = @_;

  print "assignjob $job -> $idlename\n";
  my $worker = readxml("$workersdir/idle/$idlename", $BSXML::worker, 1);
  return undef unless $worker;
  # ready for building!
  unlink("$workersdir/idle/$idlename");
  my $infoxml = readstr("$jobsdir/$arch/$job:dir/info.xml");
  my $info = XMLin($BSXML::buildinfo, $infoxml);
  my $prp = $info->{'path'}->[0];
  my $statusdir = "$reporoot/$prp->{'project'}/$prp->{'repository'}/$info->{'arch'}/$info->{'package'}";
  mkdir_p($statusdir);
  my $workercode = getcodemd5('worker', $workerdircache);
  my $buildcode = getcodemd5('build', $builddircache);
  eval {
    BSRPC::rpc({
      'uri'     => "http://$worker->{'ip'}:$worker->{'port'}/build",
      'timeout' => 10,
      'request' => "PUT",
      'headers' => [ "Content-Type: text/xml" ],
      'data'    => $infoxml,
    }, undef, "port=$port", "workercode=$workercode", "buildcode=$buildcode");
  };
  if ($@) {
    print "rpc error: $@";
    return undef;
  }
  my $status = readxml("$statusdir/status", $BSXML::buildstatus, 1);
  $status = {} unless $status;
  $status->{'uri'} = "http://$worker->{'ip'}:$worker->{'port'}";
  $status->{'workerid'} = $worker->{'workerid'} if defined $worker->{'workerid'};
  $status->{'starttime'} = time();
  $status->{'hostarch'} = $worker->{'hostarch'};
  $status->{'status'} = 'building';
  $status->{'arch'} = $arch;
  $status->{'job'} = $job;
  eval { writexml("$statusdir/.status$$", "$statusdir/status", $status, $BSXML::buildstatus); };
  warn($@) if $@;
  unlink("$jobsdir/$arch/$job:dir/status.xml");
  link("$statusdir/status", "$jobsdir/$arch/$job:dir/status.xml") || warn("link $statusdir/status $jobsdir/$arch/$job:dir/status.xml: $!\n");
  mkdir_p("$workersdir/building");
  unlink("$workersdir/building/$idlename");
  link("$statusdir/status", "$workersdir/building/$idlename") || warn("link $statusdir/status $workersdir/building/$idlename: $!\n");
  return 1;
}

$| = 1;
print "starting build service dispatcher\n";

while (1) {
  my $assigned = 0;
  my @idle = grep {!/^\./} ls("$workersdir/idle");
  my %idlearch;
  for my $idle (@idle) {
    my $harch = (split(':', $idle, 2))[0];
    for (@{$cando{$harch} || []}) {
      push @{$idlearch{$_}}, $idle;
    }
  }
  my @archs = List::Util::shuffle(keys %idlearch);
  for my $arch (@archs) {
    my @b = grep {!/^\./ && !/:new$/} ls("$jobsdir/$arch");
    my %locked = map {$_ => 1} grep {/:dir$/} @b;
    @b = grep {!/:dir$/} @b;
    @b = grep {!$locked{"$_:dir"}} @b;

    #poor man's project priority
    my @bn = grep {!/^Ports:DebianBased:Auto/} @b;
    @b = @bn if @bn;

    for my $job (List::Util::shuffle(@b)) {
      for my $idle (map {$_} List::Util::shuffle(@{$idlearch{$arch} || []})) {
	mkdir("$jobsdir/$arch/$job:dir") || next;
	if (!link("$jobsdir/$arch/$job", "$jobsdir/$arch/$job:dir/info.xml")) {
	  rmdir("$jobsdir/$arch/$job:dir");
	  next;
	}
	if (!assignjob($job, $idle, $arch)) {
	  unlink("$jobsdir/$arch/$job:dir/info.xml");
	  rmdir("$jobsdir/$arch/$job:dir");
	  my $harch = (split(':', $idle, 2))[0];
	  for (@{$cando{$harch} || []}) {
	    $idlearch{$_} = [ grep {$_ ne $idle} @{$idlearch{$_}} ];
	  }
	  next;
	}
	my $harch = (split(':', $idle, 2))[0];
	for (@{$cando{$harch} || []}) {
	  $idlearch{$_} = [ grep {$_ ne $idle} @{$idlearch{$_}} ];
	}
	$assigned++;
	last;
      }
    }
  }
  sleep(1) unless $assigned;
}
