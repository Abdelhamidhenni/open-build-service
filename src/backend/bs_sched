#!/usr/bin/perl -w
#
# Copyright (c) 2006, 2007 Michael Schroeder, Novell Inc.
# Copyright (c) 2008 Adrian Schroeter, Novell Inc.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License version 2 as
# published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program (see the file COPYING); if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA
#
################################################################
#
# The Scheduler. One big chunk of code for now.
#

BEGIN {
  my ($wd) = $0 =~ m-(.*)/- ;
  $wd ||= '.';
  unshift @INC,  "$wd/build";
  unshift @INC,  "$wd";
}

use Digest::MD5 ();
use Data::Dumper;
use Storable ();
use XML::Structured ':bytes';
use POSIX;
use Fcntl qw(:DEFAULT :flock);

use BSConfiguration;
use BSRPC ':https';
use BSUtil;
use BSFileDB;
use BSXML;
use BSDBIndex;
use BSBuild;
use BSVerify;
use Build;
use BSDB;
use BSSolv;
use BSCando;

use BSSched::RPC;
use BSSched::Remote;
use BSSched::DoD;
use BSSched::ProjPacks;
use BSSched::BuildRepo;
use BSSched::BuildResult;
use BSSched::PublishRepo;
use BSSched::Events;
use BSSched::BuildJob;

if ($BSConfig::enable_download_on_demand) {
  require BSDoD;
}

use strict;

my $testprojid;
my $testmode;
my $asyncmode;
my $startupmode;
my $usestorableforprojpack = 1;

$asyncmode = $BSConfig::sched_asyncmode if $BSConfig::sched_asyncmode;
$startupmode = $BSConfig::sched_startupmode if $BSConfig::sched_startupmode;

my $bsdir = $BSConfig::bsdir || "/srv/obs";

my @binsufs = qw{rpm deb pkg.tar.gz pkg.tar.xz};
my $binsufsre = join('|', map {"\Q$_\E"} @binsufs);

BSUtil::mkdir_p_chown($bsdir, $BSConfig::bsuser, $BSConfig::bsgroup);
BSUtil::drop_privs_to($BSConfig::bsuser, $BSConfig::bsgroup);

my $sign;
$sign = $BSConfig::sign if defined($BSConfig::sign);

BSUtil::set_fdatasync_before_rename() unless $BSConfig::disable_data_sync || $BSConfig::disable_data_sync;

my $_reporoot = "$bsdir/build";
my $_jobsdir = "$bsdir/jobs";
my $_eventdir = "$bsdir/events";
my $_extrepodir = "$bsdir/repos";
my $_dodsdir = "$bsdir/dods";
my $_rundir = $BSConfig::rundir || "$bsdir/run";
my $infodir = "$bsdir/info";
my $_remotecache = "$BSConfig::bsdir/remotecache";
my $workersrcserver = $BSConfig::workersrcserver ? $BSConfig::workersrcserver : $BSConfig::srcserver;
my $workerreposerver = $BSConfig::workerreposerver ? $BSConfig::workerreposerver : $BSConfig::reposerver;

if (@ARGV && $ARGV[0] eq '--testmode') {
  $testmode = 1;
  shift @ARGV;
}
if (@ARGV && ($ARGV[0] eq '--exit' || $ARGV[0] eq '--stop')) {
  $testmode = 'exit';
  shift @ARGV;
} elsif (@ARGV && $ARGV[0] eq '--restart') {
  $testmode = 'restart';
  shift @ARGV;
}

my $_myarch = $ARGV[0] || 'i586';

if (!$BSCando::knownarch{$_myarch}) {
  die("Architecture '$_myarch' is unknown, please adapt BSCando.pm\n");
}

my $historylay = [qw{versrel bcnt srcmd5 rev time duration}];

my %_remoteprojs;	# remote project cache

# Create directory on first start
mkdir_p($infodir) || die ("Failed to create ".$infodir);

sub unify {
  my %h = map {$_ => 1} @_;
  return grep(delete($h{$_}), @_);
}

sub sendevent {
  my ($gctx, $ev, $arch, $evname) = @_;

  my $eventdir = $gctx->{'eventdir'};
  mkdir_p("$eventdir/$arch");
  $evname = "$ev->{'type'}:::".Digest::MD5::md5_hex($evname) if length($evname) > 200;
  writexml("$eventdir/$arch/.$evname$$", "$eventdir/$arch/$evname", $ev, $BSXML::event);
  local *F;
  if (sysopen(F, "$eventdir/$arch/.ping", POSIX::O_WRONLY|POSIX::O_NONBLOCK)) {
    syswrite(F, 'x');
    close(F);
  }
}

#
# input: depsp  -> hash of arrays
#        mapp   -> hash of strings
#
# 
sub sortpacks {
  my ($depsp, $mapp, $cycp, @packs) = @_;

  return @packs if @packs < 2;
  my @cycs;
  @packs = BSSolv::depsort($depsp, $mapp, \@cycs, @packs);
  if (@cycs) {
    @$cycp = @cycs if $cycp;
    print "cycle: ".join(' -> ', @$_)."\n" for @cycs;
  }
  return @packs;
}

sub sortedmd5toreason {
  my @res;
  for my $line (@_) {
    my $tag = substr($line, 0, 1); # just the first char
    $tag = 'md5sum' if $tag eq '!';
    $tag = 'added' if $tag eq '+';
    $tag = 'removed' if $tag eq '-';
    push @res, { 'change' => $tag, 'key' => substr($line, 1) };
  }
  return \@res;
}

sub diffsortedmd5 {
  my ($fromp, $top) = @_;

  my @ret;
  my @from = map {[$_, substr($_, 34)]} @$fromp;
  my @to   = map {[$_, substr($_, 34)]} @$top;
  @from = sort {$a->[1] cmp $b->[1] || $a->[0] cmp $b->[0]} @from;
  @to   = sort {$a->[1] cmp $b->[1] || $a->[0] cmp $b->[0]} @to;

  for my $f (@from) {
    if (@to && $f->[1] eq $to[0]->[1]) {
      push @ret, "!$f->[1]" if $f->[0] ne $to[0]->[0];
      shift @to;
      next;   
    }
    if (!@to || $f->[1] lt $to[0]->[1]) {
      push @ret, "-$f->[1]";
      next;   
    }
    while (@to && $f->[1] gt $to[0]->[1]) {
      push @ret, "+$to[0]->[1]";
      shift @to;
    }
    redo;   
  }
  push @ret, "+$_->[1]" for @to;
  return @ret;
}

sub findbins_dir {
  my ($dir, $cache) = @_;
  my @bins;
  if (ref($dir)) {
    @bins = grep {/\.(?:$binsufsre)$/} @$dir;
  } else {
    @bins = ls($dir);
    @bins = map {"$dir/$_"} grep {/\.(?:$binsufsre|raw|raw\.install)$/} sort @bins;
  }
  my $repobins = {};
  for my $bin (@bins) {
    my @s = stat($bin);
    next unless @s;
    my $id = "$s[9]/$s[7]/$s[1]";
    my $data;
    if ($cache && $cache->{$id}) {
      $data = { %{$cache->{$id}} };
    } else {
      $data = Build::query($bin, 'evra' => 1);	# need arch
      next unless $data;
    }
    eval {
      BSVerify::verify_nevraquery($data);
    };
    next if $@;
    delete $data->{'disttag'};
    $data->{'id'} = $id;
    $repobins->{$bin} = $data;
  }
  return $repobins;
}

sub writesolv {
  my ($fn, $fnf, $repo) = @_;
  if (defined($fnf) && $BSUtil::fdatasync_before_rename) {
    local *F;
    open(F, '>', $fn) || die("$fn: $!\n");
    $repo->tofile_fd(fileno(F));
    BSUtil::do_fdatasync(fileno(F));
    close(F) || die("$fn close: $!\n");
  } else {
    $repo->tofile($fn);
  }
  return unless defined $fnf;
  $! = 0;
  rename($fn, $fnf) || die("rename $fn $fnf: $!\n");
}

my %_prpcheckuseforbuild;	# project/package meta has changed
my %_channeldata;	# global channel data unificator to save memory

#  'lastscan'   last time we scanned
#  'meta'       meta cache
#  'solv'       solv data cache (for remote repos)
my %_repodatas;		# our repository knowledge
my %_repodatas_alien;	# repositories from other archs

my %_remotegbininfos;
my %_remotepackstatus;
my %_remotepackstatus_cleanup;

# add :full repo to pool
sub addrepo {
  my ($ctx, $pool, $prp) = @_;

  my $gctx = $ctx->{'gctx'};
  my $arch = $gctx->{'arch'};
  my $now = time();
  my $repodata = $gctx->{'repodatas'}->{$prp};
  if ($repodata && $repodata->{'lastscan'} && $repodata->{'lastscan'} + 24 * 3600 + ($repodata->{'random'} || 0) * 1800 > $now) {
    if (exists $repodata->{'solv'}) {
      my $r;
      eval {$r = $pool->repofromstr($prp, $repodata->{'solv'});};
      return $r if $r;
      delete $repodata->{'solv'};
    }
    my $solvfile = $repodata->{'solvfile'} || "$ctx->{'gctx'}->{'reporoot'}/$prp/$arch/:full.solv";
    if (-s $solvfile) {
      my $r;
      if ($repodata->{'solvfile'}) {
	my @s = stat _;
	utime time(), $s[9], $solvfile;	# update atime
      }
      eval {$r = $pool->repofromfile($prp, $solvfile);};
      return $r if $r;
    }
    if ($repodata->{'error'}) {
      print "    repo $prp: $repodata->{'error'}\n";
      return undef;
    }
  }
  if ($repodata) {
    delete $repodata->{'solv'};
    delete $repodata->{'lastscan'};
    delete $repodata->{'random'};
    delete $repodata->{'solvfile'};
    delete $repodata->{'error'};
  }
  my ($projid, $repoid) = split('/', $prp, 2);
  my $remoteprojs = $gctx->{'remoteprojs'};
  if ($remoteprojs->{$projid}) {
    return addrepo_remote($ctx, $pool, $prp, $arch, $remoteprojs->{$projid});
  }
  $gctx->{'repodatas'}->{$prp} = $repodata = {} unless $repodata;
  my $r = BSSched::BuildRepo::addrepo_scan($ctx, $pool, $prp, $arch, $repodata);
  if ($r && !$repodata->{'dontwrite'}) {
    $repodata->{'lastscan'} = time();
    $repodata->{'random'} = rand();
  }
  return $r;
}


# this is basically getconfig from the source server
# we do not need any macros, just the config
sub getconfig {
  my ($gctx, $arch, $path) = @_;
  my $config = '';
  my $extraconfig = '';
  if (@$path) {
    my ($p, $r) = split('/', $path->[0], 2);
    $config .= "%define _project $p\n";
    if ($BSConfig::extraconfig) {
      for (sort keys %{$BSConfig::extraconfig}) {
	$extraconfig .= $BSConfig::extraconfig->{$_} if $p =~ /$_/;
      }
    }
  }
  my $projpacks = $gctx->{'projpacks'};
  my $remoteprojs = $gctx->{'remoteprojs'};
  for my $prp (reverse @$path) {
    my ($p, $r) = split('/', $prp, 2);
    my $c;
    my $rproj = $remoteprojs->{$p};
    if ($rproj) {
      return undef if $rproj->{'error'};
      if (exists($rproj->{'config'})) {
	$c = $rproj->{'config'};
      } elsif ($rproj->{'partition'}) {
	$c = '';
      } else {
        $c = BSSched::Remote::fetchremoteconfig($gctx, $p); 
        return undef unless defined $c;
      }
    } elsif ($projpacks->{$p}) {
      $c = $projpacks->{$p}->{'config'};
    }
    next unless defined $c;
    $config .= "\n### from $p\n";
    $config .= "%define _repository $r\n";
    # get rid of the Macros sections
    my $s1 = '^\s*macros:\s*$.*?^\s*:macros\s*$';
    my $s2 = '^\s*macros:\s*$.*\Z';
    $c =~ s/$s1//gmsi;
    $c =~ s/$s2//gmsi;
    $config .= $c;
  }
  # it's an error if we have no config at all
  return undef unless $config ne '';
  # now we got the combined config, parse it
  $config .= "\n$extraconfig" if $extraconfig;
  my @c = split("\n", $config);
  my $c = Build::read_config($arch, \@c);
  $c->{'repotype'} = [ 'rpm-md' ] unless @{$c->{'repotype'}};
  $c->{'binarytype'} ||= 'UNDEFINED';
  return $c;
}


sub expandkiwipath {
  my ($info, $prpsearchpath) = @_;
  my @path;
  for (@{$info->{'path'} || []}) {
    if ($_->{'project'} eq '_obsrepositories') {
      push @path, @{$prpsearchpath || []};
    } else {
      push @path, "$_->{'project'}/$_->{'repository'}";
    }
  }
  return @path;
}


#######################################################################
#######################################################################
##
## Repository management functions
##

sub checkaccess {
  my ($gctx, $type, $projid, $packid, $repoid) = @_;
  my $access = 1;
  my $projpacks = $gctx->{'projpacks'};
  my $remoteprojs = $gctx->{'remoteprojs'};
  my $myarch = $gctx->{'arch'};
  my $proj = $projpacks->{$projid};
  $proj = $remoteprojs->{$projid} if !$proj && ($remoteprojs->{$projid} || {})->{'partition'};
  if ($proj) {
    my $pdata;
    $pdata = ($proj->{'package'} || {})->{$packid} if defined $packid;
    $access = BSUtil::enabled($repoid, $proj->{$type}, $access, $myarch);
    $access = BSUtil::enabled($repoid, $pdata->{$type}, $access, $myarch) if $pdata;
  } else {
    # remote project access checks are handled by the remote server
    $access = 0 unless $remoteprojs->{$projid} && !$remoteprojs->{$projid}->{'partition'};
  }
  return $access;
}

# check if every user from oprojid may access projid
sub checkroles {
  my ($gctx, $type, $projid, $packid, $oprojid, $opackid) = @_;
  my $projpacks = $gctx->{'projpacks'};
  my $remoteprojs = $gctx->{'remoteprojs'};
  my $proj = $projpacks->{$projid};
  my $oproj = $projpacks->{$oprojid};
  $proj = $remoteprojs->{$projid} if !$proj && ($remoteprojs->{$projid} || {})->{'partition'};
  $oproj = $remoteprojs->{$oprojid} if !$oproj && ($remoteprojs->{$oprojid} || {})->{'partition'};
  return 0 unless $proj && $oproj;
  if ($projid eq $oprojid) {
    return 1 if !defined $opackid;
    return 1 if ($packid || '') eq ($opackid || '');
  }
  my @roles;
  if (defined($packid)) {
    my $pdata = ($proj->{'package'} || {})->{$packid} || {};
    push @roles, @{$pdata->{'person'} || []}, @{$pdata->{'group'} || []};
  }
  push @roles, @{$proj->{'person'} || []}, @{$proj->{'group'} || []};
  while ($projid =~ /^(.+):/) {
    $projid = $1;
    $proj = $projpacks->{$projid} || {};
    push @roles, @{$proj->{'person'} || []}, @{$proj->{'group'} || []};
  }
  my @oroles;
  if (defined($opackid)) {
    my $pdata = ($oproj->{'package'} || {})->{$opackid} || {};
    push @oroles, @{$pdata->{'person'} || []}, @{$pdata->{'group'} || []};
  }
  push @oroles, @{$oproj->{'person'} || []}, @{$oproj->{'group'} || []};
  while ($oprojid =~ /^(.+):/) {
    $oprojid = $1;
    $oproj = $projpacks->{$oprojid} || {};
    push @oroles, @{$oproj->{'person'} || []}, @{$oproj->{'group'} || []};
  }
  # make sure every user from oprojid can also access projid
  # XXX: check type and roles
  for my $r (@oroles) {
    next if $r->{'role'} eq 'bugowner';
    my @rx; 
    if (exists $r->{'userid'}) {
      push @rx, grep {exists($_->{'userid'}) && $_->{'userid'} eq $r->{'userid'}} @roles;
    } elsif (exists $r->{'groupid'}) {
      push @rx, grep {exists($_->{'groupid'}) && $_->{'groupid'} eq $r->{'groupid'}} @roles;
    }
    return 0 unless grep {$_->{'role'} eq $r->{'role'} || $_->{'role'} eq 'maintainer'} @rx;
  }
  return 1;
}

# check if we may access repo $aprp from repo $prp
sub checkprpaccess {
  my ($gctx, $aprp, $prp) = @_;
  return 1 if $aprp eq $prp;
  my ($aprojid, $arepoid) = split('/', $aprp, 2);
  # ok if aprp is not protected
  return 1 if checkaccess($gctx, 'access', $aprojid, undef, $arepoid);
  my ($projid, $repoid) = split('/', $prp, 2);
  # not ok if prp is unprotected
  return 0 if checkaccess($gctx, 'access', $projid, undef, $repoid);
  # both prp and aprp are proteced.
  return 1 if $aprojid eq $projid;	# they hopefully know what they are doing
  # check if publishing flags match unless aprojid is remote
  my $remoteprojs = $gctx->{'remoteprojs'};
  if ((!$remoteprojs->{$aprojid} || $remoteprojs->{$aprojid}->{'partition'}) && !checkaccess($gctx, 'publish', $aprojid, undef, $arepoid)) {
    return 0 if checkaccess($gctx, 'publish', $projid, undef, $repoid);
  }
  # check if the roles match
  return checkroles($gctx, 'access', $aprojid, undef, $projid, undef);
}

#
# sendrepochangeevent - send a repository/repoinfo event
#
# we don't directly send it to the src server, as this would
# slow down the scheduler too much. Instead, we write it on
# disk and the dispatcher will pick it up and send it for us.
#
sub sendrepochangeevent {
  my ($gctx, $prp, $type) = @_;

  my $myarch = $gctx->{'arch'};
  my ($projid, $repoid) = split('/', $prp, 2);
  my $ev = {
    'type' => ($type || 'repository'),
    'project' => $projid,
    'repository' => $repoid,
    'arch' => $myarch,
  };
  sendevent($gctx, $ev, 'repository', "${projid}::${repoid}::${myarch}");
}

#
# sendunblockedevent - send an unblocked event to another scheduler
#
sub sendunblockedevent {
  my ($gctx, $prp, $arch) = @_;

  my ($projid, $repoid) = split('/', $prp, 2);
  my $ev = {
    'type' => 'unblocked',
    'project' => $projid,
    'repository' => $repoid,
  };
  sendevent($gctx, $ev, $arch, "unblocked::${projid}::${repoid}");
}

sub set_repo_state {
  my ($gctx, $prp, $state, $details) = @_;

  my $myarch = $gctx->{'arch'};
  my $reporoot = $gctx->{'reporoot'};
  my $gdst = "$reporoot/$prp/$myarch";
  unlink("$gdst/:schedulerstate.dirty") if $state eq 'scheduling' || $state eq 'broken' || $state eq 'disabled';
  $state .= " $details" if $details;
  mkdir_p($gdst);
  writestr("$gdst/.:schedulerstate", "$gdst/:schedulerstate", $state);
}


# create a delta job
#
# output: $job           - the job identifier
#         $error         - in case we could not start the job
sub createdeltajob {
  my ($ctx, $packid, $suffix, $needdelta) = @_;

  my $gctx = $ctx->{'gctx'};
  my $projid = $ctx->{'project'};
  my $repoid = $ctx->{'repository'};
  my $myarch = $gctx->{'arch'};
  my $job = BSSched::BuildJob::jobname("$projid/$repoid", $packid);
  $job .= "-$suffix" if defined $suffix;
  my $myjobsdir = $gctx->{'myjobsdir'};
  if (-e "$myjobsdir/$job") {
    return undef, 'building'; # delta creation already in progress
  }
  my $srcmd5 = '';
  $srcmd5 .= $_->[2] for @$needdelta;
  $srcmd5 = Digest::MD5::md5_hex($srcmd5);
  my $jobdatadir = "$myjobsdir/$job:dir";
  mkdir_p($jobdatadir);
  BSUtil::cleandir($jobdatadir);
  return (undef, "could not create jobdir") unless -d $jobdatadir;
  for my $delta (@$needdelta) {
    #print Dumper($delta);
    my $deltaid = $delta->[2];
    link($delta->[0], "$jobdatadir/$deltaid.old") || return (undef, "link error: $!");
    link($delta->[1], "$jobdatadir/$deltaid.new") || return (undef, "link error: $!");
    my $qold = Build::Rpm::query("$jobdatadir/$deltaid.old", 'evra' => 1);
    my $qnew = Build::Rpm::query("$jobdatadir/$deltaid.new", 'evra' => 1);
    return (undef, "bad rpms") unless $qold && $qnew;
    return (undef, "name/arch mismatch") if $qold->{'name'} ne $qnew->{'name'} || $qold->{'arch'} ne $qnew->{'arch'};
    $qold->{'epoch'} = '' unless defined $qold->{'epoch'};
    $qnew->{'epoch'} = '' unless defined $qnew->{'epoch'};
    my $info = '';
    $info .= ucfirst($_).": $qnew->{$_}\n" for qw{name epoch version release arch};
    $info .= "Old".ucfirst($_).": $qold->{$_}\n" for qw{name epoch version release arch};
    writestr("$jobdatadir/$deltaid.info", undef, $info);
  }
  # create job
  my $bconf = $ctx->{'conf'};
  my ($eok, @bdeps) = Build::get_build($bconf, [], "deltarpm");
  if (!$eok) {
    print "        unresolvable:\n";
    print "          $_\n" for @bdeps;
    return (undef, "unresolvable: ".join(', ', @bdeps));
  }
  my $now = time();
  my @pdeps = Build::get_preinstalls($bconf);
  my @vmdeps = Build::get_vminstalls($bconf);
  my %runscripts = map {$_ => 1} Build::get_runscripts($bconf);
  my %bdeps = map {$_ => 1} @bdeps;
  my %pdeps = map {$_ => 1} @pdeps;
  my %vmdeps = map {$_ => 1} @vmdeps;
  @bdeps = unify(@pdeps, @vmdeps, @bdeps);
  for (@bdeps) {
    $_ = {'name' => $_}; 
    $_->{'preinstall'} = 1 if $pdeps{$_->{'name'}};
    $_->{'vminstall'} = 1 if $vmdeps{$_->{'name'}};
    $_->{'runscripts'} = 1 if $runscripts{$_->{'name'}};
    $_->{'notmeta'} = 1;
  }
  my $searchpath = BSSched::BuildJob::path2buildinfopath($gctx, $ctx->{'prpsearchpath'});
  my $binfo = {
    'project' => $projid,
    'repository' => $repoid,
    'package' => $packid,
    'file' => '_delta',
    'srcmd5' => $srcmd5,
    'reason' => 'source change',
    'srcserver' => $workersrcserver,
    'reposerver' => $workerreposerver,
    'job' => $job,
    'arch' => $myarch,
    'readytime' => $now,
    'bdep' => \@bdeps,
    'path' => $searchpath,
    'needed' => 0,
  };
  my $obsname = $gctx->{'obsname'};
  $binfo->{'disturl'} = "obs://$obsname/$projid/$repoid/$srcmd5-$packid";
  $binfo->{'hostarch'} = $bconf->{'hostarch'} if $bconf->{'hostarch'};

  writexml("$myjobsdir/.$job", "$myjobsdir/$job", $binfo, $BSXML::buildinfo);
  BSSched::BuildJob::add_crossmarker($gctx, $bconf->{'hostarch'}, $job) if $bconf->{'hostarch'};
  print "    created deltajob...\n";
  return $job;
}

my $exportcnt = 0;

sub createexportjob {
  my ($gctx, $prp, $arch, $packid, $jobrepo, $dst, $oldrepo, $meta, @exports) = @_;

  my $myarch = $gctx->{'arch'};
  # create unique id
  my $now = time();
  # create prefix so that sorting by jobname creates the correct ordering
  my $prefix = sprintf("%08x-%08x-", $now, $exportcnt);
  my $job = "import-$prefix".Digest::MD5::md5_hex("$exportcnt.$$.$myarch.$now");
  $exportcnt++;

  local *F;
  my $jobstatus = {
    'code' => 'finished',
    'result' => 'succeeded',
  };
  my $ajobsdir = "$gctx->{'jobsdir'}/$arch";
  mkdir_p($ajobsdir) unless -d $ajobsdir;
  if (!BSUtil::lockcreatexml(\*F, "$ajobsdir/.$job", "$ajobsdir/$job:status", $jobstatus, $BSXML::jobstatus)) {
    print "job lock failed!\n";
    return;
  }

  my ($projid, $repoid) = split('/', $prp, 2);
  my $info = {
    'project' => $projid,
    'repository' => $repoid,
    'package' => ($packid || ':import'),
    'arch' => $myarch,	# use hostarch instead?
    'job' => $job,
  };
  writexml("$ajobsdir/.$job", "$ajobsdir/$job", $info, $BSXML::buildinfo);
  my $dir = "$ajobsdir/$job:dir";
  mkdir_p($dir);
  if ($meta) {
    link($meta, "$meta.dup");
    rename("$meta.dup", "$dir/meta");
    unlink("$meta.dup");
  }
  my %seen;
  while (@exports) {
    my ($rp, $r) = splice(@exports, 0, 2);
    next unless $r->{'source'};
    link("$dst/$rp", "$dir/$rp") || warn("link $dst/$rp $dir/$rp: $!\n");
    $seen{$r->{'id'}} = 1;
  }
  my @replaced;
  for my $rp (sort keys %$oldrepo) {
    my $r = $oldrepo->{$rp};
    next unless $r->{'source'};	# no src rpms in full tree
    next if $r->{'imported'};	# imported stuff never was re-exported
    next if $seen{$r->{'id'}};
    my $suf;
    $suf = $1 if $rp =~ /\.($binsufsre)$/;
    push @replaced, {'name' => "$r->{'name'}.$suf", 'id' => $r->{'id'}} if $suf;
  }
  if (@replaced) {
    writexml("$dir/replaced.xml", undef, {'name' => 'replaced', 'entry' => \@replaced}, $BSXML::dir);
  }
  close F;
  my $ev = {
    'type' => 'import',
    'job' => $job,
  };
  sendevent($gctx, $ev, $arch, "import.$job");
}

sub orderpackids {
  my ($proj, @packids) = @_;
  $proj ||= {};
  my @s;
  my @back;
  my $kind = $proj->{'kind'} || '';
  for (@packids) {
    if ($_ eq '_volatile') {
      push @back, $_;
    } elsif (/^(.*)\.(\d+)$/) {
      # we ignore the name for maintenance release projects and sort only
      # by the incident number
      if ($kind eq 'maintenance_release') {
        push @s, [ $_, '', $2];
      } else {
        push @s, [ $_, $1, $2];
      }
    } elsif (/^(.*)\.imported_.*?(\d+)$/) {
      # code11 import hack...
      if ($kind eq 'maintenance_release') {
        push @s, [ $_, '', $2 - 1000000];
      } else {
        push @s, [ $_, $1, $2 - 1000000];
      }
    } else {
      push @s, [ $_, $_, 99999999 ];
    }
  }
  @packids = map {$_->[0]} sort { $a->[1] cmp $b->[1] || $b->[2] <=> $a->[2] || $a->[0] cmp $b->[0] } @s;
  push @packids, @back;
  return @packids;
}


sub update_preinstallimage {
  my ($gctx, $prp, $packid, $dst, $jobdir) = @_;
  my $myarch = $gctx->{'arch'};
  my $gdst = "$gctx->{'reporoot'}/$prp/$myarch";
  my $dirty;
  # wipe old
  my $imagedata = BSUtil::retrieve("$gdst/:preinstallimages", 1) || [];
  my $newimagedata = [ grep {$_->{'package'} ne $packid} @$imagedata ];
  if (@$newimagedata != @$imagedata) {
    $dirty = 1;
    $imagedata = $newimagedata;
  }
  my @all;
  @all = grep {/(?:\.tar\.xz|\.tar\.gz|\.info)$/} grep {!/^\./} sort(ls($jobdir)) if $jobdir;
  my %all = map {$_ => 1} @all;
  my @imgs = grep {s/\.info$//} @all;
  for my $img (@imgs) {
    my $tar;
    next if (-s "$jobdir/$img.info") > 100000;
    if (-f "$jobdir/$img.tar.xz") {
      $tar = "$img.tar.xz";
    } elsif (-f "$jobdir/$img.tar.gz") {
      $tar = "$img.tar.gz";
    }
    next unless $tar;
    my @s = stat("$jobdir/$tar");
    next unless @s;
    my $info = readstr("$jobdir/$img.info", 1);
    next unless $info;
    my $id = Digest::MD5::md5_hex("$info/$s[9]/$s[7]/$s[1]");
    # calculate bitstring
    my $b = "\0" x 512;
    my @hdrmd5s;
    my @bins;
    for (split("\n", readstr("$jobdir/$img.info", 1))) {
      next unless /^([0-9a-f]{32})  ([^ ]+)$/s;
      vec($b, hex(substr($1, 0, 3)), 1) = 1;
      push @hdrmd5s, $1;
      push @bins, $2;
    }
    unlink("$jobdir/.preinstallimage.$id");
    link("$jobdir/$tar", "$jobdir/.preinstallimage.$id") || die("link $jobdir/$tar $jobdir/.preinstallimage.$id");
    if ($dst && $dst ne $jobdir) {
      unlink("$dst/.preinstallimage.$id");
      link("$jobdir/.preinstallimage.$id", "$dst/.preinstallimage.$id") || die("link $jobdir/.$id $dst/.preinstallimage.$id");
    }
    my $sizek = int(($s[7] + 1023) / 1024);
    push @$imagedata, {'package' => $packid, 'hdrmd5' => $id, 'file' => $tar, 'sizek' => $sizek, 'bitstring' => $b, 'hdrmd5s' => \@hdrmd5s, 'bins' => \@bins};
    $dirty = 1;
  }
  if ($dirty) {
    if (@$imagedata) {
      BSUtil::store("$gdst/.:preinstallimages", "$gdst/:preinstallimages", $imagedata);
    } else {
      unlink("$gdst/:preinstallimages");
    }
  }
}


####################################################################
####################################################################
##
##  project/package data collection functions
##

#my @prps;		# all prps(project-repositories-sorted) we have to schedule, sorted
#my %prpsearchpath;	# maps prp => [ prp, prp, ...]
                        # build packages with the packages of the prps
#my %prpdeps;		# searchpath plus aggregate deps plus kiwi deps
			# maps prp => [ prp, prp ... ]
			# used for sorting
#my %prpnoleaf;		# is this prp referenced by another prp?
#my @projpacks_linked;	# data of all linked sources

my %_repounchanged;
my %_prpfinished;
my %_prpnotready;	# maps prp => { packid => 1, ... }

my @_retryevents;

my $_maxserverload = 1;
$_maxserverload = $BSConfig::sched_maxserverload if $BSConfig::sched_maxserverload;

sub xrpc_setchanged {
  my ($ctx, $handle) = @_;

  my $gctx = $ctx->{'gctx'};
  die("no gctx in ctx\n") unless $gctx;

  my $changeprp = $handle->{'_changeprp'} || $ctx->{'changeprp'};
  my $changetype = $handle->{'_changetype'} || $ctx->{'changetype'} || 'high';
  my $changelevel = $handle->{'_changelevel'} || $ctx->{'changelevel'} || 1;
  return unless $changeprp;

  my $changed = $gctx->{"changed_$changetype"};
  my $changed_dirty = $gctx->{'changed_dirty'};
  my $lookat = $gctx->{"lookat_$changetype"};
  my $prps = $gctx->{'prps'};
  my ($projid, $repoid) = split('/', $changeprp, 2);
  if (defined($repoid)) {
    my $prp = $changeprp;
    @$lookat = grep {$_ ne $prp} @$lookat;
    unshift @$lookat, $prp;
    if ($changetype eq 'low') {
      # we don't use changed2lookat to prevent infinite looping
      my $prpdeps = $gctx->{'prpdeps'};
      for my $dprp (@$prps) {
	next if $dprp eq $prp;
	$changed->{$dprp} = 1 if grep {$_ eq $prp} @{$prpdeps->{$dprp}};
      }
    } else {
      if ($changelevel == 2) {
        $changed->{$prp} = 2;
      } else {
        $changed->{$prp} ||= 1;
      }
    }
    $changed_dirty->{$prp} = 1;
    return;
  }
  my @cprps;
  for my $prp (@$prps) {
    push @cprps, $prp if (split('/', $prp, 2))[0] eq $projid;
  }
  my %cprps = map {$_ => 1} @cprps;
  @$lookat = grep {!$cprps{$_}} @$lookat;
  if ($changelevel == 2) {
    for my $prp (@cprps) {
      unshift @$lookat, $prp;
      $changed->{$prp} = 2;
      $changed_dirty->{$prp} = 1;
    }
    $changed->{$projid} = 2;
  } else {
    for my $prp (@cprps) {
      unshift @$lookat, $prp;
      $changed->{$prp} ||= 1;
      $changed_dirty->{$prp} = 1;
    }
    $changed->{$projid} ||= 1;
  }
}

sub update_prpcheckuseforbuild {
  my ($gctx, $projid, $proj) = @_;
  my $myarch = $gctx->{'arch'};
  my $prpcheckuseforbuild = $gctx->{'prpcheckuseforbuild'};
  if (!$proj) {
    for my $prp (keys %$prpcheckuseforbuild) {
      delete $prpcheckuseforbuild->{$prp} if (split('/', $prp, 2))[0] eq $projid;
    }
  } else {
    for my $repo (@{$proj->{'repository'}}) {
      next unless grep {$_ eq $myarch} @{$repo->{'arch'} || []};
      $prpcheckuseforbuild->{"$projid/$repo->{'name'}"} = 1;
    }
  }
}

# -> BSUtil
sub identical {
  my ($d1, $d2, $except) = @_;

  if (!defined($d1)) {
    return defined($d2) ? 0 : 1;
  }
  return 0 unless defined($d2);
  my $r = ref($d1);
  return 0 if $r ne ref($d2);
  if ($r eq '') {
    return 0 if $d1 ne $d2; 
  } elsif ($r eq 'HASH') {
    my %k = (%$d1, %$d2);
    for my $k (keys %k) {
      next if $except && $except->{$k};
      return 0 unless identical($d1->{$k}, $d2->{$k}, $except);
    }    
  } elsif ($r eq 'ARRAY') {
    return 0 unless @$d1 == @$d2;
    for (my $i = 0; $i < @$d1; $i++) {
      return 0 unless identical($d1->[$i], $d2->[$i], $except);
    }    
  } else {
    return 0;
  }
  return 1;
}

sub addretryevent {
  my ($gctx, $ev) = @_;
  for my $oev (@{$gctx->{'retryevents'}}) {
    next if $ev->{'type'} ne $oev->{'type'} || $ev->{'project'} ne $oev->{'project'};
    if ($ev->{'type'} eq 'repository' || $ev->{'type'} eq 'recheck') {
      next if $ev->{'repository'} ne $oev->{'repository'};
    } elsif ($ev->{'type'} eq 'package') {
      next if ($ev->{'package'} || '') ne ($oev->{'package'} || '');
    }
    return;
  }
  $ev->{'retry'} = time() + 60;
  push @{$gctx->{'retryevents'}}, $ev;
}

sub getretryevents {
  my ($gctx) = @_;
  my $retryevents = $gctx->{'retryevents'};
  my $now = time();
  my @due = grep {$_->{'retry'} <= $now} @$retryevents;
  return () unless @due;
  @$retryevents = grep {$_->{'retry'} > $now} @$retryevents;
  delete $_->{'retry'} for @due;
  return @due;
}

####################################################################


### remote repository handling

sub addrepo_remote_unpackcpio {
  my ($gctx, $pool, $prp, $arch, $cpio, $solvok, $error) = @_;

  my $repodata;
  my $myarch = $gctx->{'arch'};
  if ($arch eq $myarch) {
    my $repodatas = $gctx->{'repodatas'};
    $repodatas->{$prp} ||= {};
    $repodata = $repodatas->{$prp};
  } else {
    my $repodatas_alien = $gctx->{'repodatas_alien'};
    $repodatas_alien->{"$prp/$arch"} ||= {};
    $repodata = $repodatas_alien->{"$prp/$arch"};
  }
  my $remotecache = $gctx->{'remotecache'};
  my $cachemd5 = Digest::MD5::md5_hex("$prp/$arch");
  substr($cachemd5, 2, 0, '/');

  if ($error) {
    chomp $error;
    warn("$error\n");
    if (BSSched::RPC::is_transient_error($error)) {
      my ($projid, $repoid) = split('/', $prp, 2);
      addretryevent($gctx, {'type' => 'repository', 'project' => $projid, 'repository' => $repoid, 'arch' => $arch});
      if (-s "$remotecache/$cachemd5.solv") {
	# try last solv file
	my $r;
	eval {$r = $pool->repofromfile($prp, "$remotecache/$cachemd5.solv");};
	if ($r) {
	  $repodata->{'lastscan'} = time();
	  $repodata->{'random'} = rand();
	  $repodata->{'solvfile'} = "$remotecache/$cachemd5.solv";
	  return $r;
	}
      }
    }
    $repodata->{'lastscan'} = time();
    $repodata->{'random'} = rand();
    $repodata->{'error'} = $error;
    return undef;
  }

  my %cpio = map {$_->{'name'} => $_->{'data'}} @{$cpio || []};
  my $repostate = $cpio{'repositorystate'};
  $repostate = XMLin($BSXML::repositorystate, $repostate) if $repostate;
  if ($arch eq $myarch) {
    my $prpnotready = $gctx->{'prpnotready'};
    delete $prpnotready->{$prp};
    if ($repostate && $repostate->{'blocked'}) {
      $prpnotready->{$prp} = { map {$_ => 1} @{$repostate->{'blocked'}} };
    }
  }
  my $r;
  my $solv;
  if (exists $cpio{'repositorysolv'} && $solvok) {
    eval {$r = $pool->repofromstr($prp, $cpio{'repositorysolv'}); };
    warn($@) if $@;
  } elsif (exists $cpio{'repositorycache'}) {
    my $cache;
    my $havedod;
    if (defined &BSSolv::thawcache) {
      eval { $cache = BSSolv::thawcache($cpio{'repositorycache'}); };
    } else {
      eval { $cache = BSUtil::fromstorable($cpio{'repositorycache'}); };
    }
    delete $cpio{'repositorycache'};	# free mem
    warn($@) if $@;
    return undef unless $cache;
    delete $cache->{'/url'};
    delete $cache->{'/dodcookie'};
    delete $cache->{'/external/'};
    # free some unused entries to save mem
    for (values %$cache) {
      $havedod = 1 if ($_->{'hdrmd5'} || '') eq 'd0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0';
      delete $_->{'path'};
      delete $_->{'id'};
    }
    # add special "havedod" marker
    $cache->{'/dodcookie'} = 'remote repository with dod packages' if $havedod;
    $r = $pool->repofromdata($prp, $cache);
  } else {
    # return empty repo
    $r = $pool->repofrombins($prp, '');
    $repodata->{'solv'} = $r->tostr();	# small enough to keep it incore
  }
  return undef unless $r;
  # write solv file
  $repodata->{'solvfile'} = "$remotecache/$cachemd5.solv";
  mkdir_p("$remotecache/".substr($cachemd5, 0, 2));
  BSSched::BuildRepo::writesolv("$remotecache/$cachemd5.solv.new$$", "$remotecache/$cachemd5.solv", $r);
  $repodata->{'lastscan'} = time();
  $repodata->{'random'} = rand();
  return $r;
}

sub addrepo_remote_resume {
  my ($ctx, $handle, $error, $cpio) = @_;
  my $gctx = $ctx->{'gctx'};
  my $pool = BSSolv::pool->new();
  my $r = addrepo_remote_unpackcpio($gctx, $pool, $handle->{'_prp'}, $handle->{'_arch'}, $cpio, $handle->{'_solvok'}, $error);
  xrpc_setchanged($ctx, $handle) unless !$r && $error && BSSched::RPC::is_transient_error($error);
}

sub addrepo_remote {
  my ($ctx, $pool, $prp, $arch, $remoteproj) = @_;

  my ($projid, $repoid) = split('/', $prp, 2);
  return undef if !$remoteproj || $remoteproj->{'error'};

  my $cachemd5 = Digest::MD5::md5_hex("$prp/$arch");
  substr($cachemd5, 2, 0, '/');

  my $gctx = $ctx->{'gctx'};
  print "    fetching remote repository state for $prp\n";
  my $param = {
    'uri' => "$remoteproj->{'remoteurl'}/build/$remoteproj->{'remoteproject'}/$repoid/$arch/_repository",
    'timeout' => 200,
    'receiver' => \&BSHTTP::cpio_receiver,
    'proxy' => $gctx->{'remoteproxy'},
  };
  if ($asyncmode) {
    $param->{'async'} = { '_resume' => \&addrepo_remote_resume, '_prp' => $prp, '_arch' => $arch };
  }
  my $cpio;
  my $solvok;
  eval {
    die('unsupported view\n') unless $remoteproj->{'partition'} || defined($BSConfig::usesolvstate) && $BSConfig::usesolvstate;
    $param->{'async'}->{'_solvok'} = 1 if $param->{'async'};
    $cpio = $gctx->{'rctx'}->xrpc($ctx, "repository/$prp/$arch", $param, undef, 'view=solvstate');
    $solvok = 1 if $cpio;
  };
  if ($@ && $@ =~ /unsupported view/) {
    $solvok = undef;
    delete $param->{'async'}->{'_solvok'} if $param->{'async'};
    eval {
      $cpio = $gctx->{'rctx'}->xrpc($ctx, "repository/$prp/$arch", $param, undef, 'view=cache');
    };
  }
  if ($@) {
    return addrepo_remote_unpackcpio($ctx->{'gctx'}, $pool, $prp, $arch, $cpio, undef, $@);
  }
  return 0 if $param->{'async'} && $cpio;	# hack: false but not undef
  return addrepo_remote_unpackcpio($ctx->{'gctx'}, $pool, $prp, $arch, $cpio, $solvok);
}


# add repo belonging to a different architecture
sub addrepo_alien {
  my ($ctx, $pool, $prp, $arch) = @_;

  my $gctx = $ctx->{'gctx'};
  my $repodatas = $gctx->{'repodatas'};
  my $repodatas_alien = $gctx->{'repodatas_alien'};
  my $prpnotready = $gctx->{'prpnotready'};
  $repodatas_alien->{"$prp/$arch"}->{'dontwrite'} = 1;
  my $oldrepodata = $repodatas->{$prp};
  my $oldprpnotready = $prpnotready->{$prp};
  delete $prpnotready->{$prp};
  $repodatas->{$prp} = $repodatas_alien->{"$prp/$arch"};
  my $savemyarch = $gctx->{'arch'};
  $gctx->{'arch'} = $arch;
  my $r = addrepo($ctx, $pool, $prp);
  $gctx->{'arch'} = $savemyarch;
  $repodatas_alien->{"$prp/$arch"} = $repodatas->{$prp};
  delete $repodatas->{$prp};
  $repodatas->{$prp} = $oldrepodata if $oldrepodata;
  delete $prpnotready->{$prp};
  $prpnotready->{$prp} = $oldprpnotready if $oldprpnotready;
  return $r;
}

### remote project binary state handling 

sub convertpackagebinarylist {
  my ($gctx, $prpa, $packagebinarylist, $error, $packstatususer, $isgbininfo) = @_;

  my $remotegbininfos = $gctx->{'remotegbininfos'};
  if ($error) {
    chomp $error;
    warn("$error\n");
    $error ||= 'internal error';
    $remotegbininfos->{$prpa} = { 'lastfetch' => time(), 'error' => $error };
    return (undef, undef);
  }
  my $gbininfo = {};
  my $rpackstatus = {};
  if ($isgbininfo) {
    $gbininfo = $packagebinarylist || {};
    for my $pkg (keys %$gbininfo) {
      my $bi = $gbininfo->{$pkg};
      $rpackstatus->{$pkg} = delete($bi->{'.code'}) if exists $bi->{'.code'};
    }
  } else {
    for my $binaryversionlist (@{$packagebinarylist->{'binaryversionlist'} || []}) {
      my %bins;
      for my $binary (@{$binaryversionlist->{'binary'} || []}) {
	my $filename = $binary->{'name'};
	# XXX: should not rely on the filename here!
	if ($filename =~ /^(?:::import::.*::)?(.+)-[^-]+-[^-]+\.([a-zA-Z][^\.\-]*)\.rpm$/) {
	  $bins{$filename} = {'filename' => $filename, 'name' => $1, 'arch' => $2};
	} elsif ($filename =~ /^([^\/]+)_[^\/]*_([^\/]*)\.deb$/) {
	  $bins{$filename} = {'filename' => $filename, 'name' => $1, 'arch' => $2};
	} elsif ($filename =~ /^([^\/]+)-[^-]+-[^-]+-([a-zA-Z][^\/\.\-]*)\.pkg\.tar\..z$/) {
	  $bins{$filename} = {'filename' => $filename, 'name' => $1, 'arch' => $2};
	} elsif ($filename eq '.nouseforbuild') {
	  $bins{$filename} = {};
	} else {
	  $bins{$filename} = {'filename' => $filename};	# XXX: what about the md5sum for appdata?
	}
	$bins{$filename}->{'hdrmd5'} = $binary->{'hdrmd5'} if $binary->{'hdrmd5'};
	$bins{$filename}->{'leadsigmd5'} = $binary->{'leadsigmd5'} if $binary->{'leadsigmd5'};
      }
      my $pkg = $binaryversionlist->{'package'};
      $gbininfo->{$pkg} = \%bins;
      $rpackstatus->{$pkg} = $binaryversionlist->{'code'} if $binaryversionlist->{'code'};
    }
  }
  my $remotecache = $gctx->{'remotecache'};
  my $cachemd5 = Digest::MD5::md5_hex($prpa);
  substr($cachemd5, 2, 0, '/');
  mkdir_p("$remotecache/".substr($cachemd5, 0, 2));
  BSUtil::store("$remotecache/$cachemd5.bininfo.new$$", "$remotecache/$cachemd5.bininfo", $gbininfo);

  $remotegbininfos->{$prpa} = { 'lastfetch' => time() };

  if ($packstatususer) {
    my $remotepackstatus = $gctx->{'remotepackstatus'};
    my $remotepackstatus_cleanup = $gctx->{'remotepackstatus_cleanup'};
    $rpackstatus->{'/users'} = [];
    $rpackstatus->{'/users'} = [ @{$remotepackstatus->{$prpa}->{'/users'} || []} ] if $remotepackstatus->{$prpa};
    push @{$rpackstatus->{'/users'}}, $packstatususer unless grep {$_ eq $packstatususer} @{$rpackstatus->{'/users'}};
    push @{$remotepackstatus_cleanup->{$packstatususer}}, $prpa;
    $remotepackstatus->{$prpa} = $rpackstatus;
  }

  return ($gbininfo, $rpackstatus);
}

sub cleanup_remotepackstatus {
  my ($gctx, $prp) = @_;

  my $remotepackstatus = $gctx->{'remotepackstatus'};
  my $remotepackstatus_cleanup = $gctx->{'remotepackstatus_cleanup'};
  return unless $remotepackstatus_cleanup->{$prp};
  print "    cleaning up remote packstatus\n";
  for my $prpa (@{$remotepackstatus_cleanup->{$prp}}) {
    my $rpackstatus = $remotepackstatus->{$prpa};
    my @users = grep {$_ ne $prp} @{$rpackstatus->{'/users'} || []};
    $rpackstatus->{'/users'} = \@users;
    print "      - $prpa: ".@users." users\n";
    delete $remotepackstatus->{$prpa} unless @users;
  }
  delete $remotepackstatus_cleanup->{$prp};
}

sub read_gbininfo_remote_resume {
  my ($ctx, $handle, $error, $packagebinarylist) = @_;
  my $gctx = $ctx->{'gctx'};
  convertpackagebinarylist($gctx, $handle->{'_prpa'}, $packagebinarylist, $error, $ctx->{'prp'}, $handle->{'_isgbininfo'});
  xrpc_setchanged($ctx, $handle);
}

sub read_gbininfo_remote {
  my ($ctx, $prpa, $remoteproj, $packstatus) = @_;

  return undef unless $remoteproj;
  return undef if $remoteproj->{'error'};

  my $gctx = $ctx->{'gctx'};
  my $remotegbininfos = $gctx->{'remotegbininfos'};
  my $cachemd5 = Digest::MD5::md5_hex($prpa);
  substr($cachemd5, 2, 0, '/');

  my $now = time();

  # first check error case
  if ($remotegbininfos->{$prpa} && $remotegbininfos->{$prpa}->{'error'} && ($remotegbininfos->{$prpa}->{'lastfetch'} || 0) > $now - 3600) {
    return undef;
  }

  # check if we can use the cache
  my $rpackstatus;
  if ($packstatus) {
    my $remotepackstatus = $gctx->{'remotepackstatus'};
    if ($remotepackstatus->{$prpa} && $asyncmode) {
      my $prp = $ctx->{'prp'};
      $rpackstatus = $remotepackstatus->{$prpa} if grep {$_ eq $prp} @{$remotepackstatus->{$prpa}->{'/users'} || []};
    }
  }
  if ((!$packstatus || $rpackstatus) && $remotegbininfos->{$prpa} && ($remotegbininfos->{$prpa}->{'lastfetch'} || 0) > $now - 3600) {
    my $remotecache = $gctx->{'remotecache'};
    if (-s "$remotecache/$cachemd5.bininfo") {
      my $gbininfo = BSUtil::retrieve("$remotecache/$cachemd5.bininfo", 1);
      if ($gbininfo) {
	if ($packstatus) {
	  for my $pkg (keys %$gbininfo) {
	    $packstatus->{$pkg} = $rpackstatus->{$pkg} if $rpackstatus->{$pkg};
	  }
	}
        return $gbininfo;
      }
    }
  }

  print "    fetching remote project binary state for $prpa\n";
  my ($projid, $repoid, $arch) = split('/', $prpa, 3);
  my $param = {
    'uri' => "$remoteproj->{'remoteurl'}/build/$remoteproj->{'remoteproject'}/$repoid/$arch",
    'timeout' => 200,
    'proxy' => $gctx->{'remoteproxy'},
  };
  if ($asyncmode) {
    $param->{'async'} = { '_resume' => \&read_gbininfo_remote_resume, '_prpa' => $prpa };
  }
  my $packagebinarylist;
  eval {
    if ($remoteproj->{'partition'}) {
      $param->{'async'}->{'_isgbininfo'} = 1 if $asyncmode;
      $packagebinarylist = $gctx->{'rctx'}->xrpc($ctx, "bininfo/$prpa", $param, \&BSUtil::fromstorable, "view=gbininfocode");
    } else {
      $packagebinarylist = $gctx->{'rctx'}->xrpc($ctx, "bininfo/$prpa", $param, $BSXML::packagebinaryversionlist, "view=binaryversionscode");
    }
  };
  if ($@) {
    warn($@);
    my $error = $@;
    $error =~ s/\n$//s;
    ($projid, $repoid) = split('/', $ctx->{'prp'}, 2);
    addretryevent($ctx->{'gctx'}, {'type' => 'recheck', 'project' => $projid, 'repository' => $repoid}) if BSSched::RPC::is_transient_error($error);
    return undef;
  }
  return 0 if $packagebinarylist && $param->{'async'};
  my $gbininfo;
  ($gbininfo, $rpackstatus) = convertpackagebinarylist($gctx, $prpa, $packagebinarylist, undef, undef, $remoteproj->{'partition'} ? 1 : undef);
  if ($packstatus && $rpackstatus) {
    $packstatus->{$_} = $rpackstatus->{$_} for keys %$rpackstatus;
    delete $packstatus->{'/users'};
  }
  return $gbininfo;
}


#
# patch the packstatus entry of package $packid so that it reflects the finished state
# and does not revert back to scheduled
#

sub aggregatefinished {
  my ($ectx, $job, $js) = @_;

  my $gctx = $ectx->{'gctx'};
  my $changed = $gctx->{'changed_med'};
  my $myjobsdir = $gctx->{'myjobsdir'};
  my $myarch = $gctx->{'arch'};
  my $info = readxml("$myjobsdir/$job", $BSXML::buildinfo, 1);
  my $jobdatadir = "$myjobsdir/$job:dir";
  if (!$info || ! -d $jobdatadir) {
    print "  - $job is bad\n";
    return;
  }
  my $projid = $info->{'project'};
  my $repoid = $info->{'repository'};
  my $packid = $info->{'package'};
  if ($info->{'arch'} ne $myarch) {
    print "  - $job has bad arch\n";
    return;
  }
  my $projpacks = $gctx->{'projpacks'};
  if (!$projpacks->{$projid}) {
    print "  - $job belongs to an unknown project\n";
    return;
  }
  my $pdata = ($projpacks->{$projid}->{'package'} || {})->{$packid};
  if (!$pdata) {
    print "  - $job belongs to an unknown package, discard\n";
    return;
  }
  my $prp = "$projid/$repoid";
  my $gdst = "$gctx->{'reporoot'}/$prp/$myarch";
  my $dst = "$gdst/$packid";
  mkdir_p($dst);
  print "  - $prp: $packid aggregate built\n";
  my $useforbuildenabled = 1;
  $useforbuildenabled = BSUtil::enabled($repoid, $projpacks->{$projid}->{'useforbuild'}, $useforbuildenabled, $myarch);
  $useforbuildenabled = BSUtil::enabled($repoid, $pdata->{'useforbuild'}, $useforbuildenabled, $myarch);
  my $prpsearchpath = $gctx->{'prpsearchpath'}->{$prp};
  BSSched::BuildResult::update_dst_full($gctx, $prp, $packid, $jobdatadir, undef, $useforbuildenabled, $prpsearchpath);
  $changed->{$prp} = 2 if $useforbuildenabled;
  my $repounchanged = $gctx->{'repounchanged'};
  delete $repounchanged->{$prp} if $useforbuildenabled;
  $repounchanged->{$prp} = 2 if $repounchanged->{$prp};
  $changed->{$prp} ||= 1;
  unlink("$gdst/:repodone");
  unlink("$gdst/:logfiles.fail/$packid");
  unlink("$gdst/:logfiles.success/$packid");
  unlink("$dst/logfile");
  unlink("$dst/status");
  mkdir_p("$gdst/:meta");
  rename("$jobdatadir/meta", "$gdst/:meta/$packid") || die("rename $jobdatadir/meta $gdst/:meta/$packid: $!\n");
  BSSched::BuildJob::patchpackstatus($gctx, $prp, $packid, 'succeeded');
}

sub deltafinished {
  my ($ectx, $job, $js) = @_;

  my $gctx = $ectx->{'gctx'};
  my $changed = $gctx->{'changed_med'};
  my $myjobsdir = $gctx->{'myjobsdir'};
  my $myarch = $gctx->{'arch'};
  my $info = readxml("$myjobsdir/$job", $BSXML::buildinfo, 1);
  my $jobdatadir = "$myjobsdir/$job:dir";
  if (!$info || ! -d $jobdatadir) {
    print "  - $job is bad\n";
    return;
  }
  my $projid = $info->{'project'};
  my $repoid = $info->{'repository'};
  my $packid = $info->{'package'};
  if ($info->{'arch'} ne $myarch) {
    print "  - $job has bad arch\n";
    return;
  }
  my $projpacks = $gctx->{'projpacks'};
  if (!$projpacks->{$projid}) {
    print "  - $job belongs to an unknown project\n";
    return;
  }
  my $prp = "$projid/$repoid";
  my $gdst = "$gctx->{'reporoot'}/$prp/$myarch";
  my $dst = "$gdst/$packid";
  mkdir_p($dst);
  my $code = $js->{'result'} || 'failed';
  my $status = {'readytime' => $info->{'readytime'} || $info->{'starttime'}};
  BSSched::BuildJob::addjobhist($gctx, $prp, $info, $status, $js, $code);
  if ($code ne 'succeeded') {
    print "  - $job: build failed\n";
    unlink("$dst/logfile");
    rename("$jobdatadir/logfile", "$dst/logfile");
    unlink("$gdst/:repodone");
    return;
  }
  my @all = sort(ls($jobdatadir));
  print "  - $prp: $packid built: ".(@all). " files\n";
  for my $f (@all) {
    next unless $f =~ /^(.*)\.(drpm|out|dseq)$/s;
    my $deltaid = $1;
    if ($2 ne 'dseq') {
      rename("$jobdatadir/$f", "$dst/$deltaid");
    } else {
      rename("$jobdatadir/$f", "$dst/$deltaid.dseq");
    }
  }
  $changed->{$prp} ||= 1;
  unlink("$gdst/:repodone");
  unlink("$dst/logfile");
  rename("$jobdatadir/logfile", "$dst/logfile");
}

sub uploadbuildevent {
  my ($ectx, $job, $js) = @_;

  my $gctx = $ectx->{'gctx'};
  my $myarch = $gctx->{'arch'};
  my $changed = $gctx->{'changed_med'};
  my $myjobsdir = $gctx->{'myjobsdir'};
  my $info = readxml("$myjobsdir/$job", $BSXML::buildinfo, 1);
  my $jobdatadir = "$myjobsdir/$job:dir";
  if (!$info || ! -d $jobdatadir) {
    print "  - $job is bad\n";
    return;
  }
  my $projid = $info->{'project'};
  my $repoid = $info->{'repository'};
  my $packid = $info->{'package'};
  if ($info->{'arch'} ne $myarch) {
    print "  - $job has bad arch\n";
    return;
  }
  my $projpacks = $gctx->{'projpacks'};
  if (!$projpacks->{$projid}) {
    print "  - $job belongs to an unknown project\n";
    return;
  }
  my $pdata = ($projpacks->{$projid}->{'package'} || {})->{$packid};
  if (!$pdata) {
    print "  - $job belongs to an unknown package, discard\n";
    return;
  }
  my $prp = "$projid/$repoid";
  my $gdst = "$gctx->{'reporoot'}/$prp/$myarch";
  my $dst = "$gdst/$packid";
  mkdir_p($dst);
  print "  - $prp: $packid uploaded\n";
  my $useforbuildenabled = 1;
  $useforbuildenabled = BSUtil::enabled($repoid, $projpacks->{$projid}->{'useforbuild'}, $useforbuildenabled, $myarch);
  $useforbuildenabled = BSUtil::enabled($repoid, $pdata->{'useforbuild'}, $useforbuildenabled, $myarch);
  my $prpsearchpath = $gctx->{'prpsearchpath'}->{$prp};
  BSSched::BuildResult::update_dst_full($gctx, $prp, $packid, $jobdatadir, undef, $useforbuildenabled, $prpsearchpath);
  $changed->{$prp} = 2 if $useforbuildenabled;
  my $repounchanged = $gctx->{'repounchanged'};
  delete $repounchanged->{$prp} if $useforbuildenabled;
  $repounchanged->{$prp} = 2 if $repounchanged->{$prp};
  $changed->{$prp} ||= 1;
  unlink("$gdst/:repodone");
}

sub importevent {
  my ($ectx, $job, $js) = @_;

  my $gctx = $ectx->{'gctx'};
  my $changed = $gctx->{'changed_med'};
  my $myjobsdir = $gctx->{'myjobsdir'};
  my $myarch = $gctx->{'arch'};
  my $info = readxml("$myjobsdir/$job", $BSXML::buildinfo, 1);
  my $jobdatadir = "$myjobsdir/$job:dir";
  if (!$info || ! -d $jobdatadir) {
    print "  - $job is bad\n";
    return;
  }
  my $projid = $info->{'project'};
  my $repoid = $info->{'repository'};
  my $packid = $info->{'package'};
  my $projpacks = $gctx->{'projpacks'};
  if (!$projpacks->{$projid}) {
    print "  - $job belongs to an unknown project\n";
    return;
  }
  my $importarch = $info->{'arch'} || 'unknown';
  my $prp = "$projid/$repoid";
  my $gdst = "$gctx->{'reporoot'}/$prp/$myarch";
  my @all = ls($jobdatadir);
  my %all = map {$_ => 1} @all;
  my $meta = $all{'meta'} ? "$jobdatadir/meta" : undef;
  @all = map {"$jobdatadir/$_"} @all;
  my $pdata = ($projpacks->{$projid}->{'package'} || {})->{$packid} || {};
  print "  - $prp: $packid imported from $importarch\n";
  my $useforbuildenabled = 1;
  $useforbuildenabled = BSUtil::enabled($repoid, $projpacks->{$projid}->{'useforbuild'}, $useforbuildenabled, $myarch);
  $useforbuildenabled = BSUtil::enabled($repoid, $pdata->{'useforbuild'}, $useforbuildenabled, $myarch);
  my $prpsearchpath = $gctx->{'prpsearchpath'}->{$prp};
  BSSched::BuildResult::update_dst_full($gctx, $prp, $packid, $jobdatadir, $meta, $useforbuildenabled, $prpsearchpath, undef, $importarch);
  $changed->{$prp} = 2 if $useforbuildenabled;
  my $repounchanged = $gctx->{'repounchanged'};
  delete $repounchanged->{$prp} if $useforbuildenabled;
  unlink($_) for @all;
  rmdir($jobdatadir);
}

##########################################################################
##########################################################################
##
##

sub metacheck {
  my ($ctx, $packid, $buildtype, $new_meta, $data) = @_;
  
  my $gctx = $ctx->{'gctx'};
  my $prp = $ctx->{'prp'};
  my $gdst = $ctx->{'gdst'};
  my @meta = split("\n", (readstr("$gdst/:meta/$packid", 1) || ''));
  if (!@meta) {
    print "      - $packid ($buildtype)\n";
    print "        no former build, start build\n";
    return ('scheduled', [ @$data, {'explain' => 'new build'} ]);
  }
  if ($meta[0] ne $new_meta->[0]) {
    print "      - $packid ($buildtype)\n";
    print "        src change, start build\n";
    return ('scheduled', [ @$data, {'explain' => 'source change', 'oldsource' => substr($meta[0], 0, 32)} ]);
  }
  if (@meta == 2 && $meta[1] =~ /^fake/) {
    my @s = stat("$gdst/:meta/$packid");
    if (!@s || $s[9] + 14400 > time()) {
      print "      - $packid ($buildtype)\n";
      print "        buildsystem setup failure\n";
      return ('failed')
    }
    print "      - $packid ($buildtype)\n";
    print "        retrying bad build\n";
    return ('scheduled', [ @$data, { 'explain' => 'retrying bad build' } ]);
  }
  if (join('\n', @meta) eq join('\n', @$new_meta)) {
    if (($buildtype eq 'kiwi-image' || $buildtype eq 'kiwi-product') && $ctx->{'relsynctrigger'}->{$packid}) {
      print "      - $packid ($buildtype)\n";
      print "        rebuild counter sync\n";
      return ('scheduled', [ @$data, {'explain' => 'rebuild counter sync'} ]);
    }
    #print "      - $packid ($buildtype)\n";
    #print "        nothing changed\n";
    return ('done');
  }
  my $repo = $ctx->{'repo'}; 
  if ($buildtype eq 'kiwi-image' || $buildtype eq 'kiwi-product') {
    my $rebuildmethod = $repo->{'rebuild'} || 'transitive';
    if ($rebuildmethod eq 'local') {
      #print "      - $packid ($buildtype)\n";
      #print "        nothing changed\n";
      return ('done');
    }
  }
  my @diff = diffsortedmd5(\@meta, $new_meta);
  print "      - $packid ($buildtype)\n";
  print "        $_\n" for @diff;
  print "        meta change, start build\n";
  return ('scheduled', [ @$data, {'explain' => 'meta change', 'packagechange' => sortedmd5toreason(@diff)} ]);
}


##########################################################################
##########################################################################
##
##  kiwi-image package type handling
##
sub checkkiwiimage {
  my ($ctx, $packid, $pdata, $info) = @_;

  my $gctx = $ctx->{'gctx'};
  my $myarch = $gctx->{'arch'};
  my $projid = $ctx->{'project'};
  my $repoid = $ctx->{'repository'};
  my $prp = $ctx->{'prp'};
  my $repo = $ctx->{'repo'};

  my @aprps = expandkiwipath($info, $ctx->{'prpsearchpath'});
  # get config from path
  my $bconf = getconfig($gctx, $myarch, \@aprps);
  if (!$bconf) {
    print "      - $packid (kiwi-image)\n";
    print "        no config\n";
    return ('broken', 'no config');
  }

  my $pool = BSSolv::pool->new();
  $pool->settype('deb') if $bconf->{'binarytype'} eq 'deb';

  my $delayed_errors = '';
  for my $aprp (@aprps) {
    if (!checkprpaccess($gctx, $aprp, $prp)) {
      print "      - $packid (kiwi-image)\n";
      print "        repository $aprp is unavailable";
      return ('broken', "repository $aprp is unavailable");
    }
    my $r = addrepo($ctx, $pool, $aprp);
    if (!$r) {
      my $error = "repository '$aprp' is unavailable";
      if (defined $r) {
        $error .= " (delayed)";
        $delayed_errors .= ", $error";
        next;
      }
      print "      - $packid (kiwi-image)\n";
      print "        $error\n";
      return ('broken', $error);
    }
  }
  return ('delayed', substr($delayed_errors, 2)) if $delayed_errors;
  $pool->createwhatprovides();
  my $bconfignore = $bconf->{'ignore'};
  my $bconfignoreh = $bconf->{'ignoreh'};
  delete $bconf->{'ignore'};
  delete $bconf->{'ignoreh'};
  my @deps = @{$info->{'dep'} || []};
  my $xp = BSSolv::expander->new($pool, $bconf);
  no warnings 'redefine';
  local *Build::expand = sub { $_[0] = $xp; goto &BSSolv::expander::expand; };
  use warnings 'redefine';
  my ($eok, @edeps) = Build::get_build($bconf, [], @deps, '--ignoreignore--');
  if (!$eok) {
    print "      - $packid (kiwi-image)\n";
    print "        unresolvable:\n";
    print "            $_\n" for @edeps;
    return ('unresolvable', join(', ', @edeps));
  }
  $bconf->{'ignore'} = $bconfignore if $bconfignore;
  $bconf->{'ignoreh'} = $bconfignoreh if $bconfignoreh;

  my @new_meta;

  my %dep2pkg;
  for my $p ($pool->consideredpackages()) {
    my $n = $pool->pkg2name($p);
    $dep2pkg{$n} = $p;
  }

  my $notready = $ctx->{'notready'};
  my $prpnotready = $gctx->{'prpnotready'};
  my %nrs;
  for my $arepo ($pool->repos()) {
    my $aprp = $arepo->name();
    if (!$repo->{'block'} || $repo->{'block'} ne 'never') {
      $nrs{$aprp} = ($prp eq $aprp ? $notready : $prpnotready->{$aprp}) || {};
    } else {
      $nrs{$aprp} = {};
    }
  }
  
  my @blocked;
  for my $n (sort @edeps) {
    my $p = $dep2pkg{$n};
    my $aprp = $pool->pkg2reponame($p);
    push @blocked, $prp ne $aprp ? "$aprp/$n" : $n if $nrs{$aprp}->{$n};
    push @new_meta, $pool->pkg2pkgid($p)."  $aprp/$n" unless @blocked;
  }
  if (@blocked) {
    print "      - $packid (kiwi-image)\n";
    print "        blocked (@blocked)\n";
    return ('blocked', join(', ', @blocked));
  }
  @new_meta = sort {substr($a, 34) cmp substr($b, 34)} @new_meta;
  unshift @new_meta, map {"$_->{'srcmd5'}  $_->{'project'}/$_->{'package'}"} @{$info->{'extrasource'} || []};
  unshift @new_meta, ($pdata->{'verifymd5'} || $pdata->{'srcmd5'})."  $packid";
  my ($state, $data) = metacheck($ctx, $packid, 'kiwi-image', \@new_meta, [ $bconf, \@edeps ]);
  if ($BSConfig::enable_download_on_demand && $state eq 'scheduled') {
    my $dods = BSSched::DoD::dodcheck($ctx, $pool, $myarch, @edeps);
    return ('blocked', $dods) if $dods;
  }
  return ($state, $data);
}

sub rebuildkiwiimage {
  my ($ctx, $packid, $pdata, $info, $data) = @_;
  my $bconf = $data->[0];
  my $edeps = $data->[1];
  my $reason = $data->[2];

  my $gctx = $ctx->{'gctx'};
  my $projid = $ctx->{'project'};
  my $repoid = $ctx->{'repository'};
  my $repo = $ctx->{'repo'};

  if (!@{$repo->{'path'} || []}) {
    # repo has no path, use kiwi repositories also for kiwi system setup
    my $prp = "$projid/$repoid";
    my @aprps = expandkiwipath($info, $ctx->{'prpsearchpath'});
    # setup pool again for kiwi system expansion
    my $pool = BSSolv::pool->new();
    $pool->settype('deb') if $bconf->{'binarytype'} eq 'deb';
    for my $aprp (@aprps) {
      if (!checkprpaccess($gctx, $aprp, $prp)) {
	print "      - $packid (kiwi-image)\n";
	print "        repository $aprp is unavailable";
	return ('broken', "repository $aprp is unavailable");
      }
      my $r = addrepo($ctx, $pool, $aprp);
      if (!$r) {
	my $error = "repository '$aprp' is unavailable";
	$error .= " (delayed)" if defined $r;
        print "      - $packid (kiwi-image)\n";
        print "        $error\n";
        return ('delayed', $error) if defined $r;
        return ('broken', $error);
      }
    }
    $pool->createwhatprovides();
    my $xp = BSSolv::expander->new($pool, $bconf);
    no warnings 'redefine';
    local *Build::expand = sub { $_[0] = $xp; goto &BSSolv::expander::expand; };
    use warnings 'redefine';
    return BSSched::BuildJob::create({ %$ctx, 'conf' => $bconf, 'prpsearchpath' => [], 'pool' => $pool }, $packid, $pdata, $info, [], $edeps, $reason, 0);
  } else {
    # repo has a configured path, expand kiwi system with it
    my $prp = "$projid/$repoid";
    return ('broken', 'no config') unless $bconf;	# should not happen
    return BSSched::BuildJob::create($ctx, $packid, $pdata, $info, [], $edeps, $reason, 0);
  }
}

##########################################################################
##########################################################################
##
##  kiwi-product package type handling
##
my %bininfo_oldok_cache;

sub read_bininfo_oldok {
  my ($dir) = @_;
  my @s = stat("$dir/.bininfo");
  if (@s) {
    my $bininfo = BSUtil::retrieve("$dir/.bininfo", 1);
    if ($bininfo) {
      $bininfo->{'.bininfo'} = {'id' => "$s[9]/$s[7]/$s[1]"};
      return $bininfo;
    }
    # check the old format cache
    $bininfo = $bininfo_oldok_cache{$dir};
    return $bininfo if $bininfo && $bininfo->{'.bininfo'}->{'id'} eq "$s[9]/$s[7]/$s[1]";
    local *F;
    if (open(F, '<', "$dir/.bininfo")) {
      $bininfo = {};
      while (<F>) {
	chomp;
        if (length($_) <= 34 || substr($_, 32, 2) ne '  ') {
	  # seems to be a corrupt file
	  undef $bininfo;
	  last;
	}
	my $file = substr($_, 34);
	next unless $file =~ /^(?:::import::.*::)?(.+)-[^-]+-[^-]+\.([a-zA-Z][^\.\-]*)\.rpm$/;
	$bininfo->{$file} = {'filename' => $file, 'hdrmd5' => substr($_, 0, 32), 'name' => $1, 'arch' => $2};
      }
      close(F);
      if ($bininfo) {
        $bininfo->{'.bininfo'} = {'id' => "$s[9]/$s[7]/$s[1]"};
        $bininfo_oldok_cache{$dir} = $bininfo;
        return $bininfo;
      }
    }
  }
  my $bininfo = {};
  for my $file (ls($dir)) {
    next unless $file =~ /^(?:::import::.*::)?(.+)-[^-]+-[^-]+\.([a-zA-Z][^\.\-]*)\.rpm$/;
    $bininfo->{$file} = {'filename' => $file, 'name' => $1, 'arch' => $2};
  }
  return $bininfo;
}

sub checkkiwiproduct {
  my ($ctx, $packid, $pdata, $info) = @_;

  my $gctx = $ctx->{'gctx'};
  my $myarch = $gctx->{'arch'};
  my $projid = $ctx->{'project'};
  my $repoid = $ctx->{'repository'};
  my $repo = $ctx->{'repo'};
  my $prp = "$projid/$repoid";
  my $reporoot = $gctx->{'reporoot'};

  # hmm, should get the arch from the kiwi info
  # but how can we map it to the buildarchs?

  # calculate all involved architectures
  my $buildarch = ($repo->{'arch'} || [])->[0] || '';
  # compat to old OBS versions, prefer local...
  $buildarch = 'local' if $BSConfig::localarch && grep {$_ eq 'local'} @{$repo->{'arch'} || []};
  # localbuildarch is where we take the buildenv from
  my $localbuildarch = $buildarch eq 'local' && $BSConfig::localarch ? $BSConfig::localarch : $buildarch;
  my $markerdir = "$reporoot/$projid/$repoid/$buildarch/$packid";

  my %imagearch = map {$_ => 1} @{$info->{'imagearch'} || []};
  return ('broken', 'no architectures for packages') unless grep {$imagearch{$_}} @{$repo->{'arch'} || []};
  my @archs = grep {$imagearch{$_}} @{$repo->{'arch'} || []};

  if ($myarch ne $buildarch && $myarch ne $localbuildarch) {
    if (!grep {$_ eq $myarch} @archs) {
      print "      - $packid (kiwi-product)\n";
      print "        not mine\n";
      return ('excluded');
    }
  }

  my @deps = @{$info->{'dep'} || []};	# expanded?
  my %deps = map {$_ => 1} @deps;
  delete $deps{''};

  my @aprps = expandkiwipath($info, $ctx->{'prpsearchpath'});
  my @bprps = @{$ctx->{'prpsearchpath'}};
  my $bconf = $ctx->{'conf'};

  if (!@{$repo->{'path'} || []}) {
    # have no configured path, use repos from kiwi file instead
    @bprps = @aprps;
    $bconf = getconfig($gctx, $myarch, \@bprps);
    if (!$bconf) {
      print "      - $packid (kiwi-product)\n";
      print "        no config\n";
      return ('broken', 'no config');
    }
  }

  my @blocked;
  my @rpms;
  my %rpms_meta;
  my %rpms_hdrmd5;

#print "prps: @aprps\n";
#print "archs: @archs\n";
#print "deps: @deps\n";
  if ($myarch eq $buildarch || $myarch eq $localbuildarch) {
    # calculate packages needed for building
    my $pool = BSSolv::pool->new();
    $pool->settype('deb') if $bconf->{'binarytype'} eq 'deb';
    my $delayed_errors = '';
    for my $aprp (@bprps) {
      if (!checkprpaccess($gctx, $aprp, $prp)) {
	print "      - $packid (kiwi-product)\n";
	print "        repository $aprp is unavailable";
	return ('broken', "repository $aprp is unavailable");
      }
      my $r = $localbuildarch eq $myarch ? addrepo($ctx, $pool, $aprp) : addrepo_alien($ctx, $pool, $aprp, $localbuildarch);
      if (!$r) {
	my $error = "repository '$aprp' is unavailable";
	$error .= " (delayed)" if defined $r;
	print "      - $packid (kiwi-product)\n";
	print "        $error\n";
	if (defined $r) {
          $delayed_errors .= ", $error";
          next;
        }
	return ('broken', $error);
      }
    }
    return ('delayed', substr($delayed_errors, 2)) if $delayed_errors;
    $pool->createwhatprovides();
    my $xp = BSSolv::expander->new($pool, $bconf);
    no warnings 'redefine';
    local *Build::expand = sub { $_[0] = $xp; goto &BSSolv::expander::expand; };
    use warnings 'redefine';
    my ($eok, @kdeps) = Build::get_sysbuild($bconf, 'kiwi-product', [ grep {/^kiwi-.*:/} @{$info->{'dep'} || []} ]);
    if (!$eok) {
      print "      - $packid (kiwi-product)\n";
      print "        unresolvable for sysbuild:\n";
      print "          $_\n" for @kdeps;
      return ('unresolvable', join(', ', @kdeps));
    }
    my %dep2pkg;
    for my $p ($pool->consideredpackages()) {
      $dep2pkg{$pool->pkg2name($p)} = $p;
    }
    # check access
    for my $aprp (@aprps) {
      if (!checkprpaccess($gctx, $aprp, $prp)) {
	print "      - $packid (kiwi-product)\n";
	print "        repository $aprp is unavailable for sysbuild";
	return ('broken', "repository $aprp is unavailable");
      }
    }
    # check if we are blocked
    if ($myarch ne $localbuildarch) {
      my %used;
      for my $bin (@kdeps) {
        my $p = $dep2pkg{$bin};
        my $aprp = $pool->pkg2reponame($p);
        my $pname = $pool->pkg2srcname($p);
        push @{$used{$aprp}}, $pname;
      }
      for my $aprp (@aprps) {
        my %pnames = map {$_ => 1} @{$used{$aprp}};
	next unless %pnames;
	# FIXME: does not work for remote repos
	my $ps = BSUtil::retrieve("$reporoot/$aprp/$localbuildarch/:packstatus", 1);
	if (!$ps) {
	  $ps = (readxml("$reporoot/$aprp/$localbuildarch/:packstatus", $BSXML::packstatuslist, 1) || {})->{'packstatus'} || [];
	  $ps = { 'packstatus' => { map {$_->{'name'} => $_->{'status'}} @$ps } };
	}
        $ps = ($ps || {})->{'packstatus'} || {};
	# FIXME: this assumes packid == pname
	push @blocked, grep {$ps->{$_} && ($ps->{$_} eq 'scheduled' || $ps->{$_} eq 'blocked' || $ps->{$_} eq 'finished')} sort keys %pnames;
      }
      if (@blocked) {
	if (! -e "$markerdir/.waiting_for_$localbuildarch") {
          mkdir_p($markerdir);
          BSUtil::touch("$markerdir/.waiting_for_$localbuildarch");
	}
      } else {
	unlink("$markerdir/.waiting_for_$localbuildarch");
      }
    } else {
      my $notready = $ctx->{'notready'};
      my $prpnotready = $gctx->{'prpnotready'};
      for my $bin (@kdeps) {
        my $p = $dep2pkg{$bin};
        my $aprp = $pool->pkg2reponame($p);
        my $pname = $pool->pkg2srcname($p);
        my $nr = ($prp eq $aprp ? $notready : $prpnotready->{$aprp}) || {};
        push @blocked, $bin if $nr->{$pname};
      }
    }
    if (@blocked) {
      print "      - $packid (kiwi-product)\n";
      print "        blocked for sysbuild (@blocked)\n";
      return ('blocked', join(', ', @blocked));
    }
    push @rpms, @kdeps;
    if ($BSConfig::enable_download_on_demand && $myarch eq $buildarch) {
      my $dods = BSSched::DoD::dodcheck($ctx, $pool, $localbuildarch, @kdeps);
      return ('blocked', $dods) if $dods;
    }
  }

  my $allpacks = $deps{'*'} ? 1 : 0;
  my $nodbgpkgs = $info->{'nodbgpkgs'};
  my $nosrcpkgs = $info->{'nosrcpkgs'};

  my $maxblocked = 20;
  my %blockedarch;
  my $delayed_errors = '';
  my $projpacks = $gctx->{'projpacks'};
  my $remoteprojs = $gctx->{'remoteprojs'};
  for my $aprp (@aprps) {
    my %known;
    my ($aprojid, $arepoid) = split('/', $aprp, 2);
    my $aproj = $projpacks->{$aprojid} || {};
    $aproj = $remoteprojs->{$aprojid} if $remoteprojs->{$aprojid};
    my $pdatas = $aproj->{'package'} || {};
    my @apackids = sort keys %$pdatas;
    for my $apackid (@apackids) {
      next if $pdatas->{$apackid}->{'patchinfo'};
      my $info = (grep {$_->{'repository'} eq $arepoid} @{$pdatas->{$apackid}->{'info'} || []})[0];
      $known{$apackid} = $info->{'name'} if $info && $info->{'name'};
    }
    for my $arch (@archs) {
      next if $myarch ne $buildarch && $myarch ne $arch;
      my $ps = BSUtil::retrieve("$reporoot/$aprp/$arch/:packstatus", 1);
      if (!$ps) {
	$ps = (readxml("$reporoot/$aprp/$arch/:packstatus", $BSXML::packstatuslist, 1) || {})->{'packstatus'} || [];
	$ps = { 'packstatus' => { map {$_->{'name'} => $_->{'status'}} @$ps } };
      }
      $ps = ($ps || {})->{'packstatus'} || {};

      my $gbininfo;
      if ($remoteprojs->{$aprojid}) {
        $gbininfo = read_gbininfo_remote($ctx, "$aprp/$arch", $remoteprojs->{$aprojid}, $ps);
	if (!$gbininfo) {
	  my $error = "project binary state of $aprp/$arch is unavailable";
	  $error .= " (delayed)" if defined $gbininfo;
	  print "      - $packid (kiwi-product)\n";
	  print "        $error\n";
	  if (defined $gbininfo) {
	    $delayed_errors .= ", $error";
	    next;
	  }
	  return ('broken', $error);
	}
      } else {
        $gbininfo = BSSched::BuildResult::read_gbininfo("$reporoot/$aprp/$arch", $arch eq $myarch ? 0 : 1);
      }
      next if $delayed_errors;
      if (!$gbininfo && $arch ne $myarch && -d "$gctx->{'eventdir'}/$arch") {
        # mis-use unblocked to tell other scheduler that it is missing
        print "    requesting :repoinfo for $aprp/$arch\n";
	sendunblockedevent($gctx, $aprp, $arch);
      }
      @apackids = unify(@apackids, sort keys %$gbininfo) if $gbininfo;

      # just for maintenance_release project handling, in that case we
      # use the binary from the container with the highest number if
      # some containers contain the same binary.
      my $seen_binary;
      $seen_binary = {} if ($aproj->{'kind'} || '') eq 'maintenance_release';

      for my $apackid (orderpackids($aproj, @apackids)) {
        next if $apackid eq '_volatile';
        next if ($pdatas->{$apackid} || {})->{'patchinfo'};

        if (($allpacks && !$deps{"-$apackid"} && !$deps{'-'.($known{$apackid} || '')}) || $deps{$apackid} || $deps{$known{$apackid} || ''}) {
	  # hey, we probably need this package! wait till it's finished
	  my $code = $ps->{$apackid} || 'unknown';
	  if ($code eq 'scheduled' || $code eq 'blocked' || $code eq 'finished') {
	    push @blocked, "$aprp/$arch/$apackid";
	    $blockedarch{$arch} = 1;
	    last if @blocked > $maxblocked;
	    next;
	  }
        }

        # hmm, we don't know if we really need it. check bininfo.
	my $bininfo;
	if ($gbininfo) {
	  $bininfo = $gbininfo->{$apackid} || {};
	} else {
	  $bininfo = read_bininfo_oldok("$reporoot/$aprp/$arch/$apackid");
	}

	# skip channels/patchinfos
	next if $bininfo->{'.nouseforbuild'};

	my @got;
	my $needit;
	my @bi = sort(keys %$bininfo);
	# put imports last
	my @ibi = grep {/^::import::/} @bi;
	if (@ibi) {
	  @bi = grep {!/^::import::/} @bi;
	  push @bi, @ibi;
	}
	for my $fn (@bi) {
	  next unless $fn =~ /\.rpm$/;
	  next if $nodbgpkgs && $fn =~ /-(?:debuginfo|debugsource)-/;
	  next if $nosrcpkgs && $fn =~ /\.(?:nosrc|src)\.rpm$/;
	  if ($fn =~ /^::import::.*?::(.*)$/) {
	    # ignore import if we already got the package (can happen with aggregates)
	    next if $rpms_meta{"$aprp/$arch/$apackid/$1"};
 	  }
	  my $b = $bininfo->{$fn};
	  if ($seen_binary) {
	    next if $seen_binary->{"$b->{'name'}.$b->{'arch'}"};
	    $seen_binary->{"$b->{'name'}.$b->{'arch'}"} = 1;
	  }
	  $needit = 1 if $deps{$b->{'name'}} || ($allpacks && !$deps{"-$b->{'name'}"});
	  push @got, "$aprp/$arch/$apackid/$fn";
	  $rpms_hdrmd5{$got[-1]} = $b->{'hdrmd5'} if $b->{'hdrmd5'};
	  $rpms_meta{$got[-1]} = "$aprp/$arch/$apackid/$b->{'name'}.$b->{'arch'}";
        }
	next unless $needit;
	# ok we need it. check if the package is built.
	my $code = $ps->{$apackid} || 'unknown';
	if ($code eq 'scheduled' || $code eq 'blocked' || $code eq 'finished') {
	  push @blocked, "$aprp/$arch/$apackid";
	  $blockedarch{$arch} = 1;
	  last if @blocked > $maxblocked;
	  next;
        }
	push @rpms, @got;
      }
      last if @blocked > $maxblocked;
    }
    last if @blocked > $maxblocked;
  }
  return ('delayed', substr($delayed_errors, 2)) if $delayed_errors;
  if ($myarch eq $buildarch) {
    # update waiting_for markers
    for my $arch (grep {$_ ne $buildarch} @archs) {
      if ($blockedarch{$arch}) {
	next if -e "$markerdir/.waiting_for_$arch";
        mkdir_p($markerdir);
        BSUtil::touch("$markerdir/.waiting_for_$arch");
      } else {
	unlink("$markerdir/.waiting_for_$arch");
      }
    }
  }
  if (@blocked) {
    push @blocked, '...' if @blocked > $maxblocked;
    print "      - $packid (kiwi-product)\n";
    print "        blocked (@blocked)\n";
    return ('blocked', join(', ', @blocked));
  }

  if ($myarch ne $buildarch) {
    # looks good from our side. tell master arch to check it
    if (-e "$markerdir/.waiting_for_$myarch") {
      unlink("$markerdir/.waiting_for_$myarch");
      sendunblockedevent($gctx, $prp, $buildarch);
      print "      - $packid (kiwi-product)\n";
      print "        unblocked\n";
    }
    return ('excluded', "is built in architecture '$buildarch'");
  }

  # now create meta info
  my @new_meta;
  push @new_meta, ($pdata->{'verifymd5'} || $pdata->{'srcmd5'})."  $packid";
  push @new_meta, map {"$_->{'srcmd5'}  $_->{'project'}/$_->{'package'}"} @{$info->{'extrasource'} || []};
  for my $rpm (sort {$rpms_meta{$a} cmp $rpms_meta{$b} || $a cmp $b} grep {$rpms_meta{$_}} @rpms) {
    my $id = $rpms_hdrmd5{$rpm};
    eval { $id ||= Build::queryhdrmd5("$reporoot/$rpm"); };
    $id ||= "deaddeaddeaddeaddeaddeaddeaddead";
    push @new_meta, "$id  $rpms_meta{$rpm}";
  }
  return metacheck($ctx, $packid, 'kiwi-product', \@new_meta, [ $bconf, \@rpms ]);
}

sub rebuildkiwiproduct {
  my ($ctx, $packid, $pdata, $info, $data) = @_;

  my $gctx = $ctx->{'gctx'};
  my $myarch = $gctx->{'arch'};
  my $projid = $ctx->{'project'};
  my $repoid = $ctx->{'repository'};
  my $repo = $ctx->{'repo'};
  my $relsyncmax = $ctx->{'relsyncmax'};
  my $remoteprojs = $gctx->{'remoteprojs'};

  my $bconf = $data->[0];
  my $rpms = $data->[1];
  my $reason = $data->[2];
  my $prp = "$projid/$repoid";
  my $srcmd5 = $pdata->{'srcmd5'};
  my $job = BSSched::BuildJob::jobname($prp, $packid);
  my $myjobsdir = $gctx->{'myjobsdir'};
  return ('scheduled', "$job-$srcmd5") if -s "$myjobsdir/$job-$srcmd5";
  my @otherjobs = grep {/^\Q$job\E-[0-9a-f]{32}$/} ls($myjobsdir);
  $job = "$job-$srcmd5";

  # kill those ancient other jobs
  for my $otherjob (@otherjobs) {
    print "        killing old job $otherjob\n";
    BSSched::BuildJob::killjob($ctx->{'gctx'}, $otherjob);
  }

  my $localbuildarch = $myarch eq 'local' && $BSConfig::localarch ? $BSConfig::localarch : $myarch;
  my $now = time(); # ensure that we use the same time in all logs

  my $syspath;
  if (@{$repo->{'path'} || []}) {
    # images repo has a configured path, use it to set up the kiwi system
    $syspath = [];
    my $prpsearchpath = $gctx->{'prpsearchpath'}->{$prp};
    for (@$prpsearchpath) {
      my @pr = split('/', $_, 2);
      my $server = $workerreposerver;
      if ($remoteprojs->{$pr[0]}) {
	$server = $workersrcserver;
	my $par = $remoteprojs->{$pr[0]}->{'partition'};
	if ($par) {
	  # XXX: should also come from src server
	  $server = ($BSConfig::workerpartitionservers || {})->{$par} || $remoteprojs->{$pr[0]}->{'remoteurl'};
	}
      }
      push @$syspath, {'project' => $pr[0], 'repository' => $pr[1], 'server' => $server};
    }
  }
  my @aprps = expandkiwipath($info, $ctx->{'prpsearchpath'});
  my $searchpath = [];
  for (@aprps) {
    my @pr = split('/', $_, 2);
    my $server = $workerreposerver;
    if ($remoteprojs->{$pr[0]}) {
      $server = $workersrcserver;
      my $par = $remoteprojs->{$pr[0]}->{'partition'};
      if ($par) {
	# XXX: should also come from src server
	$server = ($BSConfig::workerpartitionservers || {})->{$par} || $remoteprojs->{$pr[0]}->{'remoteurl'};
      }
    }
    push @$searchpath, {'project' => $pr[0], 'repository' => $pr[1], 'server' => $server};
  }

  my @bdeps;
  my @pdeps = Build::get_preinstalls($bconf);
  my @vmdeps = Build::get_vminstalls($bconf);
  my %runscripts = map {$_ => 1} Build::get_runscripts($bconf);
  my %pdeps = map {$_ => 1} @pdeps;
  my %vmdeps = map {$_ => 1} @vmdeps;
  for my $rpm (unify(@pdeps, @vmdeps, @{$rpms || []})) {
    my @b = split('/', $rpm);
    if (@b == 1) {
      # this is a build environment package
      push @bdeps, { 'name' => $rpm, 'notmeta' => 1, };
      $bdeps[-1]->{'preinstall'} = 1 if $pdeps{$rpm};
      $bdeps[-1]->{'vminstall'} = 1 if $vmdeps{$rpm};
      $bdeps[-1]->{'repoarch'} = $localbuildarch if $localbuildarch ne $myarch;
      next;
    }
    next unless @b == 5;
    next unless $b[4] =~ /^(?:::import::.*::)?(.+)-([^-]+)-([^-]+)\.([a-zA-Z][^\.\-]*)\.rpm$/;
    push @bdeps, {
      'name' => $1,
      'version' => $2,
      'release' => $3,
      'arch' => $4,
      'project' => $b[0],
      'repository' => $b[1],
      'repoarch' => $b[2],
      'package' => $b[3],
    };
  }
  if ($info->{'extrasource'}) {
    push @bdeps, map {{
      'name' => $_->{'file'}, 'version' => '', 'repoarch' => 'src',
      'project' => $_->{'project'}, 'package' => $_->{'package'}, 'srcmd5' => $_->{'srcmd5'},
    }} @{$info->{'extrasource'}};
  }

  my $dst = "$gctx->{'reporoot'}/$prp/$myarch/$packid";

  # find the last build count we used for this version/release
  mkdir_p($dst);
  my $h = BSFileDB::fdb_getmatch("$dst/history", $historylay, 'versrel', defined($pdata->{'versrel'}) ? $pdata->{'versrel'} : '', 1);
  $h = {'bcnt' => 0} unless $h;

  # max with sync data
  my $tag = $pdata->{'bcntsynctag'} || $packid;
  if ($relsyncmax->{"$tag/$pdata->{'versrel'}"}) {
    if ($h->{'bcnt'} + 1 < $relsyncmax->{"$tag/$pdata->{'versrel'}"}) {
      $h->{'bcnt'} = $relsyncmax->{"$tag/$pdata->{'versrel'}"} - 1;
    }
  }

  my $binfo = {
    'project' => $projid,
    'repository' => $repoid,
    'package' => $packid,
    'srcserver' => $workersrcserver,
    'reposerver' => $workerreposerver,
    'job' => $job,
    'arch' => $myarch,
    'srcmd5' => $srcmd5,
    'verifymd5' => $pdata->{'verifymd5'} || $srcmd5,
    'rev' => $pdata->{'rev'},
    'file' => $info->{'file'},
    'versrel' => $pdata->{'versrel'},
    'bcnt' => $h->{'bcnt'} + 1,
    'bdep' => \@bdeps,
    'path' => $searchpath,
    'reason' => $reason->{'explain'},
    'readytime' => $now,
  };
  my $obsname = $gctx->{'obsname'};
  $binfo->{'disturl'} = "obs://$obsname/$projid/$repoid/$srcmd5-$packid";
  $binfo->{'syspath'} = $syspath if $syspath;
  $binfo->{'hostarch'} = $bconf->{'hostarch'} if $bconf->{'hostarch'};
  $binfo->{'revtime'} = $pdata->{'revtime'} if $pdata->{'revtime'};
  $binfo->{'imagetype'} = $info->{'imagetype'} if $info->{'imagetype'};
  $binfo->{'nodbgpkgs'} = $info->{'nodbgpkgs'} if $info->{'nodbgpkgs'};
  $binfo->{'nosrcpkgs'} = $info->{'nosrcpkgs'} if $info->{'nosrcpkgs'};
  $binfo->{'constraintsmd5'} = $pdata->{'constraintsmd5'} if $pdata->{'constraintsmd5'};
  $binfo->{'prjconfconstraint'} = $bconf->{'constraint'} if @{$bconf->{'constraint'} || []};
  mkdir_p($dst);
  writexml("$dst/.status", "$dst/status", { 'status' => 'scheduled', 'readytime' => $now, 'job' => $job}, $BSXML::buildstatus);
  $reason->{'time'} = $now;
  writexml("$dst/.reason", "$dst/reason", $reason, $BSXML::buildreason);
  BSSched::BuildJob::writejob($gctx, $job, $binfo);
  return ('scheduled', $job);
}

##########################################################################
##########################################################################
##
##  patchinfo package type handling
##
sub checkpatchinfo {
  my ($ctx, $packid, $pdata, $info) = @_;

  my $projid = $ctx->{'project'};
  my $repoid = $ctx->{'repository'};
  my $repo = $ctx->{'repo'};
  my $gctx = $ctx->{'gctx'};
  my $myarch = $gctx->{'arch'};
  my @archs = @{$repo->{'arch'}};
  return ('broken', 'missing archs') unless @archs;	# can't happen
  my $buildarch = $archs[0];	# always build in first arch
  my $reporoot = $gctx->{'reporoot'};
  my $markerdir = "$reporoot/$projid/$repoid/$buildarch/$packid";
  my $patchinfo = $pdata->{'patchinfo'};
  my $projpacks = $gctx->{'projpacks'};
  my $proj = $projpacks->{$projid} || {};

  if (@{$patchinfo->{'releasetarget'} || []}) {
    my $ok;
    for my $rt (@{$patchinfo->{'releasetarget'}}) {
      $ok = grep {$rt->{'project'} eq $_->{'project'} && (!defined($rt->{'repository'}) || $rt->{'repository'} eq $_->{'repository'})} @{$repo->{'releasetarget'} || []};
      last if $ok;
    }
    return ('excluded') unless $ok;
  }

  return ('broken', "patchinfo is stopped: ".$patchinfo->{'stopped'}) if $patchinfo->{'stopped'};
  return ('broken', 'patchinfo lacks category') unless $patchinfo->{'category'};

  my $ptype = 'local';
  $ptype = 'binary' if ($proj->{'kind'} || '') eq 'maintenance_incident';
  
  my $broken;
  # find packages
  my @packages;
  if ($patchinfo->{'package'}) {
    @packages = @{$patchinfo->{'package'}};
    my $pdatas = $proj->{'package'} || {};
    my @missing;
    for my $apackid (@packages) {
      if (!$pdatas->{$apackid}) {
	push @missing, $_;
      }
    }
    $broken = 'missing packages: '.join(', ', @missing) if @missing;
  } else {
    my $pdatas = $proj->{'package'} || {};
    @packages = grep {!$pdatas->{$_}->{'aggregatelist'} && !$pdatas->{$_}->{'patchinfo'}} sort keys %$pdatas;
  }
  if (!@packages && !$broken) {
    $broken = 'no packages found';
  }

  if ($buildarch ne $myarch) {
    # XXX wipe just in case! remove when we do that elsewhere...
    if (-d "$reporoot/$projid/$repoid/$myarch/$packid") {
      # (patchinfo packages will not be in :full)
      unlink("$reporoot/$projid/$repoid/$myarch/:meta/$packid");
      unlink("$reporoot/$projid/$repoid/$myarch/:logfiles.fail/$packid");
      unlink("$reporoot/$projid/$repoid/$myarch/:logfiles.success/$packid");
      unlink("$reporoot/$projid/$repoid/$myarch/:logfiles.success/$packid");
      BSUtil::cleandir("$reporoot/$projid/$repoid/$myarch/$packid");
      rmdir("$reporoot/$projid/$repoid/$myarch/$packid");
    }
    # check if we go from blocked to unblocked
    my $blocked;
    my $packstatus = $ctx->{'packstatus'};
    for my $apackid (@packages) {
      my $code = $packstatus->{$apackid} || '';
      if ($code eq 'excluded') {
	next;
      }
      if ($code ne 'done' && $code ne 'disabled') {
	$blocked = 1;
        last;
      }
      if (-e "$reporoot/$projid/$repoid/$myarch/:logfiles.fail/$apackid") {
	$blocked = 1;
        last;
      }
      if (! -e "$reporoot/$projid/$repoid/$myarch/:logfiles.success/$apackid") {
	if (! -e "$reporoot/$projid/$repoid/$myarch/$apackid/.channelinfo") {
	  next if $code eq 'disabled';
	  $blocked = 1;
          last;
	}
      }
    }
    if (!$blocked) {
      if (-e "$markerdir/.waiting_for_$myarch") {
	unlink("$markerdir/.waiting_for_$myarch");
	sendunblockedevent($gctx, "$projid/$repoid", $buildarch);
	print "      - $packid (patchinfo)\n";
	print "        unblocked\n";
      }
    }
    if ($blocked && !$broken) {
      # hmm, we should be blocked. trigger build arch check
      if (!-e "$markerdir/.waiting_for_$myarch") {
	BSUtil::touch("$reporoot/$projid/$repoid/$buildarch/:schedulerstate.dirty") if -d "$reporoot/$projid/$repoid/$buildarch";
	sendunblockedevent($gctx, "$projid/$repoid", $buildarch);
	print "      - $packid (patchinfo)\n";
	print "        blocked\n";
      }
    }
    return ('excluded', "is built in architecture '$buildarch'");
  }

  return ('broken', $broken) if $broken;

  my @new_meta;
  push @new_meta, ($pdata->{'verifymd5'} || $pdata->{'srcmd5'})."  $packid";

  if ($ptype eq 'local') {
    # only rebuild if patchinfo source changes
    my @meta;
    if (open(F, '<', "$reporoot/$projid/$repoid/$myarch/:meta/$packid")) {
      @meta = <F>;
      close F;
      chomp @meta;
    }
    if (@meta == 1 && $meta[0] eq $new_meta[0]) {
      print "      - $packid (patchinfo)\n";
      print "        nothing changed\n";
      return ('done');
    }
  }

  # collect em
  my $apackstatus;
  my @blocked;
  my @tocopy;
  my %metas;
  my $empty_channel_seen;
  my $rpms_seen;
  my $enabled_seen;
  for my $arch (@archs) {
    if ($arch eq $myarch) {
      $apackstatus = $ctx->{'packstatus'};
    } else {
      my $ps = BSUtil::retrieve("$reporoot/$projid/$repoid/$arch/:packstatus", 1);
      if (!$ps) {
	$ps = (readxml("$reporoot/$projid/$repoid/$arch/:packstatus", $BSXML::packstatuslist, 1) || {})->{'packstatus'} || [];
	$ps = { 'packstatus' => { map {$_->{'name'} => $_->{'status'}} @$ps } } if $ps;
      }
      $apackstatus = ($ps || {})->{'packstatus'} || {};
    }
    my $blockedarch;
    for my $apackid (@packages) {
      my $code = $apackstatus->{$apackid} || '';
      next if $code eq 'excluded';
      $enabled_seen = 1 unless $code eq 'disabled';
      if ($code ne 'done' && $code ne 'disabled') {
	$blockedarch = 1;
	push @blocked, "$arch/$apackid";
        next;
      }
      if (-e "$reporoot/$projid/$repoid/$arch/:logfiles.fail/$apackid") {
        # last build failed
        if ($code ne 'disabled' || -e "$reporoot/$projid/$repoid/$arch/:logfiles.success/$apackid") {
	  $blockedarch = 1;
	  push @blocked, "$arch/$apackid (failed)";
	  next;
	}
      } elsif (! -e "$reporoot/$projid/$repoid/$arch/:logfiles.success/$apackid") {
	# package was never built yet or channel
	if (! -e "$reporoot/$projid/$repoid/$arch/$apackid/.channelinfo") {
	  next if $code eq 'disabled';
	  $blockedarch = 1;
	  push @blocked, "$arch/$apackid (no logfiles.success)";
	  next;
	}
      }
      if ($ptype eq 'binary') {
	# like aggregates
	my $d = "$reporoot/$projid/$repoid/$arch/$apackid";
	my @d = grep {/\.rpm$/ && !/^::import::/} ls($d);
	my $m = '';
	for my $b (sort @d) {
	  my @s = stat("$d/$b");
	  $m .= "$b\0$s[9]/$s[7]/$s[1]\0" if @s;
	}
	if (!@d) {
	  # is this a channel?
	  $empty_channel_seen = 1 if -e "$d/.channelinfo";
	} else {
	  $rpms_seen = 1;
	}
	$metas{"$arch/$apackid"} = Digest::MD5::md5_hex($m);
      } elsif ($ptype eq 'direct' || $ptype eq 'transitive') {
	my ($ameta) = split("\n", readstr("$reporoot/$projid/$repoid/$arch/:meta/$apackid", 1) || '', 2);
	if (!$ameta) {
	  push @blocked, "$arch/$apackid";
	  $blockedarch = 1;
	} else {
	  if ($metas{$apackid} && $metas{$apackid} ne $ameta) {
	    push @blocked, "meta/$apackid";
	    $blockedarch = 1;
	  } else {
	    $metas{$apackid} = $ameta;
	  }
	}
      }
      push @tocopy, "$arch/$apackid";
    }
    if ($blockedarch && $arch ne $myarch) {
      mkdir_p("$reporoot/$projid/$repoid/$myarch/$packid");
      BSUtil::touch("$markerdir/.waiting_for_$arch") unless -e "$markerdir/.waiting_for_$arch";
    } else {
      unlink("$markerdir/.waiting_for_$arch");
    }
  }

  if (@blocked) {
    print "      - $packid (patchinfo)\n";
    print "        blocked (@blocked)\n";
    return ('blocked', join(', ', @blocked));
  }

  return ('excluded', 'no binary in channel') if ($empty_channel_seen && !$rpms_seen);
  return ('excluded', 'no package enabled') unless $enabled_seen;

  return ('broken', 'no binaries found') unless @tocopy;

  for (sort(keys %metas)) {
    push @new_meta, "$metas{$_}  $_";
  }

  # compare with stored meta
  my @meta;
  if (open(F, '<', "$reporoot/$projid/$repoid/$myarch/:meta/$packid")) {
    @meta = <F>;
    close F;
    chomp @meta;
  }
  if (@meta == @new_meta && join("\n", @meta) eq join("\n", @new_meta)) {
    print "      - $packid (patchinfo)\n";
    print "        nothing changed\n";
    return ('done');
  }

  # now collect...
  return ('scheduled', [ \@tocopy, \%metas, $ptype]);
}

sub rebuildpatchinfo {
  my ($ctx, $packid, $pdata, $info, $data) = @_;

  my $gctx = $ctx->{'gctx'};
  my $myarch = $gctx->{'arch'};
  my $projid = $ctx->{'project'};
  my $repoid = $ctx->{'repository'};
  my @tocopy = @{$data->[0]};
  my $ckmetas = $data->[1];
  my $ptype = $data->[2];
  my $reporoot = $gctx->{'reporoot'};
  
  print "      - $packid (patchinfo)\n";
  print "        rebuilding\n";
  my $now = time();
  my $prp = "$projid/$repoid";
  my $job = BSSched::BuildJob::jobname($prp, $packid);
  my $myjobsdir = $gctx->{'myjobsdir'};
  return ('scheduled', $job) if -s "$myjobsdir/$job";

  my $patchinfo = $pdata->{'patchinfo'};
  my $jobdatadir = "$myjobsdir/$job:dir";
  unlink "$jobdatadir/$_" for ls($jobdatadir);
  mkdir_p($jobdatadir);
  my $jobrepo = {};
  my $error;
  my %donebins;
  my @upackages;
  my $broken;
  my %metas;
  my $bininfo = {};
  my $updateinfodata;
  my %updateinfodata_tocopy;
  my %binaryfilter = map {$_ => 1} @{$patchinfo->{'binary'} || []};
  my %filtered;
  
  if (-s "$reporoot/$prp/$myarch/$packid/.updateinfodata") {
    $updateinfodata = BSUtil::retrieve("$reporoot/$prp/$myarch/$packid/.updateinfodata");
    %updateinfodata_tocopy = map {$_ => 1} @{$updateinfodata->{'packages'} || []};
  }

  my %supportstatus;
  my $target;
  my $firstissued = ($updateinfodata || {})->{'firstissued'} || $now;

  for my $tocopy (@tocopy) {
    my ($arch, $apackid) = split('/', $tocopy, 2);
    my @bins;
    my $meta;
    my $from;
    my $mpackid;
    my $channelinfo;

    if ($ptype eq 'local') {
      # always reuse old packages
    } elsif ($ptype eq 'binary') {
      $mpackid = "$arch/$apackid";
    } elsif ($ptype eq 'direct' || $ptype eq 'transitive') {
      $mpackid = $apackid;
    } else {
      $broken = "illegal ptype";
      last;
    }
    if ($updateinfodata->{'filtered'} && $updateinfodata->{'filtered'}->{$tocopy}) {
      # we previously filtered packages, check if this is still true
      if (grep {!%binaryfilter || $binaryfilter{$_}} keys %{$updateinfodata->{'filtered'}->{$tocopy}}) {
	# can't reuse old packages, as the filter changed
	delete $updateinfodata_tocopy{$tocopy};
      }
    }
    if ($updateinfodata_tocopy{$tocopy} && (!defined($mpackid) || ($updateinfodata->{'metas'}->{$mpackid} || '') eq $ckmetas->{$mpackid})) {
      print "        reusing old packages for '$tocopy'\n";
      $from = "$reporoot/$projid/$repoid/$myarch/$packid";
      @bins = grep {$updateinfodata->{'binaryorigins'}->{$_} eq $tocopy} keys(%{$updateinfodata->{'binaryorigins'}});
      if ($updateinfodata->{'supportstatus'}) {
	# fake channelinfo
	my $oldsupportstatus = $updateinfodata->{'supportstatus'};
        for (@bins) {
	  next unless $oldsupportstatus->{$_};
	  $channelinfo ||= {};
	  $channelinfo->{$_} = { 'supportstatus' => $oldsupportstatus->{$_} };
	}
      }
      $target ||= $updateinfodata->{'target'} if $updateinfodata->{'target'};
    } else {
      $from = "$reporoot/$projid/$repoid/$tocopy";
      @bins = grep {/\.rpm$/ && !/^::import::/} ls($from);
      if (-e "$from/.channelinfo") {
        $channelinfo = BSUtil::retrieve("$from/.channelinfo");
	$target ||= $channelinfo->{'/target'} if $channelinfo->{'/target'};
      }
    }
    if (defined($mpackid)) {
      my $meta = $ckmetas->{$mpackid};
      if (!$meta) {
	$broken = "$tocopy has no meta";
	last;
      }
      $metas{$mpackid} ||= $meta;
      if ($metas{$mpackid} ne $meta) {
	$broken = "$mpackid has different sources";
	last;
      }
    }
    my $m = '';
    for my $bin (sort @bins) {
      if ($donebins{$bin}) {
        if ($ptype eq 'binary') {
	  my @s = stat("$from/$bin");
	  $m .= "$bin\0$s[9]/$s[7]/$s[1]\0" if @s;
        }
        next;
      }
      if (!link("$from/$bin", "$jobdatadir/$bin")) {
        my $error = "link $from/$bin $jobdatadir/$bin: $!\n";
        return ('broken', $error);
      }
      my @s = stat("$jobdatadir/$bin");
      return ('broken', "$jobdatadir/$bin: stat failed") unless @s;
      if ($ptype eq 'binary') {
        # be extra careful with em, recalculate meta
	$m .= "$bin\0$s[9]/$s[7]/$s[1]\0" if @s;
      }
      my $d;
      eval {
        $d = Build::query("$jobdatadir/$bin", 'evra' => 1, 'unstrippedsource' => 1);
	BSVerify::verify_nevraquery($d);
	my $leadsigmd5 = '';
	die("$jobdatadir/$bin: no hdrmd5\n") unless Build::queryhdrmd5("$jobdatadir/$bin", \$leadsigmd5);
	$d->{'leadsigmd5'} = $leadsigmd5 if $leadsigmd5;
      };
      if ($@ || !$d) {
        return ('broken', "$bin: bad rpm");
      }
      if (%binaryfilter && !$binaryfilter{$d->{'name'}}) {
	$filtered{$tocopy} ||= {};
	$filtered{$tocopy}->{$d->{'name'}} = 1;
        unlink("$jobdatadir/$bin");
        next;
      }
      if ($d->{'arch'} ne 'src' && $d->{'arch'} ne 'nosrc' && -e "$from/$d->{'name'}-appdata.xml") {
	unlink("$jobdatadir/$d->{'name'}-appdata.xml");
	if (!link("$from/$d->{'name'}-appdata.xml", "$jobdatadir/$d->{'name'}-appdata.xml")) {
          my $error = "link $from/$d->{'name'}-appdata.xml $jobdatadir/$d->{'name'}-appdata.xml: $!\n";
          return ('broken', $error);
	}
      }
      $donebins{$bin} = $tocopy;
      $bininfo->{$bin} = {'name' => $d->{'name'}, 'arch' => $d->{'arch'}, 'hdrmd5' => $d->{'hdrmd5'}, 'filename' => $bin, 'id' => "$s[9]/$s[7]/$s[1]"};
      $bininfo->{$bin}->{'leadsigmd5'} = $d->{'leadsigmd5'} if $d->{'leadsigmd5'};
      $bininfo->{$bin}->{'md5sum'} = $d->{'md5sum'} if $d->{'md5sum'};
      my $upd = {
	'name' => $d->{'name'},
	'version' => $d->{'version'},
	'release' => $d->{'release'},
	'epoch' => $d->{'epoch'} || 0,
	'arch' => $d->{'arch'},
	'filename' => $bin,
	'src' => "$d->{'arch'}/$bin",	# as hopefully written by the publisher
      };
      $upd->{'reboot_suggested'} = 'True' if exists $patchinfo->{'reboot_needed'};
      $upd->{'relogin_suggested'} = 'True' if exists $patchinfo->{'relogin_needed'};
      $upd->{'restart_suggested'} = 'True' if exists $patchinfo->{'zypp_restart_needed'};
      push @upackages, $upd;
      if ($channelinfo) {
	my $ci = $channelinfo->{$bin};
        next unless $ci->{'supportstatus'};
        $upd->{'supportstatus'} = $ci->{'supportstatus'};
	$supportstatus{$bin} = $ci->{'supportstatus'};
      }
    }
    $metas{$mpackid} = Digest::MD5::md5_hex($m) if $ptype eq 'binary';
  }

  $broken ||= 'no binaries found' unless @upackages;

  my $update = {};
  $update->{'status'} = 'stable';
  $update->{'from'} = $patchinfo->{'packager'} if $patchinfo->{'packager'};
  # quick hack, to be replaced with something sane
  if ($BSConfig::updateinfo_fromoverwrite) {
    for (sort keys %$BSConfig::updateinfo_fromoverwrite) {
      $update->{'from'} = $BSConfig::updateinfo_fromoverwrite->{$_} if $projid =~ /$_/;
    }
  }
  $update->{'version'} = $patchinfo->{'version'} || '1';	# bodhi inserts its own version...
  $update->{'id'} = $patchinfo->{'incident'};
  if (!$update->{'id'}) {
    $update->{'id'} = $projid;
    $update->{'id'} =~ s/:/_/g;
  }
  if ($target && $target->{'id_template'}) {
    my $template = $target->{'id_template'};
    my @lt = localtime($firstissued);
    $broken ||= 'patchinfo name is required' if $template =~ /%N/ && !defined $patchinfo->{'name'};
    $template =~ s/%Y/$lt[5] + 1900/eg;
    $template =~ s/%M/$lt[4] + 1/eg;
    $template =~ s/%D/$lt[3]/eg;
    $template =~ s/%N/$patchinfo->{'name'}/eg if defined $patchinfo->{'name'};
    if ($template =~ /%C/) {
      $template =~ s/%C/$update->{'id'}/g;
    } else {
      $template .= "-$update->{'id'}";
    }
    $update->{'id'} = $template;
  }
  $update->{'type'} = $patchinfo->{'category'};
  $update->{'title'} = $patchinfo->{'summary'};
  $update->{'severity'} = $patchinfo->{'rating'} if defined $patchinfo->{'rating'};
  $update->{'description'} = $patchinfo->{'description'};
  $update->{'message'} = $patchinfo->{'message'} if defined $patchinfo->{'message'};
  # FIXME: do not guess the release element!
  $update->{'release'} = $repoid eq 'standard' ? $projid : $repoid;
  $update->{'release'} =~ s/_standard$//;
  $update->{'release'} =~ s/[_:]+/ /g;
  $update->{'issued'} = { 'date' => $now };

  # fetch defined issue trackers from src server. FIXME: cache this
  my @references;
  my $issue_trackers;
  my $param = {
    'uri' => "$BSConfig::srcserver/issue_trackers",
    'timeout' => 30,
  };
  eval {
    $issue_trackers = BSRPC::rpc($param, $BSXML::issue_trackers);
  };
  warn($@) if $@;
  if ($issue_trackers) {
    for my $b (@{$patchinfo->{'issue'} || []}) {
      my $it = (grep {$_->{'name'} eq $b->{'tracker'}} @{$issue_trackers->{'issue-tracker'} || []})[0];
      if ($it && $b->{'id'}) {
        my $trackerid = $b->{'id'};
        my $referenceid = $b->{'id'};
        if ($b->{'tracker'} eq 'cve') {
          # stay compatible with case insensitive writings and old _patchinfo files
          $trackerid =~ s/^(?:cve-)?//i;
          $referenceid =~ s/^(?:cve-)?/CVE-/i;
        }
        my $url = $it->{'show-url'};
        $url =~ s/@@@/$trackerid/g;
        my $title = $b->{'_content'};
        $title = $url unless defined($title) && $title ne '';
        push @references, {'href' => $url, 'id' => $referenceid, 'title' => $title, 'type' => $it->{'kind'}};
      }
    }
  }
  if ($target && $target->{'requires_issue'}) {
    $broken ||= 'no issue referenced' unless @references;
  }
  $update->{'references'} = { 'reference' => \@references };
  # XXX: set name and short
  my $col = {
    'package' => \@upackages,
  };
  $update->{'pkglist'} = {'collection' => [ $col ] };
  $update->{'patchinforef'} = "$projid/$packid";	# deleted in publisher...
  writexml("$jobdatadir/updateinfo.xml", undef, {'update' => [$update]}, $BSXML::updateinfo);
  writestr("$jobdatadir/logfile", undef, "update built succeeded ".localtime($now)."\n");
  $updateinfodata = {
    'packages' => \@tocopy,
    'metas' => \%metas,
    'binaryorigins' => \%donebins,
    'firstissued' => $firstissued,
  };
  $updateinfodata->{'supportstatus'} = \%supportstatus if %supportstatus;
  $updateinfodata->{'filtered'} = \%filtered if %filtered;
  $updateinfodata->{'target'} = $target if $target;
  BSUtil::store("$jobdatadir/.updateinfodata", undef, $updateinfodata);
  if ($broken) {
    BSUtil::cleandir($jobdatadir);
    writestr("$jobdatadir/logfile", undef, "update built failed ".localtime($now)."\n\n$broken\n");
  }
  my @new_meta = ($pdata->{'verifymd5'} || $pdata->{'srcmd5'})."  $packid";
  for my $apackid (sort(keys %metas)) {
    push @new_meta, "$metas{$apackid}  $apackid";
  }
  writestr("$jobdatadir/meta", undef, join("\n", @new_meta)."\n");
  # XXX write reason
  BSSched::BuildJob::fakejobfinished_nouseforbuild($ctx, $packid, $job, $broken ? 'failed' : 'succeeded', $bininfo, $pdata);
  return ('done');
}

##########################################################################
##########################################################################
##
##  channel package type handling
##
sub checkchannel {
  my ($ctx, $packid, $pdata, $info) = @_;
  my $gctx = $ctx->{'gctx'};
  my $myarch = $gctx->{'arch'};
  my $projid = $ctx->{'project'};
  my $repoid = $ctx->{'repository'};
  my $repo = $ctx->{'repo'};
  my %repoarchs = map {$_ => 1} @{$repo->{'arch'} || []};
  my $channel = $pdata->{'channel'};
  my $projpacks = $gctx->{'projpacks'};
  my $proj = $projpacks->{$projid} || {};
  my $reporoot = $gctx->{'reporoot'};
  # do the channel filtering, same project but different repositories

  # first build a releasetarget -> repo map
  my %proj2repo;
  for my $arepo (@{$projpacks->{$projid}->{'repository'} || []}) {
    next unless grep {$_ eq $myarch} @{$arepo->{'arch'} || []};
    $proj2repo{"$projid/$arepo->{'name'}"}->{$arepo->{'name'}} = 1;
    for my $rt (@{$arepo->{'releasetarget'} || []}) {
      my $rtprojid = $rt->{'project'};
      my $rtrepoid = $rt->{'repository'};
      $proj2repo{"$rtprojid/$rtrepoid"}->{$arepo->{'name'}} = 1;
      $proj2repo{$rtprojid}->{$arepo->{'name'}} = 1;
    }
  }
  my $forme = {};
  if ($channel->{'target'}) {
    $forme = undef;
    for (@{$channel->{'target'}}) {
      if (!$_->{'project'}) {
	$forme = $_ if $_->{'repository'} && $repoid eq $_->{'repository'};
      } else {
	if ($_->{'repository'}) {
	  $forme = $_ if $proj2repo{"$_->{'project'}/$_->{'repository'}"};
	} else {
	  $forme = $_ if $proj2repo{$_->{'project'}};
	}
      }
    }
  }
  return ('excluded', 'not target of channel') if !$forme;
  
  # now create filter
  my %arepos;
  my %filter;
  my %packagefilter;
  for my $binaries (@{$channel->{'binaries'} || []}) {
    my $defprojid = $binaries->{'project'};
    my $defrepoid = $binaries->{'repository'};
    my $defarch = $binaries->{'arch'};
    for my $binary (@{$binaries->{'binary'} || []}) {
      next unless $binary->{'name'};
      my $bi = $binary;
      my $arch = $bi->{'arch'} || $defarch || '';
      if ($arch && !$repoarchs{$arch}) {
	# not in repo, go for the import!
	$bi = { %$binary, 'importedfrom' => $arch };
	$arch = $myarch;
      }
      next unless !$arch || $arch eq $myarch;
      my $aprojid = $bi->{'project'} || $defprojid || $projid;
      next unless $aprojid;
      my $arepoid = $bi->{'repository'} || $defrepoid || '';
      my $rtkey = $arepoid ? "$aprojid/$arepoid" : $aprojid;
      next unless $proj2repo{$rtkey};
      for my $arepoid (keys %{$proj2repo{$rtkey}}) {
        $arepos{$arepoid} = 1;
        push @{$filter{"$arepoid/$bi->{'name'}"}}, $bi;
      }
      if ($bi->{'package'}) {
	push @{$packagefilter{"$arepoid/$bi->{'package'}"}}, $bi;
      }
    }
  }
  #print Dumper(\%filter);

  # find packages (same code as in checkpatchinfo)
  my $pdatas = $proj->{'package'} || {};
  my @apackids = grep {!$pdatas->{$_}->{'aggregatelist'} && !$pdatas->{$_}->{'patchinfo'}} sort keys %$pdatas;

  # go through the repos and check the binaries
  my @new_meta = ($pdata->{'verifymd5'} || $pdata->{'srcmd5'})."  $packid";
  my @blocked;
  my @broken;
  my %collected;
  my @channelbins;
  for my $arepoid (sort keys %arepos) {
    my $aprp = "$projid/$arepoid";
    my $ps = BSUtil::retrieve("$reporoot/$aprp/$myarch/:packstatus", 1);
    $ps = ($ps || {})->{'packstatus'} || {};
    # find which projects go into this repo
    my %aprojids;
    for my $aprojid (keys %proj2repo) {
      $aprojids{$aprojid} = 1 if $proj2repo{$aprojid}->{$arepoid};
    }
    my $gbininfo = BSSched::BuildResult::read_gbininfo("$reporoot/$aprp/$myarch");
    for my $apackid (@apackids) {
      next if $arepoid eq $repoid && $apackid eq $packid;
      my $code = $ps->{$apackid} || 'unknown';
      if ($code eq 'scheduled' || $code eq 'blocked' || $code eq 'finished' || $code eq 'unknown') {
        push @blocked, "$arepoid/$apackid";
        next;
      }
      my $bininfo = $gbininfo->{$apackid} || {};
      my @sbins;
      my %usedsrc;

      # this messy code tries to guess the "final" package name for
      # maintenance incidents.
      my $lapackid;	#linked package id
      my $linked = ($pdatas->{$apackid} || {})->{'linked'};
      if (!@{$linked || []}) {
	$lapackid = $apackid;
	if (($proj->{'kind'} || '') eq 'maintenance_incident' && (($pdatas->{$apackid} || {})->{'error'} || '') eq 'disabled') {
	  # workaround for src server not sending linked data for disabled packages
	  $lapackid =~ s/\.[^\.]+$//;
	}
      } elsif ($linked->[0]->{'project'} ne $projid) {
	$lapackid = $linked->[0]->{'package'};
      } else {
	# what a mess! but bug compatible to api...
	my ($pin, $pout);
	for (@$linked) {
	  $pout = $_->{'package'};
	  last if $_->{'project'} ne $projid;
	  $pin = $pout;
	}
	$lapackid = $apackid;
	if ($pin =~ s/^\Q$pout\E//) {
	  $lapackid =~ s/\Q$pin\E$//;
	}
      }

      my @pf = @{$packagefilter{"$arepoid/$apackid"} || $packagefilter{"$arepoid/$lapackid"} || []};

      my @bins = sort keys %$bininfo;
      # put imports last
      my @ibins = grep {/^::import::/} @bins;
      if (@ibins) {
	@bins = grep {!/^::import::/} @bins;
	push @bins, @ibins;
      }
      for my $filename (@bins) {
	my $bi = $bininfo->{$filename};
	my $n = $bi->{'name'};
	next unless $n;
	if ($bi->{'arch'} eq 'src' || $bi->{'arch'} eq 'nosrc') {
	  push @sbins, $bi unless $bininfo->{'.nosourceaccess'};
	  next;
	}
	if (@pf) {
	  for my $f (splice @pf) {
	    push @pf, $f if $f->{'name'} ne $n || ($f->{'binaryarch'} && $bi->{'arch'} ne $f->{'binaryarch'});
	  }
	}
	my $tfilename = $filename;
	$tfilename =~ s/^::import::.*?:://;
	next if $collected{$tfilename};
	next unless $filter{"$arepoid/$n"};
	my $found;
	my $supportstatus;
	my $importedfrom;
	for my $f (@{$filter{"$arepoid/$n"}}) {
	  next if $f->{'importedfrom'} && $filename !~ /^::import::\Q$f->{'importedfrom'}\E::/;
	  next if $f->{'package'} && $apackid ne $f->{'package'} && $lapackid ne $f->{'package'};
	  next if $f->{'binaryarch'} && $bi->{'arch'} ne $f->{'binaryarch'};
	  $supportstatus = $f->{'supportstatus'};
	  $found = 1;
	  last;
	}
	next unless $found;
	# oooh, this binary goes into the channel!
	$collected{$tfilename} = 1;
	$usedsrc{$bi->{'source'}} = 1;
	my $m = Digest::MD5::md5_hex($bi->{'id'})."  $arepoid/$apackid/$n.$bi->{'arch'}";
	push @new_meta, $m;
	$bi->{'filename'} = $filename;	# work around bug in bininfo generation
	push @channelbins, [ $arepoid, $apackid, $bi, $supportstatus ];
      }
      if (%usedsrc) {
	for my $bi (@sbins) {
	  next unless $usedsrc{$bi->{'name'}};
	  next if $collected{$bi->{'filename'}};
	  $collected{$bi->{'filename'}} = 1;
	  my $m = Digest::MD5::md5_hex($bi->{'id'})."  $arepoid/$apackid/$bi->{'name'}.$bi->{'arch'}";
	  push @new_meta, $m;
	  push @channelbins, [ $arepoid, $apackid, $bi ];
	}
      }
      for my $f (@pf) {
	if ($f->{'binaryarch'}) {
	  push @broken, "$arepoid/$apackid/$f->{'name'}.$f->{'binaryarch'}";
	} else {
	  push @broken, "$arepoid/$apackid/$f->{'name'}";
	}
      }
    }
  }
  if (@broken) {
    print "      - $packid (channel)\n";
    print "        broken (@blocked)\n";
    return ('broken', 'missing: '.join(', ', @broken));
  }
  if (@blocked) {
    print "      - $packid (channel)\n";
    print "        blocked (@blocked)\n";
    return ('blocked', join(', ', @blocked));
  }
  my @meta;
  if (open(F, '<', "$reporoot/$projid/$repoid/$myarch/:meta/$packid")) {
    @meta = <F>;
    close F;
    chomp @meta;
  }
  if (join('\n', @meta) eq join('\n', @new_meta)) {
    print "      - $packid (channel)\n";
    print "        nothing changed\n";
    return ('done');
  }
  my @diff = diffsortedmd5(\@meta, \@new_meta);
  print "      - $packid (channel)\n";
  print "        $_\n" for @diff;
  my $new_meta = join('', map {"$_\n"} @new_meta);
  return ('scheduled', [ $new_meta, \@channelbins, $forme ]);
}

sub rebuildchannel {
  my ($ctx, $packid, $pdata, $info, $data) = @_;
  my $new_meta = $data->[0];
  my $channelbins = $data->[1];
  my $forme = $data->[2];
  my $gctx = $ctx->{'gctx'};
  my $myarch = $gctx->{'arch'};
  my $projid = $ctx->{'project'};
  my $repoid = $ctx->{'repository'};
  my $prp = "$projid/$repoid";
  my $job = BSSched::BuildJob::jobname($prp, $packid);
  my $myjobsdir = $gctx->{'myjobsdir'};
  return ('scheduled', $job) if -s "$myjobsdir/$job";
  my $reporoot = $gctx->{'reporoot'};
  my $jobdatadir = "$myjobsdir/$job:dir";
  unlink "$jobdatadir/$_" for ls($jobdatadir);
  mkdir_p($jobdatadir);
  my %channelinfo = ('/target' => $forme);
  my $bininfo = {};
  my $checksums = '';
  my %checksums_seen;
  for my $cb (@$channelbins) {
    my ($arepoid, $apackid, $bi, $supportstatus) = @$cb;
    my $dir = "$reporoot/$projid/$arepoid/$myarch/$apackid";
    my $file = "$dir/$bi->{'filename'}";
    my @s = stat($file);
    if (!@s || "$s[9]/$s[7]/$s[1]" ne $bi->{'id'}) {
      BSUtil::cleandir($jobdatadir);
      rmdir($jobdatadir);
      return ('broken', "id mismatch in $arepoid/$apackid $s[9]/$s[7]/$s[1] $bi->{'id'}");
    }
    my $tfilename = $bi->{'filename'};
    $tfilename =~ s/^::import::.*?:://;
    link($file, "$jobdatadir/$tfilename") || die("link $file $jobdatadir/$tfilename: $!\n");
    if ($bi->{'arch'} ne 'src' && $bi->{'arch'} ne 'nosrc' && -e "$dir/$bi->{'name'}-appdata.xml") {
      unlink("$jobdatadir/$bi->{'name'}-appdata.xml");
      link("$dir/$bi->{'name'}-appdata.xml", "$jobdatadir/$bi->{'name'}-appdata.xml") || die("link $bi->{'name'}-appdata.xml $jobdatadir/$bi->{'name'}-appdata.xml: $!\n");
    }
    if (!$checksums_seen{"$arepoid/$apackid"}) {
      $checksums_seen{"$arepoid/$apackid"} = 1;
      # just append the checksums, it does not matter if we pick up too many
      if (-s "$reporoot/$projid/$arepoid/$myarch/$apackid/.checksums") {
        $checksums .= readstr("$reporoot/$projid/$arepoid/$myarch/$apackid/.checksums", 1) || '';
      }
    }
    $bininfo->{$tfilename} = $bi;
    my $ci = { 'repository' => $arepoid, 'package' => $apackid };
    $ci->{'supportstatus'} = $supportstatus if defined $supportstatus;
    $channelinfo{$tfilename} = $ci;
  }
  BSUtil::store("$jobdatadir/.channelinfo", undef, \%channelinfo);
  writestr("$jobdatadir/.checksums", undef, $checksums) if $checksums;
  writestr("$jobdatadir/meta", undef, $new_meta);
  BSSched::BuildJob::fakejobfinished_nouseforbuild($ctx, $packid, $job, 'succeeded', $bininfo, $pdata);
  return ('done');
}

##########################################################################
##########################################################################
##
##  aggregate package type handling
##

#
# checkaggregate  - calculate package status of an aggregate package
#
# input:  $ctx         - our context
#         $packid      - aggregate package
#         $pdata       - package data information
# output: new package status
#         package status details (new meta in 'scheduled' case)
#
# globals used: $projpacks
#
sub checkaggregate {
  my ($ctx, $packid, $pdata, $info) = @_;

  my $gctx = $ctx->{'gctx'};
  my $myarch = $gctx->{'arch'};
  my $projid = $ctx->{'project'};
  my $repoid = $ctx->{'repository'};
  my $reporoot = $gctx->{'reporoot'};
  # clone it as we may patch the 'packages' array below
  my $aggregates = Storable::dclone($pdata->{'aggregatelist'}->{'aggregate'} || []);
  my @broken;
  my @blocked;
  my $prpfinished = $gctx->{'prpfinished'};
  my $delayed;
  my %gbininfos;
  my $projpacks = $gctx->{'projpacks'};
  my $remoteprojs = $gctx->{'remoteprojs'};
  for my $aggregate (@$aggregates) {
    my $aprojid = $aggregate->{'project'};
    my $proj = $remoteprojs->{$aprojid} || $projpacks->{$aprojid};
    if (!$proj) {
      push @broken, $aprojid;
      next;
    }
    if ($proj->{'error'}) {
      if (BSSched::RPC::is_transient_error($proj->{'error'})) {
        # XXX: hmm, there's already a project retryevent on $aprojid
        addretryevent($gctx, {'type' => 'package', 'project' => $projid, 'package' => $packid});
        $delayed = 1;
      }
      push @broken, $aprojid;
      next;
    }
    if (!checkprpaccess($gctx, $aprojid, $projid)) {
      push @broken, $aprojid;
      next;
    }
    my @arepoids = grep {!exists($_->{'target'}) || $_->{'target'} eq $repoid} @{$aggregate->{'repository'} || []};
    if (@arepoids) {
      @arepoids = map {$_->{'source'}} grep {exists($_->{'source'})} @arepoids;
    } else {
      @arepoids = ($repoid);
    }
    my @apackids = @{$aggregate->{'package'} || []};
    my $abinfilter;
    $abinfilter = { map {$_ => 1} @{$aggregate->{'binary'}} } if $aggregate->{'binary'};
    for my $arepoid (@arepoids) {
      my $aprp = "$aprojid/$arepoid";
      my $arepo = (grep {$_->{'name'} eq $arepoid} @{$proj->{'repository'} || []})[0];
      if (!$arepo || !grep {$_ eq $myarch} @{$arepo->{'arch'} || []}) {
	push @broken, $aprp;
	next;
      }
      next if !$remoteprojs->{$aprojid} && $prpfinished->{$aprp} && $aggregate->{'package'};	# no need to check blocked state
      # notready/prpnotready is indexed with source binary names, so we cannot use it here...
      my $ps = BSUtil::retrieve("$reporoot/$aprp/$myarch/:packstatus", 1);
      if (!$ps) {
	$ps = (readxml("$reporoot/$aprp/$myarch/:packstatus", $BSXML::packstatuslist, 1) || {})->{'packstatus'} || [];
	$ps = { 'packstatus' => { map {$_->{'name'} => $_->{'status'}} @$ps } };
      }
      $ps = ($ps || {})->{'packstatus'} || {};

      # for remote projects we always need the gbininfo
      if ($remoteprojs->{$aprojid}) {
	my $gbininfo = read_gbininfo_remote($ctx, "$aprp/$myarch", $remoteprojs->{$aprojid}, $ps);
	$gbininfos{"$aprp/$myarch"} = $gbininfo;
	if (!$gbininfo) {
	  $delayed = 1 if defined $gbininfo;
	  push @broken, $aprp;
	  next;
	}
      }

      if (!$aggregate->{'package'}) {
        # calculate apackids using the gbininfo file
        my $gbininfo;
        if ($remoteprojs->{$aprojid}) {
          $gbininfo = $gbininfos{"$aprp/$myarch"};
        } else {
          $gbininfo = BSSched::BuildResult::read_gbininfo("$reporoot/$aprp/$myarch");
        }
	if (!$gbininfo) {
	  push @broken, $aprp;
	  next;
	}
	for my $apackid (keys %$gbininfo) {
	  next if $apackid eq '_volatile';
	  my $bininfo = $gbininfo->{$apackid};
	  if ($abinfilter) {
	    next unless grep {defined($_->{'name'}) && $abinfilter->{$_->{'name'}}} values %$bininfo;
	  }
	  push @apackids, $apackid;
	}
	@apackids = unify(sort(@apackids));
      }

      for my $apackid (@apackids) {
	my $code = $ps->{$apackid} || 'unknown';
	if ($code eq 'scheduled' || $code eq 'blocked' || $code eq 'finished') {
	  next if $aprojid eq $projid && $arepoid eq $repoid && $apackid eq $packid;
	  push @blocked, "$aprp/$apackid";
	}
      }
    }
    # patch in calculated package list
    $aggregate->{'package'} ||= \@apackids;
  }
  if (@broken) {
    my $error = 'missing repositories: '.join(', ', @broken);
    print "      - $packid (aggregate)\n";
    print "        broken ($error)\n";
    print "        (delayed)\n" if $delayed;
    return ('delayed', $error) if $delayed;
    return ('broken', $error);
  }
  if (@blocked) {
    print "      - $packid (aggregate)\n";
    print "        blocked (@blocked)\n";
    return ('blocked', join(', ', @blocked));
  }
  my @new_meta;
  for my $aggregate (@$aggregates) {
    my $aprojid = $aggregate->{'project'};
    my @apackids = @{$aggregate->{'package'} || []};
    my @arepoids = grep {!exists($_->{'target'}) || $_->{'target'} eq $repoid} @{$aggregate->{'repository'} || []};
    if (@arepoids) {
      @arepoids = map {$_->{'source'}} grep {exists($_->{'source'})} @arepoids;
    } else {
      @arepoids = ($repoid);
    }
    for my $arepoid (@arepoids) {
      for my $apackid (@apackids) {
	my $m = '';
        if ($remoteprojs->{$aprojid}) {
	  my $bininfo = ($gbininfos{"$aprojid/$arepoid/$myarch"} || {})->{$apackid} || {};
	  for my $b (sort {$a->{'filename'} cmp $b->{'filename'}} values %$bininfo) {
	    next unless $b->{'filename'} && ($b->{'filename'} eq 'updateinfo.xml' || $b->{'filename'} =~ /\.(?:$binsufsre)$/);
	    $m .= $b->{'hdrmd5'} || $b->{'md5sum'} || '';
	  }
	} else {
	  next if $aprojid eq $projid && $arepoid eq $repoid && $apackid eq $packid;
	  my $d = "$reporoot/$aprojid/$arepoid/$myarch/$apackid";
	  my @d = grep {$_ eq 'updateinfo.xml' || /\.(?:$binsufsre)$/} ls($d);
	  for my $b (sort @d) {
	    my @s = stat("$d/$b");
	    next unless @s;
	    $m .= "$b\0$s[9]/$s[7]/$s[1]\0";
	  }
	}
	$m = Digest::MD5::md5_hex($m)."  $aprojid/$arepoid/$myarch/$apackid";
	push @new_meta, $m;
      }
    }
  }
  my @meta;
  if (open(F, '<', "$reporoot/$projid/$repoid/$myarch/:meta/$packid")) {
    @meta = <F>;
    close F;
    chomp @meta;
  }
  if (join('\n', @meta) eq join('\n', @new_meta)) {
    print "      - $packid (aggregate)\n";
    print "        nothing changed\n";
    return ('done');
  }
  my @diff = diffsortedmd5(\@meta, \@new_meta);
  print "      - $packid (aggregate)\n";
  print "        $_\n" for @diff;
  my $new_meta = join('', map {"$_\n"} @new_meta);
  return ('scheduled', [ $new_meta, $aggregates ]);
}

#
# rebuildaggregate  - copy packages from other projects to rebuild an
#                     aggregate
#
# input:  $projid    - our project
#         $repoid    - our repository
#         $packid    - aggregate package
#         $pdata     - package data information
#         $info      - file and dependency information
#         $new_meta  - the new meta file data
# output: new package status
#         package status details
#
# globals used: $projpacks
#
sub rebuildaggregate {
  my ($ctx, $packid, $pdata, $info, $data) = @_;

  my $new_meta = $data->[0];
  my $aggregates = $data->[1];
  my $gctx = $ctx->{'gctx'};
  my $myarch = $gctx->{'arch'};
  my $projid = $ctx->{'project'};
  my $repoid = $ctx->{'repository'};
  my $prp = "$projid/$repoid";
  my $job = BSSched::BuildJob::jobname($prp, $packid);
  my $myjobsdir = $gctx->{'myjobsdir'};
  return ('scheduled', $job) if -s "$myjobsdir/$job";
  my $reporoot = $gctx->{'reporoot'};
  my $remoteprojs = $gctx->{'remoteprojs'};
  my $jobdatadir = "$myjobsdir/$job:dir";
  unlink "$jobdatadir/$_" for ls($jobdatadir);
  mkdir_p($jobdatadir);
  my $jobrepo = {};
  my %jobbins;
  my $error;
  for my $aggregate (@$aggregates) {
    my $aprojid = $aggregate->{'project'};
    my @arepoids = grep {!exists($_->{'target'}) || $_->{'target'} eq $repoid} @{$aggregate->{'repository'} || []};
    if (@arepoids) {
      @arepoids = map {$_->{'source'}} grep {exists($_->{'source'})} @arepoids;
    } else {
      @arepoids = ($repoid);
    }
    my @apackids = @{$aggregate->{'package'} || []};
    my $abinfilter;
    $abinfilter = { map {$_ => 1} @{$aggregate->{'binary'}} } if $aggregate->{'binary'};
    for my $arepoid (reverse @arepoids) {
      for my $apackid (@apackids) {
        my @d;
	my $cpio;
        my $nosource = exists($aggregate->{'nosources'}) ? 1 : 0;
        my $updateinfo;
        if ($remoteprojs->{$aprojid}) {
	  my $param = {
	    'uri' => "$remoteprojs->{$aprojid}->{'remoteurl'}/build/$remoteprojs->{$aprojid}->{'remoteproject'}/$arepoid/$myarch/$apackid",
	    'receiver' => \&BSHTTP::cpio_receiver,
	    'directory' => $jobdatadir,
	    'map' => "upload:",
	    'timeout' => 300,
	    'proxy' => $gctx->{'remoteproxy'},
	  };
	  my $done;
	  if ($nosource) {
	    eval {
	      $cpio = BSRPC::rpc($param, undef, "view=cpio", "nosource=1");
	    };
	    $done = 1 if !$@ || $@ !~ /nosource/;
	  }
	  eval {
	    $cpio = BSRPC::rpc($param, undef, "view=cpio");
	  } unless $done;
	  if ($@) {
	    warn($@);
	    $error = $@;
	    $error =~ s/\n$//s;
	    addretryevent($ctx->{'gctx'}, {'type' => 'repository', 'project' => $aprojid, 'repository' => $arepoid, 'arch' => $myarch}) if BSSched::RPC::is_transient_error($error);
	    last;
	  }
	  for my $bin (@{$cpio || []}) {
	    $updateinfo = "$jobdatadir/$bin->{'name'}" if $bin->{'name'} eq 'upload:updateinfo.xml';
	    push @d, "$jobdatadir/$bin->{'name'}";
	  }
        } else {
	  next if $aprojid eq $projid && $arepoid eq $repoid && $apackid eq $packid;
	  my $d = "$reporoot/$aprojid/$arepoid/$myarch/$apackid";
	  $updateinfo = "$d/updateinfo.xml" if -f "$d/updateinfo.xml";
	  @d = grep {/\.(?:$binsufsre)$/} ls($d);
          @d = map {"$d/$_"} sort(@d);
          $nosource = 1 if -e "$d/.nosourceaccess";
	}
	my $ajobrepo = findbins_dir(\@d);
	my $copysources;
	for my $abin (sort keys %$ajobrepo) {
	  my $r = $ajobrepo->{$abin};
	  next unless $r->{'source'};
	  next if $abinfilter && !$abinfilter->{$r->{'name'}};
	  # FIXME: How is debian handling debug packages ?
	  next if $nosource && ($r->{'name'} =~ /-debug(:?info|source)?$/);
	  my $basename = $abin;
	  $basename =~ s/.*\///;
	  $basename =~ s/^upload:// if $cpio;
	  $basename =~ s/^::import::.*?:://;
	  next if $jobbins{$basename};	# first one wins
	  $jobbins{$basename} = 1;
	  BSUtil::cp($abin, "$jobdatadir/$basename");
	  $jobrepo->{"$jobdatadir/$basename"} = $r;
	  $copysources = 1 unless $nosource;
	}
	if ($updateinfo && !($abinfilter && !$abinfilter->{'updateinfo.xml'})) {
	  BSUtil::cp($updateinfo, "$jobdatadir/updateinfo.xml");
	}
	if ($copysources) {
	  for my $abin (sort keys %$ajobrepo) {
	    my $r = $ajobrepo->{$abin};
	    next if $r->{'source'};
	    my $basename = $abin;
	    $basename =~ s/.*\///;
	    $basename =~ s/^upload:// if $cpio;
	    BSUtil::cp($abin, "$jobdatadir/$basename");
	    $jobrepo->{"$jobdatadir/$basename"} = $r;
	  }
	}
        for my $bin (@{$cpio || []}) {
	  unlink("$jobdatadir/$bin->{'name'}");
	}
      }
      last if $error;
    }
    last if $error;
  }
  if ($error) {
    print "        $error\n";
    BSUtil::cleandir($jobdatadir);
    rmdir($jobdatadir);
    return ('failed', $error);
  }
  writestr("$jobdatadir/meta", undef, $new_meta);
  my $needsign;
  $needsign = 1 if $sign && grep {/\.(?:rpm|pkg\.tar\.gz|pkg\.tar.xz)$/} keys %$jobrepo;
  BSSched::BuildJob::fakejobfinished($ctx, $packid, $job, 'succeeded', { 'file' => '_aggregate' }, $needsign);
  print "        scheduled\n";
  return ('scheduled', $job);
}


##########################################################################
##########################################################################
##
##  preinstallimage type handling
##

sub checkpreinstallimage {
  my ($ctx, $packid, $pdata, $info) = @_;

  my $projid = $ctx->{'project'};
  my $repoid = $ctx->{'repository'};

  # check if we're blocked
  my $edeps = $ctx->{'edeps'}->{$packid} || [];
  my $notready = $ctx->{'notready'};
  my $dep2src = $ctx->{'dep2src'};
  my $dep2pkg = $ctx->{'dep2pkg'};
  my @blocked = grep {$notready->{$dep2src->{$_}}} @$edeps;
  return ('blocked', join(', ', @blocked)) if @blocked;

  # expand like in BSSched::BuildJob::create, so that we have all used packages
  # in the meta file
  my $bconf = $ctx->{'conf'};
  my ($eok, @bdeps) = Build::get_build($bconf, [], @{$info->{'dep'} || []});
  if (!$eok) {
    print "      - $packid (preinstallimage)\n";
    print "        unresolvable:\n";
    print "          $_\n" for @bdeps;
    return ('unresolvable', join(', ', @bdeps));
  }
  my @pdeps = Build::get_preinstalls($bconf);
  my @vmdeps = Build::get_vminstalls($bconf);
  @bdeps = unify(@pdeps, @vmdeps, @bdeps);

  # create meta
  my $pool = $ctx->{'pool'};
  my @new_meta;
  for my $dep (@bdeps) {
    my $p = $dep2pkg->{$dep};
    if (!$p) {
      print "      - $packid (preinstallimage)\n";
      print "        unresolvable:\n          $dep\n";
      return ('unresolvable', $dep);
    }
    push @new_meta, $pool->pkg2pkgid($p)."  $dep";
  }
  @new_meta = BSSolv::gen_meta([], @new_meta);

  unshift @new_meta, ($pdata->{'verifymd5'} || $pdata->{'srcmd5'})."  $packid";
  return metacheck($ctx, $packid, 'preinstallimage', \@new_meta, [ \@bdeps ]);
}

sub rebuildpreinstallimage {
  my ($ctx, $packid, $pdata, $info, $data) = @_;
  my $bdeps = $data->[0];
  my $reason = $data->[1];
  return BSSched::BuildJob::create($ctx, $packid, $pdata, $info, [], $bdeps, $reason, 0);
}


##########################################################################
##########################################################################
##
##  standard package type handling
##

sub checkpackage {
  my ($ctx, $packid, $pdata, $info, $buildtype) = @_;
  my $projid = $ctx->{'project'};
  my $repoid = $ctx->{'repository'};
  my $repo = $ctx->{'repo'};
  my $prp = $ctx->{'prp'};
  my $notready = $ctx->{'notready'};
  my $dep2src = $ctx->{'dep2src'};
  my $edeps = $ctx->{'edeps'}->{$packid} || [];
  my $depislocal = $ctx->{'depislocal'};
  my $gdst = $ctx->{'gdst'};
  my $gctx = $ctx->{'gctx'};
  my $reporoot = $gctx->{'reporoot'};
  my $myarch = $gctx->{'arch'};

  # check for localdep repos
  if (exists($pdata->{'originproject'})) {
    if ($repo->{'linkedbuild'} && $repo->{'linkedbuild'} eq 'localdep') {
      if (!grep {$depislocal->{$_}} @$edeps) {
	return ('excluded', 'project link, only depends on non-local packages');
      }
    }
  }

  # calculate if we're blocked
  my @blocked = grep {$notready->{$dep2src->{$_}}} @$edeps;
  @blocked = () if $repo->{'block'} && $repo->{'block'} eq 'never';
  if ($ctx->{'cychash'}->{$packid}) {
    # package belongs to a cycle, prune blocked list
    my $cycpass = $ctx->{'cycpass'}->{$packid} || 0;
    if (@blocked && $cycpass == 3) {
      # cycpass == 2 means that packages of this cycle are building
      # because of source changes
      print "      - $packid ($buildtype)\n";
      print "        blocked by cycle builds ($blocked[0]...)\n";
      return ('blocked', join(', ', @blocked));
    }
    my %cycs = map {$_ => 1} @{$ctx->{'cychash'}->{$packid}};
    # prune building cycle packages from blocked
    my $building = $ctx->{'building'};
    @blocked = grep {!$cycs{$dep2src->{$_}} || !$building->{$dep2src->{$_}}} @blocked;
    if (@blocked) {
      print "      - $packid ($buildtype)\n";
      print "        blocked ($blocked[0]...)\n";
    }
  }
  if (@blocked) {
    # print "      - $packid ($buildtype)\n";
    # print "        blocked\n";
    return ('blocked', join(', ', @blocked));
  }

  my $reason;
  my @meta_s = stat("$gdst/:meta/$packid");
  # we store the lastcheck data in one string instead of an array
  # with 4 elements to save precious memory
  # srcmd5.metamd5.hdrmetamd5.statdata (32+32+32+x)
  my $lastcheck = $ctx->{'lastcheck'};
  my $mylastcheck = $lastcheck->{$packid};
  my @meta;
  if (!@meta_s || !$mylastcheck || substr($mylastcheck, 96) ne "$meta_s[9]/$meta_s[7]/$meta_s[1]") {
    if (open(F, '<', "$gdst/:meta/$packid")) {
      @meta_s = stat F;
      @meta = <F>;
      close F;
      chomp @meta;
      $mylastcheck = substr($meta[0], 0, 32);
      if (@meta == 2 && $meta[1] =~ /^fake/) {
	$mylastcheck .= 'fakefakefakefakefakefakefakefake';
      } else {
	$mylastcheck .= Digest::MD5::md5_hex(join("\n", @meta));
      }
      $mylastcheck .= 'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx';
      $mylastcheck .= "$meta_s[9]/$meta_s[7]/$meta_s[1]";
      $lastcheck->{$packid} = $mylastcheck;
    } else {
      delete $lastcheck->{$packid};
      undef $mylastcheck;
    }
  }
  if (!$mylastcheck) {
    print "      - $packid ($buildtype)\n";
    print "        no meta, start build\n";
    return ('scheduled', [ { 'explain' => 'new build' } ]);
  } elsif (substr($mylastcheck, 0, 32) ne ($pdata->{'verifymd5'} || $pdata->{'srcmd5'})) {
    print "      - $packid ($buildtype)\n";
    print "        src change, start build\n";
    return ('scheduled', [ { 'explain' => 'source change', 'oldsource' => substr($mylastcheck, 0, 32) } ]);
  } elsif (substr($mylastcheck, 32, 32) eq 'fakefakefakefakefakefakefakefake') {
    my @s = stat("$gdst/:meta/$packid");
    if (!@s || $s[9] + 14400 > time()) {
      print "      - $packid ($buildtype)\n";
      print "        buildsystem setup failure\n";
      return ('failed')
    }
    print "      - $packid ($buildtype)\n";
    print "        retrying bad build\n";
    return ('scheduled', [ { 'explain' => 'retrying bad build' } ]);
  } else {
    my $rebuildmethod = $repo->{'rebuild'} || 'transitive';
    if ($rebuildmethod eq 'local' || $pdata->{'hasbuildenv'}) {
      # rebuild on src changes only
      goto relsynccheck;
    }
    # more work, check if dep rpm changed
    if ($ctx->{'incycle'}) {
      # print "      - $packid ($buildtype)\n";
      # print "        in cycle, no source change...\n";
      return ('done');
    }
    my $check = substr($mylastcheck, 32, 32);
    my $pool = $ctx->{'pool'};
    my $dep2pkg = $ctx->{'dep2pkg'};
    $check .= $rebuildmethod;
    $check .= $pool->pkg2pkgid($dep2pkg->{$_}) for sort @$edeps;
    $check = Digest::MD5::md5_hex($check);
    if ($check eq substr($mylastcheck, 64, 32)) {
      # print "      - $packid ($buildtype)\n";
      # print "        nothing changed\n";
      goto relsynccheck;
    }
    substr($mylastcheck, 64, 32) = $check;
    # even more work, generate new meta, check if it changed
    my @new_meta;
    my $repodatas = $gctx->{'repodatas'};
    my $dep2meta = $repodatas->{$prp}->{'meta'};
    $repodatas->{$prp}->{'meta'} = $dep2meta = {} unless $dep2meta;
    for my $bpack (@$edeps) {
      my $pkg = $dep2pkg->{$bpack};
      my $path = $pool->pkg2fullpath($pkg, $myarch);
      if ($depislocal->{$bpack} && $path) {
	if (!exists $dep2meta->{$bpack}) {
	  my @m;
	  # the next line works for deb and rpm
	  my $mf = substr("$reporoot/$path", 0, -4);
	  #print "        reading meta for $path\n";
	  if (! -e "$mf.meta") {
	    # the generic version
	    $mf = "$reporoot/$path";
	    $mf =~ s/\.(?:$binsufsre)$//;
	  }
	  if (open(F, '<', "$mf.meta") || open(F, '<', "$mf-MD5SUMS.meta")) {
	    @m = <F>;
	    close F;
	    chomp @m;
	    s/  /  $bpack\// for @m;
	  }
	  @m = ($pool->pkg2pkgid($pkg)."  $bpack") unless @m;
	  $dep2meta->{$bpack} = join("\n", @m);
	  # do not include our own build results
	  next if $m[0] =~ /\/\Q$packid\E$/s;
	  # fixup first line 
	  $m[0] =~ s/  .*/  $bpack/;
	  push @new_meta, @m;
	} else {
	  my $oldlen = @new_meta;
	  push @new_meta, split("\n", $dep2meta->{$bpack});
	  next if $oldlen == @new_meta;		# hmm?
	  # do not include our own build results
	  if ($new_meta[$oldlen] =~ /\/\Q$packid\E$/) {
	    splice(@new_meta, $oldlen);
	    next;
	  }
	  # fixup first line
	  $new_meta[$oldlen] =~ s/  .*/  $bpack/;
	}
      } else {
	my $pkgid = $pool->pkg2pkgid($pkg);
	push @new_meta, "$pkgid  $bpack";
      }
    }
    @new_meta = BSSolv::gen_meta($ctx->{'subpacks'}->{$info->{'name'}} || [], @new_meta);
    unshift @new_meta, ($pdata->{'verifymd5'} || $pdata->{'srcmd5'})."  $packid";
    if (Digest::MD5::md5_hex(join("\n", @new_meta)) eq substr($mylastcheck, 32, 32)) {
      # print "      - $packid ($buildtype)\n";
      # print "        nothing changed (looked harder)\n";
      $ctx->{'nharder'}++;
      $lastcheck->{$packid} = $mylastcheck;
      goto relsynccheck;
    }
    # something changed, read in old meta (if not already done)
    if (!@meta && open(F, '<', "$gdst/:meta/$packid")) {
      @meta = <F>;
      close F;
      chomp @meta;
    }
    if ($rebuildmethod eq 'direct') {
      @meta = grep {!/\//} @meta;
      @new_meta = grep {!/\//} @new_meta;
    }
    if (@meta == @new_meta && join('\n', @meta) eq join('\n', @new_meta)) {
      # print "      - $packid ($buildtype)\n";
      # print "        nothing changed (looked harder)\n";
      $ctx->{'nharder'}++;
      if ($rebuildmethod eq 'direct') {
	$lastcheck->{$packid} = $mylastcheck;
      } else {
	# should not happen, delete lastcheck cache
	delete $lastcheck->{$packid};
      }
      goto relsynccheck;
    }
    my @diff = diffsortedmd5(\@meta, \@new_meta);
    print "      - $packid ($buildtype)\n";
    print "        $_\n" for @diff;
    print "        meta change, start build\n";
    return ('scheduled', [ { 'explain' => 'meta change', 'packagechange' => sortedmd5toreason(@diff) } ] );
  }
relsynccheck:
  if ($ctx->{'relsynctrigger'}->{$packid}) {
    print "      - $packid ($buildtype)\n";
    print "        rebuild counter sync, start build\n";
    return ('scheduled', [ { 'explain' => 'rebuild counter sync' } ] );
  }
  return ('done');
}

sub rebuildpackage {
  my ($ctx, $packid, $pdata, $info, $data) = @_;

  my $reason = $data->[0];
  my $needed = $ctx->{'rebuildpackage_needed'};
  if (!$needed) {
    $needed = $ctx->{'rebuildpackage_needed'} = {};
    my $edeps = $ctx->{'edeps'};
    my $dep2src = $ctx->{'dep2src'};
    for my $p (keys %$edeps) {
      $needed->{$_}++ for map { $dep2src->{$_} || $_ } @{$edeps->{$p}};
    }
  }
  $info->{'nounchanged'} = 1 if $ctx->{'cychash'}->{$packid};
  my ($state, $job) = BSSched::BuildJob::create($ctx, $packid, $pdata, $info, $ctx->{'subpacks'}->{$info->{'name'}} || [], $ctx->{'edeps'}->{$packid} || [], $reason, $needed->{$packid} || 0);
  delete $info->{'nounchanged'};
  return ($state, $job);
}

##########################################################################
##########################################################################

sub select_read {
  my ($timeout, @watchers) = @_;
  my @retrywatchers = grep {$_->{'retry'}} @watchers;
  if (@retrywatchers) {
    my $now = time();
    for (splice @retrywatchers) {
      if ($_->{'retry'} <= $now) {
        push @retrywatchers, $_;
	next;
      }
      $timeout = $_->{'retry'} - $now if !defined($timeout) || $_->{'retry'} - $now < $timeout;
    }
    return @retrywatchers if @retrywatchers;
    @watchers = grep {!$_->{'retry'}} @watchers;
  }
  @watchers = grep {exists $_->{'socket'}} @watchers;
  while(1) {
    my $rin = '';
    for (@watchers) {
      vec($rin, fileno($_->{'socket'}), 1) = 1;
    }
    my $nfound = select($rin, undef, undef, $timeout);
    if (!defined($nfound) || $nfound == -1) {
      next if $! == POSIX::EINTR;
      die("select: $!\n");
    }
    return () if !$nfound && defined($timeout);
    die("select: $!\n") unless $nfound;
    @watchers = grep {vec($rin, fileno($_->{'socket'}), 1)} @watchers;
    die unless @watchers;
    return @watchers;
  }
}

sub changed2lookat {
  my ($gctx, $changed_low, $changed_med, $changed_high, $lookat_high, $lookat_med, $lookat_next) = @_;

  push @$lookat_high, grep {$changed_high->{$_}} sort keys %$changed_med;
  push @$lookat_med, grep {!$changed_high->{$_}} sort keys %$changed_med;
  @$lookat_high = unify(@$lookat_high);
  @$lookat_med = unify(@$lookat_med);
  my %lookat_high = map {$_ => 1} @$lookat_high;
  @$lookat_med = grep {!$lookat_high{$_}} @$lookat_med;
  my $prpdeps = $gctx->{'prpdeps'};
  for my $prp (@{$gctx->{'prps'}}) {
    if (!$changed_low->{$prp} && !$changed_med->{$prp}) {
      next unless grep {$changed_med->{$_}} @{$prpdeps->{$prp}};
    }
    $lookat_next->{$prp} = 1;
  }
  %$changed_low = ();
  %$changed_med = ();
  %$changed_high = ();
}

sub updaterelsyncmax {
  my ($gctx, $prp, $arch, $new, $cleanup) = @_;
  my $reporoot = $gctx->{'reporoot'};
  local *F;
  BSUtil::lockopen(\*F, '+>>', "$reporoot/$prp/$arch/:relsync.max");
  my $relsyncmax;
  if (-s "$reporoot/$prp/$arch/:relsync.max") {
    $relsyncmax = BSUtil::retrieve("$reporoot/$prp/$arch/:relsync.max", 2);
  }
  $relsyncmax ||= {};
  my $changed;
  for my $tag (keys %$new) {
    next if defined($relsyncmax->{$tag}) && $relsyncmax->{$tag} >= $new->{$tag};   
    $relsyncmax->{$tag} = $new->{$tag};
    $changed = 1;
  }
  if ($cleanup) {
    for (grep {!$new->{$_}} keys %$relsyncmax) {
      delete $relsyncmax->{$_};
      $changed = 1;
    }
  }
  BSUtil::store("$reporoot/$prp/$arch/.:relsync.max", "$reporoot/$prp/$arch/:relsync.max", $relsyncmax) if $changed;
  close(F);
  return $changed;
}

sub no_expander {
  return 1, splice(@_, 2);
}

my %handlers = (
  'kiwi-product' => {
    'expand' => \&no_expander,
    'check' => \&checkkiwiproduct,
    'rebuild' => \&rebuildkiwiproduct,
  },
  'kiwi-image' => {
    'expand' => \&no_expander,
    'check' => \&checkkiwiimage,
    'rebuild' => \&rebuildkiwiimage,
  },
  'patchinfo' => {
    'expand' => \&no_expander,
    'check' => \&checkpatchinfo,
    'rebuild' => \&rebuildpatchinfo,
  },
  'aggregate' => {
    'expand' => \&no_expander,
    'check' => \&checkaggregate,
    'rebuild' => \&rebuildaggregate,
  },
  'preinstallimage' => {
    'expand' => \&Build::get_deps,
    'check' => \&checkpreinstallimage,
    'rebuild' => \&rebuildpreinstallimage,
  },
  'simpleimage' => {
    'expand' => \&Build::get_deps,
    'check' => \&checkpackage,
    'rebuild' => \&rebuildpackage,
  },
  'channel' => {
    'expand' => \&no_expander,
    'check' => \&checkchannel,
    'rebuild' => \&rebuildchannel,
  },
  'unknown' => {
    'expand' => \&no_expander,
    'check' => sub {return ('broken', 'unknown package type')},
  },
);

my $defaulthandler = {
  'expand' => \&Build::get_deps,
  'check' => \&checkpackage,
  'rebuild' => \&rebuildpackage,
};



##########################################################################
##########################################################################
##
## Scheduler startup code
##

$| = 1;
$SIG{'PIPE'} = 'IGNORE';
if ($testmode && ($testmode eq 'exit' || $testmode eq 'restart')) {
  if (!(-e "$_rundir/bs_sched.$_myarch.lock") || BSUtil::lockcheck('>>', "$_rundir/bs_sched.$_myarch.lock")) {
    die("scheduler is not running for $_myarch.\n") if $testmode eq 'restart';
    print("scheduler is not running for $_myarch.\n");
    exit(0);
  }
  if ($testmode eq 'restart') {
    print "restarting scheduler for $_myarch...\n";
  } else {
    print "shutting down scheduler for $_myarch...\n";
  }
  my $ev = {
    'type' => $testmode eq 'restart' ? 'restart' : 'exitcomplete',
  };
  my $evname = "$ev->{'type'}::";
  sendevent({'eventdir' => $_eventdir}, $ev, $_myarch, $evname);
  BSUtil::waituntilgone("$_eventdir/$_myarch/$evname");
  if ($testmode eq 'exit') {
    # scheduler saw the event, wait until the process is gone
    local *F;
    BSUtil::lockopen(\*F, '>>', "$_rundir/bs_sched.$_myarch.lock", 1);
    close F;
  }
  exit(0);
}
print "starting build service scheduler\n";

# get lock
mkdir_p($_rundir);
if (!$testprojid) {
  open(RUNLOCK, '>>', "$_rundir/bs_sched.$_myarch.lock") || die("$_rundir/bs_sched.$_myarch.lock: $!\n");
  flock(RUNLOCK, LOCK_EX | LOCK_NB) || die("scheduler is already running for $_myarch!\n");
  utime undef, undef, "$_rundir/bs_sched.$_myarch.lock";
}

for my $d ("$_eventdir/$_myarch", "$_jobsdir/$_myarch", $infodir) {
  next if -d $d;
  mkdir_p($d) || die("$d: $!\n");
}
# setup event mechanism
my $_myeventdir = "$_eventdir/$_myarch";
if (!-p "$_myeventdir/.ping") {
  POSIX::mkfifo("$_myeventdir/.ping", 0666) || die("$_myeventdir/.ping: $!");
  chmod(0666, "$_myeventdir/.ping");
}

sysopen(PING, "$_myeventdir/.ping", POSIX::O_RDWR) || die("$_myeventdir/.ping: $!");
fcntl(PING, F_SETFL, POSIX::O_NONBLOCK);


# changed: 1: something "local" changed, :full unchanged,
#          2: the :full repo is changed
# set all projects and prps to :full repo changed
my %changed_low;
my %changed_med;
my %changed_high;
my %changed_dirty;
my %lastcheck;
my %delayedfetchprojpacks;

my %lookat_next;	# not so important, next series
my @lookat_low;         # not so important
my @lookat_med;         # do those first (out of band), triggered through direct build results
my @lookat_high;        # do those really first so that our users are happy, triggered through user interaction

my %nextmed;

# create global context
my $gctx = {
  'arch' => $_myarch,
  'reporoot' => $_reporoot,

  # config
  'obsname' => $BSConfig::obsname,
  'jobsdir' => $_jobsdir,
  'myjobsdir' => "$_jobsdir/$_myarch",
  'eventdir' => $_eventdir,
  'myeventdir' => $_myeventdir,
  'extrepodir' => $_extrepodir,
  'dodsdir' => $_dodsdir,
  'rundir' => $_rundir,
  'remotecache' => $_remotecache,
  'remoteproxy' => $BSConfig::proxy,

  # repository state cache
  'repodatas' => \%_repodatas,
  'repodatas_alien' => \%_repodatas_alien,

  # remote bininfo cache
  'remotegbininfos' => \%_remotegbininfos,
  'remotepackstatus' => \%_remotepackstatus,
  'remotepackstatus_cleanup' => \%_remotepackstatus_cleanup,

  # project data
  'projpacks' => undef,
  'channeldata' => \%_channeldata,
  'remoteprojs' => \%_remoteprojs,

  # postprocessed project data
  'projpacks_linked' => [],
  'prps' => [],
  'prpdeps' => {},
  'prpnoleaf' => {},
  'prpsearchpath' => {},

  # triggers
  'prpcheckuseforbuild' => \%_prpcheckuseforbuild,
  'prpfinished' => \%_prpfinished,
  'repounchanged' => \%_repounchanged,
  'prpnotready' => \%_prpnotready,

  # remote watchers
  'watchremote' => {},			# remote_url => { eventdescr => projid }
  'watchremote_start' => {},		# remote_url => lasteventno

  'changed_low' => \%changed_low,
  'changed_med' => \%changed_med,
  'changed_high' => \%changed_high,
  'changed_dirty' => \%changed_dirty,

  'lookat_low' => \@lookat_low,
  'lookat_med' => \@lookat_med,
  'lookat_high' => \@lookat_high,
  'lookat_next' => \%lookat_next,

  'delayedfetchprojpacks' => \%delayedfetchprojpacks,

  'nextmed' => \%nextmed,
  'retryevents' => [],

  # stats
  'buildavg' => 1200,			 # start not at 0, but with 20min for the average ounter
};

my $rctx = BSSched::RPC->new(
  'maxserverload' => $_maxserverload,
  'wakeupfunction' => \&xrpc_setchanged,
);

$gctx->{'rctx'} = $rctx;

$gctx->{'testmode'} = 1 if $testmode;
$BSSched::ProjPacks::testprojid = $testprojid if $testprojid;

# read old state if present
if (!$testprojid && -s "$_rundir/bs_sched.$_myarch.state") {
  print "reading old state...\n";
  my $schedstate = BSUtil::retrieve("$_rundir/bs_sched.$_myarch.state", 2);
  unlink("$_rundir/bs_sched.$_myarch.state");
  if ($schedstate) {
    # just for testing...
    print "  - $_\n" for sort keys %$schedstate;
    if ($schedstate->{'projpacks'}) {
      $gctx->{'projpacks'} = $schedstate->{'projpacks'};
      if ($schedstate->{'remoteprojs'}) {
	$gctx->{'remoteprojs'} = $schedstate->{'remoteprojs'};
	for (values %{$gctx->{'remoteprojs'}}) {
	  next unless $_->{'sibling'};
	  $_->{'partition'} ||= $_->{'sibling'};
	  delete $_->{'sibling'};
	}
      }
    } else {
      # get project and package information from src server
      BSSched::ProjPacks::get_projpacks($gctx, undef);	# XXX: async
    }
    BSSched::ProjPacks::get_projpacks_postprocess($gctx);
    my $projpacks = $gctx->{'projpacks'};
    my $prps = $gctx->{'prps'};

    my %oldprps = map {$_ => 1} @{$schedstate->{'prps'} || []};
    my @newprps = grep {!$oldprps{$_}} @$prps;

    # update lookat arrays
    @lookat_low = @{$schedstate->{'lookat'} || []};
    @lookat_med = @{$schedstate->{'lookat_oob'} || []};
    @lookat_high = @{$schedstate->{'lookat_oobhigh'} || []};

    # update changed hash
    %changed_low = ();
    %changed_med = ();
    %changed_high = ();
    for my $prp (@newprps) {
      $changed_med{$prp} = 2;
      $changed_med{(split('/', $prp, 2))[0]} = 2;
    }

    my $oldchanged_low = $schedstate->{'changed_low'} || {};
    my $oldchanged_med = $schedstate->{'changed_med'} || {};
    my $oldchanged_high = $schedstate->{'changed_high'} || {};
    for my $projid (keys %$projpacks) {
      $changed_low{$projid} = $oldchanged_low->{$projid} if exists $oldchanged_low->{$projid};
      $changed_med{$projid} = $oldchanged_med->{$projid} if exists $oldchanged_med->{$projid};
      $changed_high{$projid} = $oldchanged_high->{$projid} if exists $oldchanged_high->{$projid};
    }
    for my $prp (@$prps) {
      $changed_low{$prp} = $oldchanged_low->{$prp} if exists $oldchanged_low->{$prp};
      $changed_med{$prp} = $oldchanged_med->{$prp} if exists $oldchanged_med->{$prp};
      $changed_high{$prp} = $oldchanged_high->{$prp} if exists $oldchanged_high->{$prp};
    }

    ## update repodata hash
    #my $oldrepodata = $schedstate->{'repodata'} || {};
    #for my $prp (@$prps) {
    #  $repodata{$prp} = $oldrepodata->{$prp} if exists $oldrepodata->{$prp};
    #}

    # update prpfinished hash
    my $oldprpfinished = $schedstate->{'prpfinished'} || {};
    my $prpfinished = $gctx->{'prpfinished'};
    for my $prp (@$prps) {
      $prpfinished->{$prp} = $oldprpfinished->{$prp} if exists $oldprpfinished->{$prp};
    }

    # update prpnotready hash
    my $oldprpnotready = $schedstate->{'globalnotready'} || {};
    my $prpnotready = $gctx->{'prpnotready'};
    for my $prp (@$prps) {
      $prpnotready->{$prp} = $oldprpnotready->{$prp} if %{$oldprpnotready->{$prp} || {}};
    }

    # update repounchanged hash
    my $oldrepounchanged = $schedstate->{'repounchanged'} || {};
    my $repounchanged = $gctx->{'repounchanged'};
    for my $prp (@$prps) {
      $repounchanged->{$prp} = $oldrepounchanged->{$prp} if exists $oldrepounchanged->{$prp};
    }

    # update delayedfetchprojpacks hash
    my $olddelayedfetchprojpacks = $schedstate->{'delayedfetchprojpacks'} || {};
    for my $projid (keys %$projpacks) {
      $delayedfetchprojpacks{$projid} = $olddelayedfetchprojpacks->{$projid} if $olddelayedfetchprojpacks->{$projid};
    }

    # use old start values
    if ($schedstate->{'watchremote_start'}) {
      $gctx->{'watchremote_start'} = $schedstate->{'watchremote_start'};
    }

    # start project data fetch for delayed startup projects
    for my $projid (sort keys %$projpacks) {
      my $packs = $projpacks->{$projid}->{'package'} || {};
      for my $packid (sort keys %$packs) {
        $delayedfetchprojpacks{$projid} = [ '/all' ] if ($packs->{$packid}->{'error'} || '') eq 'delayed startup';
      }
    }

    if ($schedstate->{'fetchprojpacks'} && $schedstate->{'projpacks'}) {
      my %fetchprojpacks_nodelay = map {$_ => 1} keys %{$schedstate->{'fetchprojpacks'}};
      BSSched::ProjPacks::do_fetchprojpacks($gctx, $asyncmode, $schedstate->{'fetchprojpacks'}, \%fetchprojpacks_nodelay, {}, {});
    }
  }
}

if (!$gctx->{'projpacks'} && $startupmode) {
  if ($startupmode == 1) {
    print "cold start, scanning all non-remote projects\n";
  } else {
    print "cold start, initializing all projects\n";
  }
  my $param = {
    'uri' => "$BSConfig::srcserver/getprojpack",
  };
  my @args = ('withrepos', 'withconfig', "arch=$_myarch", 'withremotemap=1', 'noremote=1');
  push @args, 'withsrcmd5', 'withdeps' if $startupmode == 1;
  push @args, "partition=$BSConfig::partition" if $BSConfig::partition;
  my $projpacksin;
  while (1) {
    eval {
      $projpacksin = BSRPC::rpc($param, $BSXML::projpack, @args);
    };
    last unless $@ || !$projpacksin;
    print $@ if $@;
    print "retrying in 60 seconds...\n";
    sleep(60);
  }
  BSSched::ProjPacks::update_projpacks($gctx, $projpacksin);
  BSSched::ProjPacks::get_projpacks_postprocess($gctx);
  my $projpacks = $gctx->{'projpacks'};
  for my $projid (sort keys %$projpacks) {
    my $packs = $projpacks->{$projid}->{'package'} || {};
    next unless %$packs;
    if ($startupmode == 1) {
      my @delayed;
      my $ok;
      for my $packid (sort keys %$packs) {
	my $pdata = $packs->{$packid};
	if ($pdata->{'error'}) {
	  if ($pdata->{'error'} =~ /noremote option/) {
	    $pdata->{'error'} = 'delayed startup';
	    push @delayed, $packid;
	  } else {
	    $ok++;
	  }
	} else {
	  if (grep {$_->{'error'} && $_->{'error'} =~ /noremote option/} @{$pdata->{'info'} || []}) {
	    $pdata->{'error'} = 'delayed startup';
	    push @delayed, $packid;
	  } else {
	    $ok++;
	  }
	}
      }
      if (!$ok) {
        $delayedfetchprojpacks{$projid} = [ '/all' ];	# hack
      } else {
        $delayedfetchprojpacks{$projid} = [ @delayed ];
      }
    } else {
      $delayedfetchprojpacks{$projid} = [ '/all' ];	# hack
      for my $packid (sort keys %$packs) {
        $packs->{$packid}->{'error'} = 'delayed startup';
      }
    }
  }
  @lookat_low = sort keys %$projpacks;
  push @lookat_low, @{$gctx->{'prps'}};
  my $prpcheckuseforbuild = $gctx->{'prpcheckuseforbuild'};
  $prpcheckuseforbuild->{$_} = 1 for @{$gctx->{'prps'}};
}

if (!$gctx->{'projpacks'}) {
  # get project and package information from src server
  print "cold start, scanning all projects\n";
  BSSched::ProjPacks::get_projpacks($gctx, undef);
  BSSched::ProjPacks::get_projpacks($gctx, undef, 'opensuse_org') if $testprojid;
  BSSched::ProjPacks::get_projpacks_postprocess($gctx);
  # look at everything
  @lookat_low = sort keys %{$gctx->{'projpacks'}};
  push @lookat_low, @{$gctx->{'prps'}};
}

# bring dods in sync with projpacks
if ($BSConfig::enable_download_on_demand) {
  BSSched::DoD::init_doddata($gctx);
} else {
  my $dodsdir = $gctx->{'dodsdir'};
  BSUtil::cleandir($dodsdir) if -d $dodsdir;
}

BSSched::BuildJob::init_ourjobs($gctx);

unlink("$_rundir/bs_sched.$_myarch.dead");	# alive and kicking

#XXX
#@lookat_low = sort keys %$projpacks;
#push @lookat_low, @prps;

my %remotewatchers;

my %prpchecktimes;
my %prplastcheck;
my %prpunfinished;

if (@lookat_low) {
  %lookat_next = map {$_ => 1} @lookat_low;
  @lookat_low = ();
}

my $slept = 0;
my $notlow = 0;
my $notmed = 0;
my $schedulerstart = time();
my $gotevent = 1;
$gotevent = 0 if $testprojid;

my $lastschedinfo = 0;
my $initialstartup = 1;


##
## Here comes the big loop...
##

my $reporoot = $gctx->{'reporoot'};
my $myarch = $gctx->{'arch'};

eval {

  while(1) {
NEXTPRP:
    if (%changed_low || %changed_med || %changed_high) {
      changed2lookat($gctx, \%changed_low, \%changed_med, \%changed_high, \@lookat_high, \@lookat_med, \%lookat_next);
      next;
    }

    my $watchremote = $gctx->{'watchremote'};
    my $watchremote_start = $gctx->{'watchremote_start'};

    # delete no longer needed or outdated remotewatchers
    for my $remoteurl (sort keys %remotewatchers) {
      my $watcher = $remotewatchers{$remoteurl};
      if (!$watchremote->{$remoteurl} || join("\0", sort keys %{$watchremote->{$remoteurl}}) ne $watcher->{'watchlist'}) {
	close $watcher->{'socket'} if defined $watcher->{'socket'};
	delete $remotewatchers{$remoteurl};
	next;
      }
    }

    # create watchers
    for my $remoteurl (sort keys %$watchremote) {
      if (!$remotewatchers{$remoteurl}) {
	my $watcher = BSSched::Remote::setupremotewatcher($gctx, $remoteurl, $watchremote->{$remoteurl}, $watchremote_start->{$remoteurl});
	$watcher->{'watchlist'} = join("\0", sort keys %{$watchremote->{$remoteurl}});
	$remotewatchers{$remoteurl} = $watcher;
      }
    }

    # collect events to process
    my @events;

    my $pingwatcher = {
      'socket' => \*PING,
      'remoteurl' => 'ping',
    };

    # add retry events
    if (@{$gctx->{'retryevents'}}) {
      my @due = getretryevents($gctx);
      if (@due) {
	print "retrying ".@due." events\n";
	push @events, @due;
      }
    }

    # add events from watchers, also process finished xrpc calls
    if ($testprojid) {
      print "ignoring events due to test mode\n";
    } else {
      my @watchers = (values(%remotewatchers), $gctx->{'rctx'}->xrpc_handles());
      if (@watchers) {
        @watchers = select_read(0, $pingwatcher, @watchers);
	for my $watcher (@watchers) {
	  my $remoteurl = $watcher->{'remoteurl'};
	  if (!defined($remoteurl)) {
	    $gctx->{'rctx'}->xrpc_resume($watcher);
	  } elsif ($remoteurl eq 'ping') {
            $gotevent = 1;
	  } elsif ($watcher->{'retry'}) {
	    print "retrying watcher for $remoteurl\n";
	    delete $remotewatchers{$remoteurl};
	  } else {
	    push @events, BSSched::Remote::getremoteevents($gctx, $watcher, $watchremote->{$remoteurl}, $watchremote_start);
	    delete $remotewatchers{$remoteurl} unless $watcher->{'retry'};
	  }
	}
      } else {
	my $dummy;
        $gotevent = 1 if (sysread(PING, $dummy, 1, 0) || 0) > 0;
      }
    }

    # add events from the event directory
    if ($gotevent) {
      $gotevent = 0;
      # drain ping pipe
      my $dummy;
      1 while (sysread(PING, $dummy, 1024, 0) || 0) > 0;

      # check eventdir for new events
      for my $evfilename (sort(ls($_myeventdir))) {
	next if $evfilename =~ /^\./;
	my $ev;
	if ($evfilename =~ /^finished:(.*)/) {
	  $ev = {'type' => 'built', 'job' => $1};
	} else {
	  $ev = readxml("$_myeventdir/$evfilename", $BSXML::event, 1);
	  if (!$ev) {
	    print "$evfilename: bad xml\n";
	    unlink("$_myeventdir/$evfilename");
	    next;
	  }
	}
	$ev->{'type'} ||= 'unknown';
	$ev->{'evfilename'} = "$_myeventdir/$evfilename";
	push @events, $ev;
      }
    }

    # process all collected events
    if (@events) {
      die if $testprojid;

      # create event processor
      my $ectx = BSSched::Events->new(
	'gctx' => $gctx,
	'initialstartup' => $initialstartup,
      );

      $notlow = $notmed = 0 if grep {$_->{'type'} eq 'admincheck'} @events;	# HACK

      eval {
        @events = $ectx->order(@events);
	$gotevent = 1 if $ectx->process_events(@events);
      };
      if ($@) {
        warn($@);
        BSSched::Events::event_exit($ectx, {'type' => 'emergencydump'});
        exit(1);
      }

      # add all changed_high entries to changed_med to make things simpler
      for (keys %changed_high) {
	next if $changed_med{$_} && $changed_med{$_} == 2;
	$changed_med{$_} = $changed_high{$_};
      }
      next;
    }

    # done with first time event processing
    $initialstartup = undef;

    # mark all indirect affected repos dirty
    for my $prp (keys %changed_dirty) {
      my $reporoot = $gctx->{'reporoot'};
      next if ! -d "$reporoot/$prp/$myarch";
      next if   -e "$reporoot/$prp/$myarch/:schedulerstate.dirty";
      BSUtil::touch("$reporoot/$prp/$myarch/:schedulerstate.dirty");
    }
    %changed_dirty = ();

    my @ltim = localtime(time);
    my $msgtm = sprintf "%04d-%02d-%02d %02d:%02d:%02d:", $ltim[5] + 1900, $ltim[4] + 1, @ltim[3,2,1,0];

    sub check_queue {
      my ($lookat, $nextmed) = @_;
      my $prp = shift @$lookat;

      if ($nextmed && $nextmed->{$prp}) {
	my $now = time();
	my @notyet;
	while ($nextmed->{$prp} && $now < $nextmed->{$prp}) {
	  print "  not yet $prp\n";
	  push @notyet, $prp;
	  $prp = shift @$lookat;
	  last unless defined $prp;
	}
	unshift @$lookat, @notyet;
      }
      return $prp;
    }

    # if lookat_low array is empty, start new series with lookat_next
    if (!@lookat_low && %lookat_next) {
      @lookat_low = grep {$lookat_next{$_}} @{$gctx->{'prps'}};
      %lookat_next = ();
    }

    my $prp;
    my $lookattype;
    while (1) {
      $lookattype = 'low',  last if @lookat_low && $notlow > 10 && defined($prp = check_queue(\@lookat_low));
      $notlow = 0 if $notlow > 10;	# don't try so often
      $lookattype = 'med',  last if @lookat_med && $notmed > 2  && defined($prp = check_queue(\@lookat_med,  \%nextmed));
      $notmed = 0 if $notmed > 2;	# don't try so often
      $lookattype = 'high', last if @lookat_high                && defined($prp = check_queue(\@lookat_high, \%nextmed));
      $lookattype = 'med',  last if @lookat_med                 && defined($prp = check_queue(\@lookat_med,  \%nextmed));
      $lookattype = 'low',  last if @lookat_low                 && defined($prp = check_queue(\@lookat_low));
      $lookattype = 'high', last if @lookat_high                && defined($prp = check_queue(\@lookat_high));
      $lookattype = 'med',  last if @lookat_med                 && defined($prp = check_queue(\@lookat_med));
      last;
    }

    # postpone if we got source change RPCs running
    if (defined($prp)) {
      my ($projid) = split('/', $prp, 2);
      if ($gctx->{'rctx'}->xrpc_busy($projid)) {
	my $ctx = {'changeprp' => $prp, 'changetype' => $lookattype, 'gctx' => $gctx};
	$gctx->{'rctx'}->xrpc_addwakeup($ctx, $projid);
	next;
      }
    }

    $gctx->{'rctx'}->xrpc_printstats();

    if (!defined($prp)) {
      # nothing to do. good night, sleep tight...
      if ($testmode && !$gctx->{'rctx'}->xrpc_busy()) {
	print "Test mode, all sources and events processed, exiting...\n";
        BSSched::Events::event_exit({ 'gctx' => $gctx }, { 'type' => 'exitcomplete' });
      }
      my @ltim = localtime(time);
      my $msgtm = sprintf "%04d-%02d-%02d %02d:%02d:%02d:", $ltim[5] + 1900, $ltim[4] + 1, @ltim[3,2,1,0];
      print "$msgtm waiting for an event...\n";
      exit 0 if $testprojid;
      my $sleepstart = time();
      my @watchers = (values(%remotewatchers), @{$gctx->{'retryevents'}}, $gctx->{'rctx'}->xrpc_handles());
      select_read(undef, $pingwatcher, @watchers);
      $slept += time() - $sleepstart;
      next;
    }

    $notmed++;
    $notlow++;
    if ($lookattype eq 'low') {
      @lookat_high = grep {$_ ne $prp} @lookat_high;
      @lookat_med = grep {$_ ne $prp} @lookat_med;
      $notlow = 0;
    } elsif ($lookattype eq 'med') {
      @lookat_high = grep {$_ ne $prp} @lookat_high;
      $notmed = 0;
    } else {
      @lookat_med = grep {$_ ne $prp} @lookat_med;
    }
    print "$msgtm looking at $lookattype prio $prp";
    print " (".@lookat_high."/".@lookat_med."/".@lookat_low."/".(keys %lookat_next)."/".@{$gctx->{'prps'}}.")\n";
    delete $nextmed{$prp};

    my ($projid, $repoid) = split('/', $prp, 2);
    next if $testprojid && $projid ne $testprojid;

    if (!defined($repoid)) {
      # project maintenance, check for deleted repositories
      my $projpacks = $gctx->{'projpacks'};
      my %repoids;
      for my $repo (@{($projpacks->{$projid} || {})->{'repository'} || []}) {
	$repoids{$repo->{'name'}} = 1 if grep {$_ eq $myarch} @{$repo->{'arch'} || []};
      }
      for my $repoid (ls("$reporoot/$projid")) {
	next if $repoid eq ':all';	# XXX
	next if $repoids{$repoid};
	my $prp = "$projid/$repoid";
	next if -l "$reporoot/$prp";	# XXX
	my $gdst = "$reporoot/$prp/$myarch";
	next unless -d $gdst;
	# we no longer build this repoid
	print "  - deleting repository $prp\n";
	delete $gctx->{'prpfinished'}->{$prp};
	delete $gctx->{'prpnotready'}->{$prp};
	delete $prpunfinished{$prp};
	delete $prpchecktimes{$prp};
	delete $gctx->{'repodatas'}->{$prp};
	delete $lastcheck{$prp};
	delete $gctx->{'prpcheckuseforbuild'}->{$prp};
	for my $dir (ls($gdst)) {
	  # need lock for deleting publish area
	  next if $dir eq ':repo' || $dir eq ':repoinfo';
	  if (-d "$gdst/$dir") {
	    BSUtil::cleandir("$gdst/$dir");
	    rmdir("$gdst/$dir") || die("$gdst/$dir: $!\n");
	  } else {
	    unlink("$gdst/$dir") || die("$gdst/$dir: $!\n");
	  }
	}
	$changed_med{$prp} = 2;
	sendrepochangeevent($gctx, $prp);
	BSSched::BuildJob::killbuilding($gctx, $prp);
	my $ctx = {'gctx' => $gctx, 'prp' => $prp, 'gdst' => $gdst };
	BSSched::PublishRepo::prpfinished($ctx);
	# now that :repo is gone we can remove the directory
	while (!rmdir($gdst)) {
	  die("$gdst: $!\n") unless -e "$gdst/:schedulerstate.dirty";
	  print "rep server created dirty file $gdst/:schedulerstate.dirty, retry ...\n";
	  unlink("$gdst/:schedulerstate.dirty");
	}
	# XXX this should be rewritten if :repoinfo lives somewhere else
	my $repo = (grep {$_->{'name'} eq $repoid} @{($projpacks->{$projid} || {})->{'repository'} || []})[0];
	if (!$repo) {
	  # this repo doesn't exist any longer!
	  my $others;
	  for (ls("$reporoot/$prp")) {
	    next unless -d $_;
	    $others = 1;
	  }
	  if (!$others) {
	    # cannot delete repoinfo because it maz contain splitdbg data
	    # unlink("$reporoot/$prp/:repoinfo");
	    unlink("$reporoot/$prp/.finishedlock");
	    rmdir("$reporoot/$prp");
	  }
	}
      }
      rmdir("$reporoot/$projid");		# in case this was the last repo
      next;
    }

    # do delayed projpack fetches
    while ($delayedfetchprojpacks{$projid}) {
      my $async;
      $async = {'_changeprp' => $prp, '_changetype' => $lookattype} if $asyncmode;
      my $delayed = delete $delayedfetchprojpacks{$projid};
      if ($delayed) {
	if (!BSSched::ProjPacks::do_delayedprojpackfetches($gctx, $async, $projid, @$delayed)) {
	  # async request in progress...
          goto NEXTPRP;
	}
      }
    }

    my $projpacks = $gctx->{'projpacks'};
    my $prpsearchpath = $gctx->{'prpsearchpath'}->{$prp};

    if (!$projpacks->{$projid} || !$prpsearchpath) {
      next if $gctx->{'remoteprojs'}->{$projid};
      print "  - $prp: no longer exists\n";
      next;
    }

    # merge bininfo
    if (-e "$reporoot/$prp/$myarch/:bininfo.merge" || ! -e "$reporoot/$prp/$myarch/:bininfo") {
      BSSched::BuildResult::read_gbininfo("$reporoot/$prp/$myarch");
      my $repounchanged = $gctx->{'repounchanged'};
      $repounchanged->{$prp} = 2 if $repounchanged->{$prp};
    }

    # merge relsync
    if (-e "$reporoot/$prp/$myarch/:relsync.merge") {
      print "    merging relsync data\n";
      my $relsync_merge = BSUtil::retrieve("$reporoot/$prp/$myarch/:relsync.merge", 2);
      if ($relsync_merge) {
	my $relsync;
	$relsync = BSUtil::retrieve("$reporoot/$prp/$myarch/:relsync", 2) if -e "$reporoot/$prp/$myarch/:relsync";
	$relsync = { %{$relsync || {}}, %$relsync_merge };
	BSUtil::store("$reporoot/$prp/$myarch/.:relsync", "$reporoot/$prp/$myarch/:relsync", $relsync);
      }
      unlink("$reporoot/$prp/$myarch/:relsync.merge");
    }

    # merge metacache
    if (-e "$reporoot/$prp/$myarch/:full.metacache.merge") {
      print "    merging metacache data\n";
      my $metacache_merge = BSUtil::retrieve("$reporoot/$prp/$myarch/:full.metacache.merge", 2);
      if ($metacache_merge) {
	my $metacache;
	$metacache = BSUtil::retrieve("$reporoot/$prp/$myarch/:full.metacache", 2) if -e "$reporoot/$prp/$myarch/:full.metacache";
	$metacache = { %{$metacache || {}}, %$metacache_merge };
	delete $metacache->{$_} for grep {!defined($metacache_merge->{$_})} keys %$metacache_merge;
	if (%$metacache) {
	  BSUtil::store("$reporoot/$prp/$myarch/.:full.metacache", "$reporoot/$prp/$myarch/:full.metacache", $metacache);
	} else {
	  unlink("$reporoot/$prp/$myarch/:full.metacache");
	}
      }
      unlink("$reporoot/$prp/$myarch/:full.metacache.merge");
    }

    my $bconf = getconfig($gctx, $myarch, $prpsearchpath);
    if (!$bconf) {
      # see if it is caused by a remote error
      my $error;
      my $remoteprojs = $gctx->{'remoteprojs'};
      for my $pprp (@$prpsearchpath) {
	my ($pprojid, $prepoid) = split('/', $pprp, 2);
	$error = $remoteprojs->{$pprojid}->{'error'} if $remoteprojs->{$pprojid} && $remoteprojs->{$pprojid}->{'error'};
	if ($error) {
	  if ($error =~ /interconnect error:/) {
	    addretryevent($gctx, {'type' => 'project', 'project' => $pprojid});
	  }
	  print "  - $prp: $pprojid: $error\n";
	  last;
	}
      }
      next if $error;
      my $lastprojid = (split('/', $prpsearchpath->[-1]))[0];
      print "  - $prp: no config ($lastprojid)\n";
      set_repo_state($gctx, $prp, 'broken', "no config ($lastprojid)");
      $gctx->{'prpfinished'}->{$prp} = 1;
      next;
    }

    my $prptype = $bconf->{'type'};
    if (!$prptype || $prptype eq 'UNDEFINED') {
      # HACK force to channel if we have a channel package
      $prptype = 'channel' if grep {$_->{'channel'}} values(%{$projpacks->{$projid}->{'package'} || {}});
    }
    if (!$prptype || $prptype eq 'UNDEFINED') {
      # could still do channels/aggregates/patchinfos
      my $lastprojid = (split('/', $prpsearchpath->[-1]))[0];
      print "  - $prp: bad config ($lastprojid)\n";
      set_repo_state($gctx, $prp, 'broken', "bad config ($lastprojid)");
      $gctx->{'prpfinished'}->{$prp} = 1;
      next;
    }
    if ($bconf->{'hostarch'} && !$BSCando::knownarch{$bconf->{'hostarch'}}) {
      print "  - $prp: bad hostarch ($bconf->{'hostarch'})\n";
      set_repo_state($gctx, $prp, 'broken', "bad hostarch ($bconf->{'hostarch'})");
      $gctx->{'prpfinished'}->{$prp} = 1;
      next;
    }
    my $repo = (grep {$_->{'name'} eq $repoid} @{$projpacks->{$projid}->{'repository'} || []})[0];
    if (!$repo) {
      print " - $prp: no repo?\n";
      set_repo_state($gctx, $prp, 'broken', 'no repo');
      $gctx->{'prpfinished'}->{$prp} = 1;
      next;
    }

    print "  - $prp\n";

    if ($gctx->{'prpcheckuseforbuild'}->{$prp}) {
      my $packs = $projpacks->{$projid}->{'package'} || {};
      # the if statement below is to ease transition to the new full handling
      # for manually created "base" repos
      if (!$BSSched::BuildResult::new_full_handling || %$packs || ! -d "$reporoot/$prp/$myarch/:full" ||
          -e "$reporoot/$prp/$myarch/:full.useforbuild") {
        BSSched::BuildRepo::checkuseforbuild($gctx, $prp, $prpsearchpath, undef);
        delete $gctx->{'prpcheckuseforbuild'}->{$prp};
      }
    }
    if (!$lastcheck{$prp}) {
      my $oldlastcheck = BSUtil::retrieve("$reporoot/$prp/$myarch/:lastcheck", 1) || {};
      my $packs = $projpacks->{$projid}->{'package'} || {};
      for (keys %$oldlastcheck) {
	# delete old cruft
	delete $oldlastcheck->{$_} unless $packs->{$_};
      }
      $lastcheck{$prp} = $oldlastcheck;
    }
    my $ctx = { 'project' => $projid, 'repository' => $repoid, 'prp' => $prp,
		'repo' => $repo, 'gctx' => $gctx,
		'changetype' => $lookattype, 'changeprp' => $prp, 
		'prpsearchpath' => $prpsearchpath || [], 'conf' => $bconf,
		'lastcheck' => $lastcheck{$prp}, 'gdst' => "$gctx->{'reporoot'}/$prp/$myarch"};

    if ($repo->{'status'} && $repo->{'status'} eq 'disabled') {
      print "      disabled\n";
      set_repo_state($gctx, $prp, 'disabled');
      $gctx->{'prpfinished'}->{$prp} = 1;
      next;
    }

    mkdir_p("$reporoot/$prp/$myarch");
    set_repo_state($gctx, $prp, 'scheduling');

    my $packs = $projpacks->{$projid}->{'package'} || {};
    my @packs = sort keys %$packs;

    # XXX: setup packid2info hash?

    # Step 2a: check if packages got deleted/excluded
    for my $packid (grep {!/^[:\.]/} ls("$reporoot/$prp/$myarch")) {
      next if $packid eq '_volatile';
      my $reason;
      if (!$packs->{$packid}) {
	next if $packid eq '_deltas';
	next if $projpacks->{$projid}->{'missingpackages'};
	$reason = 'obsolete';
      } else {
	my $pdata = $packs->{$packid};
	if (($pdata->{'error'} || '') eq 'excluded') {
	  $reason = 'excluded';
	} else {
	  my %info = map {$_->{'repository'} => $_} @{$pdata->{'info'} || []};
	  my $info = $info{$repoid};
	  next unless $info && ($info->{'error'} || '') eq 'excluded';
	  $reason = 'excluded';
	}
      }
      my $gdst = "$reporoot/$prp/$myarch";
      my @files = ls("$gdst/$packid");
      my @ifiles = grep {/^::import::/ || /^\.meta\.success\.import\./} @files;
      if (@ifiles) {
	# only imported stuff?
        next unless grep {$_ ne '.bininfo' && !(/^::import::/ || /^\.meta\.success\.import\./)} @files;
      }
      print "      - $packid: is $reason\n";
      delete $lastcheck{$prp}->{$packid};
      # delete full entries
      my $useforbuildenabled = 1;
      $useforbuildenabled = BSUtil::enabled($repoid, $projpacks->{$projid}->{'useforbuild'}, $useforbuildenabled, $myarch);
      # hmm, need to exclude patchinfos here. cheating.
      $useforbuildenabled = 0 if -s "$gdst/$packid/.updateinfodata";
      # don't wipe imports if we're excluded
      my $importarch = $packs->{$packid} && @ifiles ? '' : undef;
      BSSched::BuildResult::update_dst_full($gctx, $prp, $packid, undef, undef, $useforbuildenabled, $prpsearchpath, undef, $importarch);
      $changed_med{$prp} = 2;
      sendrepochangeevent($gctx, $prp);
      # delete other files
      unlink("$gdst/:logfiles.success/$packid");
      unlink("$gdst/:logfiles.fail/$packid");
      unlink("$gdst/:meta/$packid");
      if (@ifiles) {
        for (@files) {
	  next if $_ eq '.bininfo';
	  next if /^::import::/ || /^\.meta\.success\.import\./;
          unlink("$gdst/$packid/$_");
	}
      } else {
        BSUtil::cleandir("$gdst/$packid");
      }
      rmdir("$gdst/$packid");
      BSSched::BuildJob::killbuilding($gctx, $prp, $packid);
      unlink("$reporoot/$prp/$myarch/:repodone");
    }


    # Step 2b: set up pool and repositories
    my $pool = BSSolv::pool->new();
    $pool->settype('deb') if $bconf->{'binarytype'} eq 'deb';
    $ctx->{'pool'} = $pool;

    my %building;
    my %dep2src;
    my %dep2pkg;
    my %depislocal;	# used in meta calculation
    my $error;
    my %unfinished;	# is blocked or needs rebuild
    my %notready;		# unfinished and will modify :full
    my $prpnotready = $gctx->{'prpnotready'};

    my $delayed;
    for my $rprp (@$prpsearchpath) {
      if (!checkprpaccess($gctx, $rprp, $prp)) {
	$error = "repository '$rprp' is unavailable";
	last;
      }
      my $r = addrepo($ctx, $pool, $rprp);
      if (!$r) {
	$delayed = 1 if defined $r;
	$error = "repository '$rprp' is unavailable";
	last;
      }
    }
    if ($error) {
      print "    $error\n";
      print "    (delayed)\n" if $delayed;
      $ctx->{'havedelayed'} = 1 if $delayed;
      set_repo_state($gctx, $prp, 'broken', $error) unless $delayed;
      next;
    }
    
    $pool->createwhatprovides();
    for my $p ($pool->consideredpackages()) {
      my $rprp = $pool->pkg2reponame($p);
      my $n = $pool->pkg2name($p);
      my $sn = $pool->pkg2srcname($p) || $n;
      $dep2pkg{$n} = $p;
      $dep2src{$n} = $sn;
      if ($rprp eq $prp) {
	$depislocal{$n} = 1;
      } else {
	$notready{$sn} = 2 if $prpnotready->{$rprp} && $prpnotready->{$rprp}->{$sn};
      }
    }
    $ctx->{'building'} = \%building;
    $ctx->{'notready'} = \%notready;
    $ctx->{'dep2pkg'} = \%dep2pkg;
    $ctx->{'dep2src'} = \%dep2src;
    $ctx->{'depislocal'} = \%depislocal;

    if ($repo->{'block'} && $repo->{'block'} eq 'local') {
      for (keys %notready) {
	delete $notready{$_} if $notready{$_} == 2;
      }
    }

    my $xp = BSSolv::expander->new($pool, $bconf);
    no warnings 'redefine';
    local *Build::expand = sub { $_[0] = $xp; goto &BSSolv::expander::expand; };
    use warnings 'redefine';

    my $prpchecktime = time();

    if ($bconf->{'expandflags:preinstallexpand'}) {
      my $err;
      if (!defined &Build::expandpreinstalls($bconf)) {
	$err = "Build::expandpreinstalls does not exist";
      } else {
	$err = Build::expandpreinstalls($bconf);
	$err = "unresolvable $err" if $err;
      }
      if ($err) {
        print "    $err\n";
        set_repo_state($gctx, $prp, 'broken', $err);
        next;
      }
    }
    # Step 2c: expand all dependencies, put them in %pdeps hash
    my %subpacks;
    push @{$subpacks{$dep2src{$_}}}, $_ for keys %dep2src;
    print "    expanding dependencies\n";
    my %experrors;
    $ctx->{'subpacks'} = \%subpacks;

    my %pdeps;
    my %pkg2src;
    my %pkgdisabled;
    my %havepatchinfos;
    my %pkg2buildtype;
    for my $packid (@packs) {
      my $pdata = $packs->{$packid};

      if ($pdata->{'error'} && $pdata->{'error'} eq 'excluded') {
	$pdeps{$packid} = [];
	next;
      }

      my $info = (grep {$_->{'repository'} eq $repoid} @{$pdata->{'info'} || []})[0];

      # calculate package type
      my $buildtype;
      if ($pdata->{'aggregatelist'}) {
	$buildtype = 'aggregate';
      } elsif ($pdata->{'patchinfo'}) {
	$buildtype = 'patchinfo';
      } elsif ($pdata->{'channel'}) {
	$buildtype = 'channel';
      } elsif ($info && $info->{'file'}) {
        # directly implement most common types
	if ($info->{'file'} =~ /\.(spec|dsc|kiwi|livebuild)$/) {
	  $buildtype = $1;
	  if ($buildtype eq 'kiwi') {
	    $buildtype = $info->{'imagetype'} && $info->{'imagetype'}->[0] eq 'product' ? 'kiwi-product' : 'kiwi-image';
	  }
	} else {
	  $buildtype = Build::recipe2buildtype($info->{'file'}) || 'unknown';
	}
      } else {
        $buildtype = 'unknown';
      }
      $pkg2buildtype{$packid} = $buildtype;
      $havepatchinfos{$packid} = 1 if $buildtype eq 'patchinfo';

      if (!$info || !defined($info->{'file'}) || !defined($info->{'name'})) {
	if ($pdata->{'error'} && $pdata->{'error'} eq 'disabled') {
	  $pkgdisabled{$packid} = 1;
	}
	if ($info && $info->{'error'} && $info->{'error'} eq 'disabled') {
	  $pkgdisabled{$packid} = 1;
	}
	$pdeps{$packid} = [];
	next;
      }
      if ($info->{'error'} && $info->{'error'} eq 'excluded') {
	$pdeps{$packid} = [];
	next;
      }
      if (exists($pdata->{'originproject'})) {
	# this is a package from a project link
	if (!$repo->{'linkedbuild'} || ($repo->{'linkedbuild'} ne 'localdep' && $repo->{'linkedbuild'} ne 'all')) {
	  $pdeps{$packid} = [];
	  next;
	}
      }
      $pkg2src{$packid} = $info->{'name'};

      if ($pdata->{'hasbuildenv'}) {
        $pdeps{$packid} = [];
        next;
      }
      my @deps = @{$info->{'dep'} || []};
      my $handler = $handlers{$buildtype} || $defaulthandler;
      my ($eok, @edeps) = $handler->{'expand'}->($bconf, $subpacks{$info->{'name'}}, @deps);
      if (!$eok) {
	$experrors{$packid} = join(', ', @edeps) || '?';
	@edeps = @deps;
      }
      $pdeps{$packid} = \@edeps;
    }
    $ctx->{'edeps'} = \%pdeps;

    # sort packages by pdeps
    print "    sorting ".@packs." packages\n";
    my @cycles;
    @packs = sortpacks(\%pdeps, \%dep2src, \@cycles, @packs);
    if (%havepatchinfos) {
      # bring patchinfos to back
      my @packs_patchinfos = grep {$havepatchinfos{$_}} @packs;
      @packs = grep {!$havepatchinfos{$_}} @packs;
      push @packs, @packs_patchinfos;
    }

    # write dependency information
    if (%pkgdisabled) {
      # leave info of disabled packages untouched
      my $olddepends = BSUtil::retrieve("$reporoot/$prp/$myarch/:depends", 1);
      if ($olddepends) {
	for (keys %pkgdisabled) {
	  $pdeps{$_} = $olddepends->{'pkgdeps'}->{$_} if $olddepends->{'pkgdeps'}->{$_};
	  $pkg2src{$_} = $olddepends->{'pkg2src'}->{$_} if $olddepends->{'pkg2src'}->{$_};
	}
      }
    }
    my %prunedsubpacks;
    for (values %pkg2src) {
      $prunedsubpacks{$_} = $subpacks{$_} if $subpacks{$_};
    }
    BSUtil::store("$reporoot/$prp/$myarch/.:depends", "$reporoot/$prp/$myarch/:depends", {
      'pkgdeps' => \%pdeps,
      'subpacks' => \%prunedsubpacks,
      'pkg2src' => \%pkg2src,
      'cycles' => \@cycles,
    });
    %prunedsubpacks = ();
    # remove old entries again
    for (keys %pkgdisabled) {
      $pdeps{$_} = [];
      delete $pkg2src{$_};
    }

    # now build cychash mapping packages to all other cycle members
    my %cychash;
    if (@cycles) {
      for my $cyc (@cycles) {
	my %nc = map {$_ => 1} @$cyc;
	for my $p (@$cyc) {
	  next unless $cychash{$p};
	  $nc{$_} = 1 for @{$cychash{$p}};
	}
	my $c = [ sort keys %nc ];
	$cychash{$_} = $c for @$c;
      }
    }

    my $projbuildenabled = 1;
    $projbuildenabled = BSUtil::enabled($repoid, $projpacks->{$projid}->{'build'}, 1, $myarch) if $projpacks->{$projid}->{'build'};
    my $projlocked = 0;
    $projlocked = BSUtil::enabled($repoid, $projpacks->{$projid}->{'lock'}, 0, $myarch) if $projpacks->{$projid}->{'lock'};

    # fetch relsync data
    my $relsyncmax;
    my %relsynctrigger;
    if (-s "$reporoot/$prp/$myarch/:relsync.max") {
      $relsyncmax = BSUtil::retrieve("$reporoot/$prp/$myarch/:relsync.max", 2);
      if ($relsyncmax && -s "$reporoot/$prp/$myarch/:relsync") {
	my $relsync = BSUtil::retrieve("$reporoot/$prp/$myarch/:relsync", 2);
	for my $packid (@packs) {
	  my $tag = $packs->{$packid}->{'bcntsynctag'} || $packid;
	  next unless $relsync->{$packid};
	  next unless $relsync->{$packid} =~ /(.*)\.(\d+)$/;
	  next unless defined($relsyncmax->{"$tag/$1"}) && $2 < $relsyncmax->{"$tag/$1"};
	  $relsynctrigger{$packid} = 1;
	}
      }
      if (%relsynctrigger) {
	# filter failed packages
	for (ls("$reporoot/$prp/$myarch/:logfiles.fail")) {
	  delete $relsynctrigger{$_};
	}
      }
    }
    $ctx->{'relsynctrigger'} = \%relsynctrigger;
    $ctx->{'relsyncmax'} = $relsyncmax;

    # Step 2d: check status of all packages
    my %packstatus;
    my $oldpackstatus;
    my %packerror;
    my @cpacks = @packs;
    my %cycpass;
    my $needed;
    $ctx->{'packstatus'} = \%packstatus;
    $ctx->{'cychash'} = \%cychash;
    $ctx->{'cycpass'} = \%cycpass;
    $ctx->{'nharder'} = 0;

    my $prjuseforbuildenabled = 1;
    $prjuseforbuildenabled = BSUtil::enabled($repoid, $projpacks->{$projid}->{'useforbuild'}, $prjuseforbuildenabled, $myarch);

    # copy old data over if we have missing packages
    if ($projpacks->{$projid}->{'missingpackages'}) {
      addretryevent($gctx, {'type' => 'package', 'project' => $projid});
      $oldpackstatus = BSUtil::retrieve("$reporoot/$prp/$myarch/:packstatus", 1) || {};
      $oldpackstatus->{'packstatus'} ||= {};
      $oldpackstatus->{'packerror'} ||= {};
      for my $packid (keys %{$oldpackstatus->{'packstatus'}}) {
	next if $packs->{$packid};
	$packstatus{$packid} = $oldpackstatus->{'packstatus'}->{$packid};
	$packerror{$packid} = $oldpackstatus->{'packerror'}->{$packid} if $oldpackstatus->{'packerror'}->{$packid}; 
      }
    }

    while (@cpacks) {
      my $packid = shift @cpacks;
      my $incycle = 0;
      if ($cychash{$packid}) {
	next if $packstatus{$packid} && $packstatus{$packid} ne 'done'; # already decided in phase 1
	# cycle package, we look at a cycle two times:
	# 1) just trigger package builds caused by source changes
	# 2) normal package build triggering
	# cychash contains all packages of this cycle

	# calculate phase 1 packages
	my @cnext = grep {!$cycpass{$_}} @{$cychash{$packid}};
	if (@cnext) {
	  # still phase1 packages left, do them first
	  unshift @cpacks, $packid;
	  $packid = shift @cnext;
	  $cycpass{$packid} = 1;	# now doinig phase 1
	  $incycle = 1;
	} elsif (($cycpass{$packid} || 0) < 2) {
	  # enter phase 2
	  $cycpass{$packid} = 2;	# just in case...
	  my $pass = 2;
	  # we are building packages because of source changes,
	  # set cycpass to 3 so that we don't start other builds
	  $pass = 3 if grep {$building{$_}} @{$cychash{$packid}};
	  $cycpass{$_} = $pass for @{$cychash{$packid}};
	}
      }
      $ctx->{'incycle'} = $incycle;

      # product definitions are never building themself
      if ($packid eq '_product') {
	$packstatus{$packid} = 'excluded';
	next;
      }

      my $pdata = $packs->{$packid};
      if ($pdata->{'lock'}) {
	if (BSUtil::enabled($repoid, $pdata->{'lock'}, $projlocked, $myarch)) {
	  $packstatus{$packid} = 'locked';
	  next;
	}
      } else {
	if ($projlocked) {
	  $packstatus{$packid} = 'locked';
	  next;
	}
      }

      if ($pdata->{'error'}) {
	if ($pdata->{'error'} eq 'disabled' || $pdata->{'error'} eq 'excluded') {
	  $packstatus{$packid} = $pdata->{'error'};
	  next;
	}
	print "      - $packid ($pdata->{'error'})\n";
	if ($pdata->{'error'} =~ /download in progress/) {
	  $packstatus{$packid} = 'blocked';
	  $packerror{$packid} = $pdata->{'error'};
	  next;
	}
	if ($pdata->{'error'} =~ /source update running/ || $pdata->{'error'} =~ /service in progress/) {
	  $packstatus{$packid} = 'blocked';
	  $packerror{$packid} = $pdata->{'error'};
	  next;
	}
	if ($pdata->{'error'} eq 'delayed startup' || $pdata->{'error'} =~ /interconnect error:/) {
	  addretryevent($gctx, {'type' => 'package', 'project' => $projid, 'package' => $packid});
	  $ctx->{'havedelayed'} = 1;
	  $packstatus{$packid} = 'blocked';
	  $packerror{$packid} = $pdata->{'error'};
	  next;
	}
	$packstatus{$packid} = 'broken';
	$packerror{$packid} = $pdata->{'error'};
	next;
      }

      if (exists($pdata->{'originproject'})) {
	# this is a package from a project link
	if (!$repo->{'linkedbuild'} || ($repo->{'linkedbuild'} ne 'localdep' && $repo->{'linkedbuild'} ne 'all')) {
	  $packstatus{$packid} = 'excluded';
	  $packerror{$packid} = 'project link';
	  next;
	}
      }

      if ($pdata->{'build'}) {
	if (!BSUtil::enabled($repoid, $pdata->{'build'}, $projbuildenabled, $myarch)) {
	  $packstatus{$packid} = 'disabled';
	  next;
	}
      } else {
	if (!$projbuildenabled) {
	  $packstatus{$packid} = 'disabled';
	  next;
	}
      }

      # select correct info again
      my $info = (grep {$_->{'repository'} eq $repoid} @{$pdata->{'info'} || []})[0] || {};

      # name of src package, needed for block detection
      my $pname = $info->{'name'} || $packid;

      if ($info->{'error'}) {
	if ($info->{'error'} eq 'disabled' || $info->{'error'} eq 'excluded') {
	  $packstatus{$packid} = $info->{'error'};
	  next;
	}
	print "      - $packid ($info->{'error'})\n";
	$packstatus{$packid} = 'broken';
	$packerror{$packid} = $info->{'error'};
	next;
      }

      # calculate package build type
      my $buildtype = $pkg2buildtype{$packid} || 'unknown';
      if ($buildtype eq 'unknown') {
	print "      - $packid (no recipe file)\n";
	$packstatus{$packid} = 'broken';
	$packerror{$packid} = 'no recipe file';
	next;
      }
      my $handler = $handlers{$buildtype} || $defaulthandler;
      #print "      - $packid ($buildtype)\n";

      if (!$incycle) {
	# hmm, this might be a bad idea...
	my $job = BSSched::BuildJob::jobname($prp, $packid)."-$pdata->{'srcmd5'}";
	my $myjobsdir = $gctx->{'myjobsdir'};
	if (-s "$myjobsdir/$job") {
	  # print "      - $packid ($buildtype)\n";
	  # print "        already scheduled\n";
	  BSSched::BuildJob::add_crossmarker($gctx, $bconf->{'hostarch'}, $job) if $bconf->{'hostarch'};
	  my $useforbuildenabled = BSUtil::enabled($repoid, $pdata->{'useforbuild'}, $prjuseforbuildenabled, $myarch);
	  $building{$packid} = $job;
	  $notready{$pname} = 1 if $useforbuildenabled;
	  $unfinished{$pname} = 1;
	  $packstatus{$packid} = 'scheduled';
	  next;
	}
      }

      # now print expandsion errors
      if ($experrors{$packid}) {
	print "      - $packid ($buildtype)\n";
	print "        unresolvable:\n";
	print "            $experrors{$packid}\n";
	$packstatus{$packid} = 'unresolvable';
	$packerror{$packid} = $experrors{$packid};
	next;
      }

      # dispatch to handlers
      my ($astatus, $aerror) = $handler->{'check'}->($ctx, $packid, $pdata, $info, $buildtype);
      if ($astatus eq 'scheduled') {
	# aerror contains rebuild data in this case
	($astatus, $aerror) = $handler->{'rebuild'}->($ctx, $packid, $pdata, $info, $aerror);
	if ($astatus eq 'scheduled') {
	  $building{$packid} = $aerror || 'job'; # aerror contains jobid in this case
	  undef $aerror;
	} elsif ($astatus eq 'delayed') {
          $ctx->{'havedelayed'} = 1;
	  ($astatus, $aerror) = ('blocked', defined($aerror) ? "delayed: $aerror" : 'delayed');
	}
	unlink("$reporoot/$prp/$myarch/:repodone");
      } elsif ($astatus eq 'delayed') {
        $ctx->{'havedelayed'} = 1;
	if (!$oldpackstatus) {
	  $oldpackstatus = BSUtil::retrieve("$reporoot/$prp/$myarch/:packstatus", 1) || {};
	  $oldpackstatus->{'packstatus'} ||= {};
	  $oldpackstatus->{'packerror'} ||= {};
	}
	$astatus = $oldpackstatus->{'packstatus'}->{$packid};
	$aerror = $oldpackstatus->{'packerror'}->{$packid};
	($astatus, $aerror) = ('blocked', 'delayed') unless $astatus;
	$unfinished{$pname} = 1;
      }
      $packstatus{$packid} = $astatus;
      $packerror{$packid} = $aerror if defined $aerror;
      if ($astatus eq 'blocked' || $astatus eq 'scheduled') {
	my $useforbuildenabled = BSUtil::enabled($repoid, $pdata->{'useforbuild'}, $prjuseforbuildenabled, $myarch);
	$notready{$pname} = 1 if $useforbuildenabled;
	$unfinished{$pname} = 1;
      }
    }

    # delete global entries from notready
    for (keys %notready) {
      delete $notready{$_} if $notready{$_} == 2;
    }
    # put local notready into prpnotready if not a leaf
    if (%notready && $gctx->{'prpnoleaf'}->{$prp}) {
      $prpnotready->{$prp} = \%notready;
    } else {
      delete $prpnotready->{$prp};
    }

    # write blocked data into a file so that remote servers can fetch it
    # we don't put it into :packstatus to make retrival fast
    if (%notready) {
      my @blocked = sort keys %notready;
      writexml("$reporoot/$prp/$myarch/.:repostate", "$reporoot/$prp/$myarch/:repostate", {'blocked' => \@blocked}, $BSXML::repositorystate);
    } else {
      unlink("$reporoot/$prp/$myarch/:repostate");
    }

    # building jobs may have changed back to excluded, blocked or disabled, remove the jobs
    BSSched::BuildJob::killunwantedjobs($ctx->{'gctx'}, $prp, \%packstatus);

    # notify remote build services of repository changes or block state
    # changes
    # we alse send it if we finish a prp to give linked aggregates a
    # chance to work
    my $repounchanged = $gctx->{'repounchanged'};
    if (!$repounchanged->{$prp} || (!%unfinished && !$gctx->{'prpfinished'}->{$prp})) {
      sendrepochangeevent($gctx, $prp);
      $repounchanged->{$prp} = 1;
    } elsif ($repounchanged->{$prp} == 2) {
      sendrepochangeevent($gctx, $prp, 'repoinfo');
      $repounchanged->{$prp} = 1;
    }

    # free memory
    Build::forgetdeps($bconf);

    # write package status for this project
    BSUtil::store("$reporoot/$prp/$myarch/.:packstatus", "$reporoot/$prp/$myarch/:packstatus", {
      'packstatus' => \%packstatus,
      'packerror' => \%packerror,
    });
    unlink("$reporoot/$prp/$myarch/:packstatus.finished");

    $prpchecktime = time() - $prpchecktime;

    # write some stats
    for my $status (sort keys %{{map {$_ => 1} values %packstatus}}) {
      print "    $status: ".scalar(grep {$_ eq $status} values %packstatus)."\n";
    }
    print "    looked harder: $ctx->{'nharder'}\n" if $ctx->{'nharder'};
    print "    building: ".scalar(keys %building).", notready: ".scalar(keys %notready).", unfinished: ".scalar(keys %unfinished)."\n";
    print "    took $prpchecktime seconds to check the packages\n";

    # trigger dod package fetching
    if ($BSConfig::enable_download_on_demand) {
      BSSched::DoD::dodfetch($ctx) if $ctx->{'doddownloads'};
    }

    my $schedulerstate;
    my $schedulerdetails;
    if (keys %building) {
      $schedulerstate = 'building';
    } elsif ($ctx->{'havedelayed'} || keys %unfinished) {
      $schedulerstate = 'blocked';
    } else {
      $schedulerstate = 'finished';
    }

    # we always publish kiwi...
    if ((!%unfinished && !$ctx->{'havedelayed'}) || $prptype eq 'kiwi') {
      my $locked = 0;
      $locked = BSUtil::enabled($repoid, $projpacks->{$projid}->{'lock'}, $locked, $myarch) if $projpacks->{$projid}->{'lock'};
      my $pubenabled = BSUtil::enabled($repoid, $projpacks->{$projid}->{'publish'}, 1, $myarch);
      my %pubenabled;
      for my $packid (@packs) {
	my $pdata = $packs->{$packid};
        next if defined($pdata->{'lock'}) && BSUtil::enabled($repoid, $pdata->{'lock'}, $locked, $myarch);
        next if !defined($pdata->{'lock'}) && $locked;
	if ($pdata->{'publish'}) {
	  $pubenabled{$packid} = BSUtil::enabled($repoid, $pdata->{'publish'}, $pubenabled, $myarch);
	} else {
	  $pubenabled{$packid} = $pubenabled;
	}
      }
      my $repodonestate = $projpacks->{$projid}->{'patternmd5'} || '';
      for my $packid (@packs) {
	$repodonestate .= "\0$packid" if $pubenabled{$packid};
      }
      $repodonestate .= "\0$_" for sort keys %unfinished;
      $repodonestate = Digest::MD5::md5_hex($repodonestate);
      if (@packs && !grep {$_} values %pubenabled) {
	# all packages have publish disabled hint
	$repodonestate = "disabled:$repodonestate";
      }
      if (-e "$reporoot/$prp/$myarch/:repodone") {
	my $oldrepodone = readstr("$reporoot/$prp/$myarch/:repodone", 1) || '';
	unlink("$reporoot/$prp/$myarch/:repodone") if $oldrepodone ne $repodonestate;
      }
      my $publisherror;
      if ($locked) {
	print "    publishing is locked\n";
      } elsif (! -e "$reporoot/$prp/$myarch/:repodone") {
	if (($repodonestate !~ /^disabled/) || -d "$reporoot/$prp/$myarch/:repo") {
	  mkdir_p("$reporoot/$prp/$myarch");
	  $publisherror = BSSched::PublishRepo::prpfinished($ctx, \@packs, \%pubenabled);
	} else {
	  print "    publishing is disabled\n";
	}
	writestr("$reporoot/$prp/$myarch/:repodone", undef, $repodonestate) unless $publisherror || %unfinished;
        if ($publisherror) {
  	  $schedulerstate = "broken";
  	  $schedulerstate = "building" if $publisherror eq 'delta generation: building';
  	  $schedulerdetails = $publisherror;
        }
      }
      if (!%unfinished && !$publisherror) {
	$gctx->{'prpfinished'}->{$prp} = 1;
	# write out lastcheck cache and delete it
	if ($lastcheck{$prp} && %{$lastcheck{$prp}}) {
	  BSUtil::store("$reporoot/$prp/$myarch/.:lastcheck", "$reporoot/$prp/$myarch/:lastcheck", $lastcheck{$prp}) if $lastcheck{$prp};
	} else {
	  unlink("$reporoot/$prp/$myarch/:lastcheck");
	}
	delete $lastcheck{$prp};
	# delete pkg meta cache
	my $repodatas = $gctx->{'repodatas'};
	delete $repodatas->{$prp}->{'meta'} if $repodatas->{$prp};
	if (!$gctx->{'prpnoleaf'}->{$prp}) {
	  # only free repo data if all projects we depend on are finished, too.
	  # (we always have to do the expansion if something changes)
	  my @unfinishedprps;
	  my $remoteprojs = $gctx->{'remoteprojs'};
	  my $prpfinished = $gctx->{'prpfinished'};
	  for (@{$gctx->{'prpdeps'}->{$prp}}) {
	    next if $prpfinished->{$_};
	    # if this is a remote repo, check prpnotready
	    if (!%{$prpnotready->{$_} || {}}) {
	      my ($p) = split('/', $_, 2);
	      next if $remoteprojs->{$p};
	    }
	    push @unfinishedprps, $_;
	  }
	  if (!@unfinishedprps) {
	    print "    leaf prp, freeing data\n";
	    delete $repodatas->{$prp};
	  } else {
	    print "    leaf prp, unfinished prps: @unfinishedprps\n";
	  }
	}
      }
      # special handling for incidents, we need to guarantee that dirty flag of channel
      # are set in channel repos early enough or a release may be possible
      my $proj = $projpacks->{$projid} || {};
      if (($proj->{'kind'} || '') eq 'maintenance_incident') {
        my $prpfinished = $gctx->{'prpfinished'};
	for my $my_repo (@{$proj->{'repository'} ||[]}) {
          my $my_prp = "$projid/$my_repo->{'name'}";
	  next if $prpfinished->{$my_prp};
	  for (@{$gctx->{'prpdeps'}->{$my_prp}}) {
	    next if $prpfinished->{$_};
	    BSUtil::touch("$reporoot/$my_prp/$myarch/:schedulerstate.dirty") if -d "$reporoot/$my_prp/$myarch";
          }
        }
      }
    } else {
      delete $gctx->{'prpfinished'}->{$prp};
      unlink("$reporoot/$prp/$myarch/:repodone");
    }

    set_repo_state($gctx, $prp, $schedulerstate, $schedulerdetails);

    if (%unfinished) {
      $prpunfinished{$prp} = scalar(keys %unfinished);
    } else {
      delete $prpunfinished{$prp};
    }
    $prpchecktimes{$prp} = $prpchecktime;

    # send relsync file if something has been changed
    my @relsync1 = stat("$reporoot/$prp/$myarch/:relsync");
    my @relsync2 = stat("$reporoot/$prp/$myarch/:relsync.sent");
    if (@relsync1 && (!@relsync2 || "$relsync1[9]/$relsync1[7]/$relsync1[1]" ne "$relsync2[9]/$relsync2[7]/$relsync2[1]")) {
      print "    updating relsync information\n";
      my $relsync = BSUtil::retrieve("$reporoot/$prp/$myarch/:relsync") || {};
      my $relsyncmax = {};
      for my $packid (sort keys %$relsync) {
	next unless $relsync->{$packid} =~ /^(.*)\.([^-]*)$/;
	my $tag = ($packs->{$packid} || {})->{'bcntsynctag'} || $packid;
	next if defined($relsyncmax->{"$tag/$1"}) && $relsyncmax->{"$tag/$1"} >= $2;
	$relsyncmax->{"$tag/$1"} = $2;
      }
      updaterelsyncmax($gctx, $prp, $myarch, $relsyncmax, %unfinished ? 0 : 1);
      my $relsyncdata = BSUtil::tostorable($relsyncmax);
      # sent new data!
      my $param = {
	'uri' => "$BSConfig::srcserver/relsync",
	'request' => 'POST',
	'data' => $relsyncdata,
      };
      eval {
	BSRPC::rpc($param, undef, "project=$projid", "repository=$repoid", "arch=$myarch");
      };
      if (!$@) {
	unlink("$reporoot/$prp/$myarch/:relsync$$");
	link("$reporoot/$prp/$myarch/:relsync", "$reporoot/$prp/$myarch/:relsync$$");
	rename("$reporoot/$prp/$myarch/:relsync$$", "$reporoot/$prp/$myarch/:relsync.sent");
      } else {
	warn($@);
      }
    }

    cleanup_remotepackstatus($gctx, $prp) if $gctx->{'remotepackstatus_cleanup'}->{$prp} && !$ctx->{'havedelayed'};

    my $now = time();
    if ($prpchecktime) {
      $nextmed{$prp} = $now + 10 * $prpchecktime;
    } else {
      delete $nextmed{$prp};
    }
    $prplastcheck{$prp} = $now;

    if ($now - $lastschedinfo > 60) {
      # update scheduler stats
      my $sinfo = {'arch' => $myarch, 'started' => $schedulerstart, 'time' => $now, 'slept' => $slept};
      $sinfo->{'projects'} = keys %$projpacks;
      $sinfo->{'repositories'} = @{$gctx->{'prps'}};
      my $unfinishedsum = 0;
      $unfinishedsum += $_ for values %prpunfinished;
      $sinfo->{'notready'} = $unfinishedsum;
      $sinfo->{'queue'} = {};
      $sinfo->{'queue'}->{'high'} = @lookat_high;
      $sinfo->{'queue'}->{'med'} = @lookat_med;
      $sinfo->{'queue'}->{'low'} = @lookat_low;
      $sinfo->{'queue'}->{'next'} = keys %lookat_next;
      my $sum = 0;
      my $sum2 = 0;
      my $n = keys %prpchecktimes;
      for my $prp (sort keys %prpchecktimes) {
	my $t = $prpchecktimes{$prp};
	$sum += $t;
	$sum2 += $t * $t;
      }
      $sinfo->{'avg'} = $sum / $n;
      $sinfo->{'variance'} = sqrt(abs(($sum2 - $sum * $sum / $n) / $n));
      for my $prp (splice(@{[sort {$prpchecktimes{$b} <=> $prpchecktimes{$a}} keys %prpchecktimes]}, 0, 10)) {
	my ($projid, $repoid) = split('/', $prp, 2);
	my $worst = {'project' => $projid, 'repository' => $repoid};
	$worst->{'packages'} = keys %{($projpacks->{$projid} || {})->{'package'} || {}};
	$worst->{'time'} = $prpchecktimes{$prp};
	push @{$sinfo->{'worst'}}, $worst;
      }
      $sinfo->{'buildavg'} = $gctx->{'buildavg'};
      writexml("$infodir/.schedulerinfo.$myarch", "$infodir/schedulerinfo.$myarch", $sinfo, $BSXML::schedulerinfo);
      $lastschedinfo = $now;
    }
  }

};

if ($@) {
  warn($@);
  BSSched::Events::event_exit({ 'gctx' => $gctx }, {'type' => 'emergencydump'});
  exit(1);
}

exit(0);
