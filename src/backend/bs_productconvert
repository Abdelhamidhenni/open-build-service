#!/usr/bin/perl -w
#
# Copyright (c) 2008 Klaas Freitag, Novell Inc.
# Copyright (c) 2008 Adrian Schroeter, Novell Inc.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License version 2 as
# published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program (see the file COPYING); if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA
#
################################################################
#
# Converter to create Kiwi- and Spec files from product definition
#
BEGIN {
  my ($wd) = $0 =~ m-(.*)/- ;
  $wd ||= '.';
  unshift @INC,  "$wd";
}

use strict;
use Getopt::Std;
use Data::Dumper;
use File::Basename;
use Storable;

use XML::Structured ':bytes';
use BSUtil;
use BSXML;
use BSProductXML;
use BSKiwiXML;
use BSXML;

my $bsdir;
eval{
  require BSConfig;
  $bsdir = "$BSConfig::bsdir" if defined($BSConfig::bsdir);
};


# read the product xml file

use vars qw ( $opt_h $opt_l $opt_d $opt_m 
              @errors %conditionals %repositories %groupRefs %archSets $indir $runOnServer);

my %product_requires;

sub usage()
{
  print<<END

  bs_productconvert product_file output_directory [project_name]

  convert a product definition file to a spec- and a kiwi source file.

  Options:

  -h:   help, print this text.
  -l:   Run local on server, use direct path instead of obs:// URL.
  -d:   debug, create debug output and files
  -m:   mediaset, build only for the given mediaset, identify by name
END
;

  exit;
}

sub readProductFile( $ )
{
    my ($filename) = @_;

    print "parsing product definition... ";
    my $xml = BSProductXML::readproductxml( "$filename", 0, $opt_d );

    if( defined($xml) ) {
	print "success!\n";
	# print Dumper $xml;
    } else {
	print "FAILED: Unable to parse $filename\n";
	die;
    }
    return $xml;
}


sub createDescription( $ )
{
    my( $prodRef ) = @_;
    my $re;

    $re->{type} = "system";
    $re->{author} = "The SUSE Team";
    $re->{contact} = "build\@opensuse.org";
    $re->{specification} = $prodRef->{summary}[0]->{_content};  # FIXME: lang dependent

    return $re;
}

sub convertFlags( $ ){
    my ($flag)=@_;
    $flag =~ s/GE/>/sg;
    $flag =~ s/EQ/=/sg;
    $flag =~ s/LT/</sg;
    return $flag;
}

sub convertRelationship( $ ){
    my ( $relationship ) = @_;
    $relationship =~ s/suggests/Suggests/sg;
    $relationship =~ s/recommends/Recommends/sg;
    $relationship =~ s/requires/Requires/sg;
    $relationship =~ s/provides/Provides/sg;
    $relationship =~ s/conflicts/Conflicts/sg;
    $relationship =~ s/obsoletes/Obsoletes/sg;
    return $relationship;
}

sub createPreferences( $ )
{
    my( $prodRef ) = @_;
    my $re = {};

    $re->{type} = [{_content => "product"}];
    $re->{version} = "1.0.0"; # hardcoded to fullfill kiwi scheme, real version is defined elsewhere
    $re->{packagemanager} = "zypper" ; # hardcoded since no other support exist yet.

    return $re;
}

#
# The conditionals are kind of macros which are used all over the product definition.
# The conditionals part of the product def is parsed into the global conditionalhash
# with the conditional name as key.
#
sub parseConditionals( $ )
{
    my ($conditionalRef) = @_;
    # print Dumper $conditionalRef;
    return unless( $conditionalRef );

    foreach my $condRef (@{$conditionalRef}) {
	my $name = $condRef->{name};
#	print "Parsed conditional $name\n";
	# print Dumper $condRef;
	$conditionals{$name} = $condRef;
    }
}

sub parseArchsets( $ ) 
{
    my ($archSetsRef ) = @_;

    foreach my $archSet ( @{$archSetsRef } ) {
	# print "Parsing Archset $archSet->{name}\n";

	# print "XXXX " . Dumper( $archSet ) . "\n";
	if( $archSet->{name} ) {
	    my %h;
	    $h{productarch} = $archSet->{productarch};
	    my @a;
	    foreach my $cRef ( @{$archSet->{arch}} ) {
		push @a, $cRef->{_content};
	    }
	    $h{archList} = \@a;
	    $archSets{$archSet->{name}} = \%h;
	}
    }
    # print Dumper %archSets;
}

sub getUrl( $$$ ){
    my ($product,$arch,$searchstring) = @_;
    my $url="";
    foreach my $url ( @{$product->{'urls'}->{'url'}} ){
        if ( "$url->{'name'}" eq "$searchstring" ){
            my $url = $url->{'_content'};
            $url =~ s/%{_target_cpu}/$arch/g;
            return $url;
	}
    }
    return $url;
}

sub createArchitectures( $ )
{
    my ($archSetList) = @_;

    my $re = {};

    my @archs;
    my %reqArchs;

    my %archMatrix;

    foreach my $requiredArch( @{$archSetList} ) {
	my $ref = $requiredArch->{ref};
	die ( "ERROR: No such archset $requiredArch\n" ) unless $archSets{$ref} ;
	my @archis = @{ $archSets{$ref}->{archList} };
	my $border = @archis; # the amount of entries
	
	print "WARN: last arch in archset must be noarch\n" unless( $archis[$border-1] eq "noarch" );

	$reqArchs{ $archSets{$ref}->{productarch} } = 1; # will be requiredarch in kiwi
	
	for( my $i = 0; $i < $border; $i++ ) {
	    $archMatrix{ $archis[$i] } = { fallback => $archis[$i+1] };
	}
    }
    foreach my $arch ( sort keys %archMatrix ) {
	my %h;
	$h{id} = $arch;
	if( $archMatrix{$arch}->{name} ) {
	    $h{name} = $archMatrix{$arch}->{name};
	} else {
	    $h{name} = "dummy"; # FIXME: should become optional
	};
	$h{fallback} = $archMatrix{$arch}->{fallback} if( $archMatrix{$arch}->{fallback});
	push @archs, \%h;
    }
    
    my @reqXml;

    foreach ( sort keys %reqArchs ) {
	my %h;
	$h{ref} = $_;
	push @reqXml, \%h;
    }
    $re->{arch} = \@archs;
    $re->{requiredarch} = \@reqXml;
    
    return $re;
}

sub createProductOptions($$$)
{
    my( $prodRef, $medium, $archSetList ) = @_;

    # General FIXME: this works only with a single product on media.
    my $product = $prodRef->{products}{product}[0];
    die( "Handling of multiple products on one media is currently not specified !\n" ) if $prodRef->{products}{product}[1];

    my $re = {};
    my %varsH;
    # we need the "default" arch for 
    # - MEDIUM_NAME
    # - releasenotesurl
    my $arch="i586";
    my @allarchs;
    foreach my $ar ( @$archSetList ) {
        $arch=$archSets{$ar->{ref}}->{productarch} if ($archSets{$ar->{ref}});
        push @allarchs, $arch;
    }

    $varsH{MEDIUM_NAME} = $product->{'name'}."-".$product->{'version'}."-".join( "-", @allarchs );
    if ( defined $medium->{'name'} ) {
      $varsH{MEDIUM_NAME} = $medium->{'name'}."-".join( "-", @allarchs );
    }
    $varsH{PRODUCT_THEME} = $product->{'buildconfig'}->{'producttheme'};
    $varsH{MULTIPLE_MEDIA} = "no";
    $varsH{MULTIPLE_MEDIA} = "true" if (defined($medium->{'sourcemedia'}) && $medium->{'sourcemedia'} > 1);
    $varsH{MULTIPLE_MEDIA} = "true" if (defined($medium->{'debugmedia'}) && $medium->{'debugmedia'} > 1);
    $varsH{RUN_MEDIA_CHECK} = "true" if (defined($medium->{'run_media_check'})) && $medium->{'run_media_check'} ne "no";
    $varsH{CREATE_REPOMD } = "true" if (defined($medium->{'create_repomd'})) && $medium->{'create_repomd'} ne "false";
    $varsH{REPO_ONLY} = "true" if (defined($medium->{'repo_only'})) && $medium->{'repo_only'} ne "no" && $medium->{'repo_only'} ne "false";
    $varsH{SHA1OPT} = "-x";

    $varsH{VENDOR} = $product->{'vendor'};
    $varsH{DISTNAME} = $product->{'name'};
    $varsH{VERSION} = $product->{'version'};
    $varsH{FLAVOR} = $medium->{'flavor'};
#    $varsH{RELEASE} = $product->{'release'};
    $varsH{PRODUCT_DIR} = "/";
    $varsH{PRODUCT_NAME} = '$DISTNAME-$FLAVOR';
    $varsH{PRODUCT_VERSION} = '$VERSION';

    my @vars;
    foreach my $opt ( sort keys %varsH ) {
	push @vars, { name => $opt, _content => $varsH{$opt} };
    }

    $re->{productvar} = \@vars;

    my %options;
    if (defined($medium->{'sourcemedia'})) {
      $options{'SOURCEMEDIUM'} = $medium->{'sourcemedia'};
    };
    if (defined($medium->{'debugmedia'})) {
      $options{'DEBUGMEDIUM'} = $medium->{'debugmedia'};
    };
    
    my $mediaStyle = "suse-11.1"; # fallback value
    $mediaStyle = $medium->{'mediastyle'} if (defined($medium->{'mediastyle'}));
    $options{'PLUGIN_DIR'} = "/usr/share/kiwi/modules/plugins/$mediaStyle";
    $options{'INI_DIR'} = "/usr/share/kiwi/modules/plugins/$mediaStyle";
    $options{'BETA_VERSION'} = $product->{'buildconfig'}->{'betaversion'} if (defined($product->{'buildconfig'}->{'betaversion'}));

    my %info;
    $info{'VENDOR'}       = $product->{'vendor'};
    $info{'NAME'}         = $product->{'name'};
    # fix for bnc #449162
    #my $rp = $product->{'installconfig'}->{'releasepackage'};
    #$info{'REFERENCES'}   = "$rp->{'name'} ".convertFlags($rp->{'flag'})." $rp->{'version'}";
    if (defined($product->{'patchlevel'}) && $product->{'patchlevel'} ne '0'){
       $info{'VERSION'}      = $product->{'version'}.".".$product->{'patchlevel'};
    }else{
       $info{'VERSION'}      = $product->{'version'};
    };
#    $info{'RELEASE'}      = $product->{'release'};
    $info{'SP_VERSION'}   = $product->{'patchlevel'} if (defined($product->{'patchlevel'}));
    $info{'DISTRIBUTION'} = $product->{'installconfig'}->{'distribution'};
    # fix for bnc #449162
    # $info{'FLAVOR'}       = $medium->{'flavor'};
    $info{'DESCRDIR'}     = $product->{'installconfig'}->{'descriptiondir'};
    $info{'DATADIR'}      = $product->{'installconfig'}->{'datadir'};
    if (defined($medium->{'preselected_patterns'})){
        $info{'PATTERNS'} .= join(' ',map( $_->{'name'},@{$medium->{'preselected_patterns'}->[0]->{'pattern'}}));
    }
    foreach my $summary ( @{$product->{'summary'}} ){
      $info{'LABEL'}      = $summary->{'_content'} if ( ! $summary->{'language'} );
    }
    $options{'REPO_LOCATION'} = getUrl($product,$arch,"repository");
    $info{'RELNOTESURL'} = getUrl($product,$arch,"releasenotes");

    $info{'LINGUAS'} = "";
    foreach my $language ( @{$product->{'linguas'}->{'language'}} ){
      $info{'LINGUAS'} .= "$language->{'_content'} ";
    }

    $info{'BASEARCHS'} = "";
    foreach my $ar ( @$archSetList ) {
        $info{'BASEARCHS'} .= "$archSets{$ar->{ref}}->{productarch} " if( $archSets{$ar->{ref}} );
    }

    # Add REGISTERPRODUCT string - see: bnc#458340
    if (defined($medium->{'productdependency'})){
	$info{'REGISTERPRODUCT'} .= "true" if (defined($product->{'register'}));
    }

    # Add Product Options
    my @vars1;
    foreach my $opt ( sort keys %options ) {
	push @vars1, { name => $opt, _content => $options{$opt} };
    }
    $re->{productoption} = \@vars1;

    # Add Product Info
    my @info;
    push @info, { name => 'CONTENTSTYLE', _content => '11' }; # Needs to be first !
    foreach my $opt ( sort keys %info) {
	push @info, { name => $opt, _content => $info{$opt} };
    }
    $re->{productinfo} = \@info;

    return $re;
}

sub createMetadata( $$$ )
{
    my( $prodRef, $medium, $archSetList ) = @_;
    
    return undef unless( $medium->{'metadata'} );
    my $re = {};

    # print "> " . Dumper $medium->{metadata};

    my @packages;
    my @files;
    my $onlyarch;
    my $removearch;
    foreach my $requiredArch( @{$archSetList} ) {
	my $ref = $requiredArch->{ref};
	die( "ERROR: No such archset $requiredArch\n" ) unless $archSets{$ref};
        $onlyarch .= "$archSets{$ref}->{productarch},";
    };
    my $metadata_medium = "0";
#    $metadata_medium = "1" if (defined($medium->{'sourcemedia'}) && $medium->{'sourcemedia'} > 1);
    foreach my $pack ( @{ $medium->{metadata}->{package} } ) {
        if ($pack->{removearch}){
          next if containsMyArch( $prodRef, $archSetList, $pack->{removearch} );
          $removearch = "$pack->{removearch},src,nosrc";
        }else{
          $removearch = "src,nosrc";
        }
	push @packages, { name => $pack->{name}, 
			  medium => $metadata_medium, 
			  removearch => $removearch,
			  onlyarch => $onlyarch };
    }

    my @a;
    return { repopackage => \@packages };
    
#     my @files;
#     foreach my $file ( @{ $medium->{metadata}->{file} } ) {
# 	push @files, { name => $file->{name} };
#     }
#     # push @a, { file => \@files }; CHECK: Needed?
# 
#     return \@a;
}

sub containsMyArch( $$$ )
{
    my ($prodRef, $archSetList, $archList ) = @_;

    foreach my $s( split( /\s*,\s*/, $archList ) ){
      foreach my $requiredArch( @{$archSetList} ) {
	my $ref = $requiredArch->{ref};
	die( "ERROR: No such archset $requiredArch\n" ) unless $archSets{$ref};
        return 1 if ( $s eq $archSets{$ref}->{productarch} );
      }
    }
    return 0;
}

sub useToPackages( $$$ )
{
    my ($prodRef, $medium, $archSetList ) = @_;

    return unless $medium;

    my @packages;

    if (defined($medium->{use_undecided}) && $medium->{use_undecided} eq "true" ) {
       # Simply take all packages ?
       push @packages, { name => "*" };
    };

    return unless $medium->{use};
    my @useStatements = @{$medium->{use} };

    # print "Use Required: <$useRequired>, Suggested: <$useSuggested>, Recommended: <$useRecommended>\n";

    foreach my $useState ( @useStatements ) {
        my $useRequired;
        my $useRecommended;
        my $useSuggested;

        # Media default settings
        $useRequired    = $medium->{'use_required'}
                          if ( defined($medium->{'use_required'}) && $medium->{'use_required'} eq "true" );
        $useRecommended = $medium->{'use_recommended'}
                          if ( defined($medium->{'use_recommended'}) && $medium->{'use_recommended'} eq "true" );
        $useSuggested   = $medium->{'use_suggested'}
                          if ( defined($medium->{'use_suggested'}) && $medium->{'use_suggested'} eq "true" );

        # can get overriden by "use group" settings
        $useRequired    = $useState->{'use_required'}
                          if ( defined($useState->{'use_required'}) && $useState->{'use_required'} eq "true" );
        $useRecommended = $useState->{'use_recommended'}
                          if ( defined($useState->{'use_recommended'}) && $useState->{'use_recommended'} eq "true" );
        $useSuggested   = $useState->{'use_suggested'}
                          if ( defined($useState->{'use_suggested'}) && $useState->{'use_suggested'} eq "true" );
    
	if( $useState->{group} ) {
#	    print "Handling use of group $useState->{group}\n";
	    push @packages, groupToPackages( $prodRef, $archSetList,
					     $useState->{group}, 
					     $useRequired, 
					     $useRecommended,
					     $useSuggested );
	    # there might be additional packages listed in the group.
	    if( $useState->{package} ) {
		foreach my $addPack ( @{$useState->{package} } ) {
		    # print Dumper( $addPack ) . "\n";
		    my $relType = $addPack->{relationship};
	            die( "ERROR: Unknown relation type string for package add!\n" ) unless( $relType eq "requires" || $relType eq "recommends" || $relType eq "suggests" );
		    if( ( $useRequired    && $addPack->{relationship} eq "requires") ||
			( $useRecommended && $addPack->{relationship} eq "recommends" ) ||
			( $useSuggested   && $addPack->{relationship} eq "suggests" ) ) {

			my %tmp;
                        $tmp{name} = $addPack->{name};
                        $tmp{medium} = $addPack->{medium} if (defined($addPack->{medium}));
                        if ($addPack->{removearch}) {
                          next if containsMyArch( $prodRef, $archSetList, $addPack->{removearch} );
                          $tmp{removearch} = $addPack->{removearch};
                        }
			push @packages, \%tmp;
		    }
		}
	    }
	} elsif( $useState->{pattern} ) {
	    die( "ERROR: Patterns are not supported for repopackages!\n" );
	}
    }
    return \@packages;
}

sub groupToPackages( $$$$$ ) 
{
    my ($prodRef, $archSetList, $group, $useReq, $useRec, $useSug ) = @_;

    # generate the list of current architectures out of the archSetList
    # FIXME: In all product configs I saw so far, there is only one entry 
    # in the archsetlist.
    # What does it mean if there are more? The following code takes all
    # and allows all.
    my @validArchs;
    foreach my $archHashRef (@$archSetList) {
	my $archSetRef = $archSets{$archHashRef->{ref}};
	push @validArchs, $archSetRef->{productarch};
    }

    my @groups = @{$prodRef->{group} || {}}; 
    my $groupRef;

    # search for the group we should convert here.
    foreach my $gl( @groups ) {
	if( $gl->{name} eq $group ) {
	    $groupRef = $gl;
	    last;
	}
    }

    unless( $groupRef ) {
	die( "ERROR: Group <$group> not found!\n" );
    }
    
    unless( $groupRef->{packagelist} ) {
	die( "ERROR: Group <$group> has no package lists!\n" );
    }

    # ok, here we have a valid group reference.
#    print " * resolving group <$groupRef->{name}>\n";
    my @packagelists = @{$groupRef->{packagelist}};

    my %conditionTemplate;
    foreach my $condList( @{$groupRef->{conditional} } ) {
#	print "Handling group conditional $condList->{name}\n";
	my $cond = $conditionals{ $condList->{name} };

	if( $cond->{platform} ) {
	    my @platforms = @{$cond->{platform}};

	    # the condition only becomes a template
	    foreach my $p ( @platforms ) {
		my @condArchs;
		@condArchs  = split( /\s*,\s*/, $p->{arch} ) if( $p->{arch} );
		# 
		my $takeIt = 1; # Take all condition tags if no arch-tag is there
		if( $p->{arch} ) {
		    $takeIt = 0;
		    foreach my $validArch( @validArchs ) {
			if( grep( /$validArch/, @condArchs ) ) {
			    $takeIt = 1;
			    last;
			}
		    }
		}
		if( $takeIt ) {
		    %conditionTemplate = (%conditionTemplate, %{$p});
		} else {
		    # This condition does not match, so drop it
		}
	    }
	}
    }

    # Drop this group, if condition(s) exist for it, but none matches for this platform
    return () if ( @{$groupRef->{conditional}} > 0 && !keys %conditionTemplate );
 
    my $useFlags = { requires => $useReq || 0, recommends => $useRec || 0, suggests => $useSug || 0 };

    my @resultList;

    foreach my $packList ( @packagelists ) {
	my $relation = $packList->{relationship} || 'requires';
	# print "Relation: $relation\n";
	if( $useFlags->{$relation} && $packList->{package} ) {
	    # parse the package in 
	    my @packs = @{$packList->{package}};
	    foreach my $pack ( @packs ) {
		my %h = %conditionTemplate;
                my $takeIt = 1;

                $takeIt = 0 unless $pack->{conditional};

		# print Dumper $pack;
		foreach my $condList( @{$pack->{conditional} } ) {
		    my $name = $condList->{name};
		    my $cond = $conditionals{$name};
                    next unless defined $h{$name};
                    $takeIt = 1;
		    print "Handling package conditional $name\n";
		    # print Dumper "Conditional: ". $cond . "\n";
		    
		    if( $cond->{platform} ) {
			my @platforms = @{$cond->{platform}};
			foreach my $p ( @platforms ) {
			    %h= (%h, %{$p});
			}
		    }
		    if( $cond->{media} ) {
			$h{medium} = $cond->{media}->{number};
		    }
		}
		$h{name} = $pack->{name};
		push @resultList, \%h;
	    }
	}

    }

    return @resultList;
}

#
# This sub expands the patterns 
sub expandPackages( $ )
{
    my ($groupRef) = @_;
    
    my $name = $groupRef->{name};

    print "Working on group $name\n";
    
    my @patterns = @{$groupRef->{pattern}};
    
    my $pat = @{$groupRef->{pattern}}[0];
    $groupRef->{_pattern} = $pat;


    foreach my $pack ( @{$groupRef->{group}} ) {
	my $packListRef = $pack->{package};
	my $relation = $pack->{relationship};
	my @resultPacks;
	foreach my $packRef ( @${packListRef} ) {
	    # print "Pushing $packRef->{name}\n";
	    my %packValues;
	    $packValues{name} = $packRef->{name};
	    if( $groupRef->{platform} ) {
		# forcerepo??
		foreach my $tag ('forcearch', 'addarch', 'onlyarch', 'removearch', 'source', 'script', 'medium' ) {
		    $packValues{$tag} = $groupRef->{platform}->{$tag} if( $groupRef->{platform}->{$tag} );
		}
	    }

	    push @resultPacks, \%packValues;
	}
	my $keyname = "_" . lc $relation;
	print "Keyname of package list: $keyname\n";
	$groupRef->{$keyname} = \@resultPacks;
    }
}

#
# Creation of the instsource part of the kiwi file
#
# note that the product spec contains a list of archsets. For each of these archsets and 
# for each of the media must be a separate kiwi file.
#
# 1. parameter: the reference on the product datastructure
# 2. parameter: the reference on the current media datastructure
# 3. parameter: list of the archs for this kiwi file.
#
sub createInstsource( $$$ )
{
    my( $prodRef, $medium, $archSetList ) = @_;
    my $re = {};

    $re->{architectures} = createArchitectures( $archSetList );
    $re->{productoptions} = createProductOptions( $prodRef, $medium, $archSetList );
    
    my @r;
    my $count = 0;
    foreach my $repo ( @{$prodRef->{repositories}{repository} } ) {
	my %h;
        my $kiwipath;
        next if defined($repo->{build}) && $repo->{build} eq "ignore";
        $count = $count + 1;
	$h{priority} = $count;
	$h{name} = "repository_".$count;
        if ($repo->{path} =~ /^obs:\/\/([^\/]*)\/([^\/]*)$/ ) { #old format without obsname 
	  $h{local} = "true";
          $kiwipath = "$1/$2";
        } elsif ($repo->{path} =~ /^obs:\/\/([^\/]*)\/([^\/]*)\/([^\/]*)$/ ) {
	  $h{local} = "true";
          $kiwipath = "$2/$3";
        } else {
          die( "ERROR: Non obs:// url as repository: $repo->{path} !\n" );
        };
        if ( $runOnServer ) {
          for my $arch ( @{$re->{architectures}->{requiredarch}} ) {
  	     my $path = "$bsdir/build/$kiwipath/$arch->{'ref'}/:full";
  	     $h{source} = { path => $path };
	     push @r, \%h;
             print "WARNING: local path $path does not exist !\n" if ( ! -e "$path" );
          };
        }else{
	  $h{source} = { path => "obs://".$kiwipath };
	  push @r, \%h;
        };
    }
    $re->{instrepo} = \@r;
    
    # metadata, media dependant
    my $ref = createMetadata( $prodRef, $medium, $archSetList );
    if( $ref ) {
	$re->{metadata} = createMetadata( $prodRef, $medium, $archSetList );
    }

    # repopackages
    my @packages;
    my $useToPacks = useToPackages( $prodRef, $medium, $archSetList );

    if( $useToPacks ) {
	push @packages, { repopackage => $useToPacks };
    }
    # print "Packlist: " . Dumper \@packages;
    $re->{repopackages} = \@packages;

    return $re;
}

sub createRepository
{
    # This is for a dummy entry, it is required by the kiwi DTD, but not used
    # for installation medias.
    my( $prodRef ) = @_;
    my @repository;
    my $source;
    my $dummydir = "/var/lib/empty";

    # Do we have ever a different repo type than "yast" on products ?
    $source->{ 'path' } = $dummydir;
    push @repository, { 'type' => 'yast2', 'source' => $source };

    return \@repository;
}

sub createFlavorReadme( $$ ){
    my($prodRef,$product)=@_;
    my $reame_file="";
    foreach my $flavor ( @{$prodRef->{mediasets}->{media}} ){
      next if ((!defined ($flavor->{'flavor'}) || ("$flavor->{'flavor'}" eq "")));
      my $readmedir = "\$RPM_BUILD_ROOT/%{_defaultdocdir}/$product->{name}-release-$flavor->{flavor}";
      $reame_file .= "mkdir -p $readmedir\n";
      $reame_file .= "cat >$readmedir/README << EOF\n";
      $reame_file .= "This package just exist just for providing the product flavor \'$flavor->{flavor}\'.\n";
      $reame_file .= "\nEOF\n\n";
    }
    return $reame_file;
}

sub writeMigrationSPECfile( $$$ )
{
    my( $file, $prodRef,$product ) = @_;
    my $mproduct = Storable::dclone($product);

    $mproduct->{name} = $product->{name}."-SP".$mproduct->{'patchlevel'}."-migration";

    my $packageversion = $mproduct->{'version'}.".".$mproduct->{'patchlevel'};
    my $oldpatchlevel = $mproduct->{'patchlevel'} - 1;
    my $content="# ";
    $content.="\n\n";
    $content.="Name:           $mproduct->{name}\n";
    $content.="Summary:        $product->{name} Service Pack $product->{'patchlevel'} Migration Product\n";
    $content.="Version:        ".$packageversion."\n";
    $content.="Release:        0\n";
    $content.="License:        BSD 3-Clause\n";
    $content.="Group:          System/Fhs\n";
    $content.="Provides:       product()\n";
    $content.="Provides:       product(%name) = %{version}-%{release}\n";
    $content.="Requires:       product(%name) = %{version}";
    $content.=".".$oldpatchlevel if ( $oldpatchlevel >0 );
    $content.="\n";
    $content.="AutoReqProv:    on\n";
    $content.="BuildRoot:      %{_tmppath}/%{name}-%{version}-build\n";
    $content.="\n%description\n";
    $content.="Product to migrate to $product->{name} Service Pack $product->{'patchlevel'}.\n";
    $content.="\n\n";
    $content.="\n%prep\n";
    $content.="\n%build\n\n";
    $content.="\n%install\n";
    $content.=createProductFile($prodRef,$mproduct);
    $content.="\n%clean\n";
    $content.="rm -rf %buildroot\n";
    $content.="\n%files\n";
    $content.="%defattr(644,root,root,755)\n";
    $content.="%dir /etc/products.d\n";
    $content.="/etc/products.d/*.prod\n";
    $content.="\n%changelog\n";

    # write out the modified file.
    writestr($file, undef, $content);      
}

sub writeProductSPECfile( $$$$ )
{
    my( $file, $infile, $prodRef,$product ) = @_;
    my $product_flavors="";
    my $packageversion = $product->{version};
    $packageversion = $product->{'version'}.".".$product->{'patchlevel'} if (defined($product->{'patchlevel'}) && $product->{'patchlevel'} ne '0');
    ### A product may obsolete packages.
    my $obsoletepackage="";
    for my $p ( @{$product->{'installconfig'}->{'obsoletepackage'}} ) {
      $obsoletepackage .= "\nProvides: weakremover(".$p->{'_content'}.")";
    }
    $obsoletepackage .= "\n";
    # My product provides
    my $productprovides="";
    $productprovides.="Provides:       %name-%version\n";
    $productprovides.="Provides:       $prodRef->{'project'}->{'name'}\n" if ((defined($prodRef->{'project'}->{'name'})) && ("$prodRef->{'project'}->{'name'}" ne ""));
    $productprovides.="Provides:       product()\n";
    $productprovides.="Provides:       product($product->{'name'}) = %version-%release\n";
    if (defined($product->{'patchlevel'}) && $product->{'patchlevel'} ne '0') {
      $productprovides.="Provides:       product($product->{'name'}-SP$product->{'patchlevel'}) = %version-%release\n";
    }
    $productprovides.="Requires:       product_flavor($product->{name}) = %version-%release\n";

    if ("$infile" eq ""){
     my ($sec,$min,$hour,$mday,$mon,$year,$wday,$ydat,$isdst)=localtime();
     $year += 1900;
     my $content=();
     # write the specfile header
     $content="#
# spec file for package $product->{name}-release (Version $product->{version})
#
# Copyright (c) $year $product->{'vendor'}.
#
# All modifications and additions to the file contributed by third parties
# remain the property of their copyright owners, unless otherwise agreed
# upon. The license for this file, and modifications and additions to the
# file, is the same license as for the pristine package itself (unless the
# license for the pristine package is not an Open Source License, in which
# case the license is the MIT License). An \"Open Source License\" is a
# license that conforms to the Open Source Definition (Version 1.9)
# published by the Open Source Initiative.
";
     my $bugtracker=getUrl($product,"i586","bugtracker");
     $content.="\n# Please submit bugfixes or comments via $bugtracker\n#\n\n" if ("$bugtracker" ne "");
     $content.="# norootforbuild\n";
     $content.="\n\n";
     $content.="Name:           $product->{name}-release\n";
     $content.="%define         product $product->{name}\n";
     if (defined ($product->{'buildconfig'}->{'betaversion'})){
       $content.="%define         betaversion $product->{'buildconfig'}->{'betaversion'}\n";
     }
     foreach my $summary ( @{$product->{'summary'}} ){
       $content.="Summary:        $summary->{_content}\n" if ( ! $summary->{'language'} );
     }
     $content.="Version:        ".$packageversion."\n";
     $content.="Release:        0\n"; # FIXME: check if this is this really handled via BS
     $content.="License:        BSD 3-Clause\n";
     $content.="Group:          System/Fhs\n";
     $content.=$obsoletepackage;
     $content.=$productprovides;
     $content.="AutoReqProv:    on\n";
     $content.="BuildRoot:      %{_tmppath}/%{name}-%{version}-build\n";
     $content.="\n%description\n";
     for my $description ( @{$product->{'description'} || []} ){
       $content.="$description->{_content}\n" if ( ! $description->{'description'} );
     }
     $content.="\n\n";
     $content.=createSPECfileFlavors($prodRef,$product);
     $content.="\n%prep\n";
     $content.="\n%build\n\n";
     $content.="\n%install\n";
     $content.=createFlavorReadme($prodRef,$product);
     $content.=createProductFile($prodRef,$product);
     $content.="\n%clean\n";
     $content.="rm -rf %buildroot\n";
     $content.="\n%files\n";
     $content.="%defattr(644,root,root,755)\n";
     $content.="%dir /etc/products.d\n";
     $content.="/etc/products.d/*.prod\n";
     $content.="\n%changelog\n";

     # write out the modified file.
     writestr($file, undef, $content);      
 
    } else {

     $product_flavors.=createSPECfileFlavors($prodRef,$product);

     # Create product file to be packaged
     my $zypp_product_file = createProductFile($prodRef,$product);
        $zypp_product_file.= createFlavorReadme($prodRef,$product);

     my $str = readstr($infile);

     # replace all strings
     $str =~ s/___DISTNAME___/$product->{name}/g;
     $str =~ s/___VERSION___/$packageversion/g;
     if ( defined $product->{buildconfig}->{betaversion} ) {
       $str =~ s/___BETA_VERSION___/$product->{buildconfig}->{betaversion}/g;
     } else {
       $str =~ s/___BETA_VERSION___//g;
     }
     $str =~ s/___RELEASE___/$product->{release}/g;
     $str =~ s/___PATCH_LEVEL___/$product->{'patchlevel'}/g;
     $str =~ s/___PACKAGE_NAME___/$product->{name}-release/g;
     $str =~ s/___PRODUCT_NAME___/$product->{name}/g;
     $str =~ s/___SUMMARY___/$product->{summary}[0]->{_content}/g; # FIXME: find the non-lang one
     $str =~ s/___DESCRIPTION___/$product->{description}[0]->{_content}/g; # FIXME: find the non-lang one
     $str =~ s/___FLAVOR_PACKAGES___/$product_flavors/g;
     $str =~ s/___CREATE_PRODUCT_FILES___/$zypp_product_file/g;

     $str =~ s/___PRODUCT_PROVIDES___/$productprovides/g;
     $str =~ s/___OBSOLETE_PACKAGES___/$obsoletepackage/g;
 
     # write out the modified file.
     writestr($file, undef, $str);
    }
}

sub createSPECfileFlavors ( $$ ) {
    my ( $prodRef,$product ) = @_;
    my $product_flavors="";
    foreach my $flavor ( @{$prodRef->{mediasets}->{media}} ){
      next if ((!defined ($flavor->{'flavor'}) || ("$flavor->{'flavor'}" eq "")));
      $product_flavors.="%package $flavor->{flavor}\n";
      $product_flavors.="License:        BSD 3-Clause\n";
      $product_flavors.="Group:          System/Fhs\n";
      if ((defined($prodRef->{'project'}->{'name'})) && ("$prodRef->{'project'}->{'name'}" ne "")){
          # TODO: - split between ":" -> Provides: SUSE \n Provides: SUSE:Factory ...
          #       - add plattform
          $product_flavors.="Provides:       $prodRef->{'project'}->{'name'}\n";
      }
      $product_flavors.="Provides:       product_flavor()\n";
      $product_flavors.="Provides:       flavor($flavor->{flavor})\n";
      $product_flavors.="Provides:       product_flavor($product->{name}) = %version-%release\n";
      if (defined($flavor->{'productdependency'})){
	foreach my $dependency (@{$flavor->{'productdependency'}}){
	    my $relship=convertRelationship($dependency->{'relationship'});
            my $version=$dependency->{'version'} if (defined($dependency->{'version'}));
            my $patchlevel="-SP".$dependency->{'patchlevel'} if (defined($dependency->{'patchlevel'}));
            my $flavor="-".$dependency->{'flavor'} if (defined($dependency->{'flavor'}));
            my $release=$dependency->{'release'} if (defined($dependency->{'release'}));
            my $flag=convertFlags($dependency->{'flag'}) if (defined($dependency->{'flag'}));
	    if (("$flag" eq "") && ("$version" ne "")){ # avoid something like Requires: sles 11
                $flag="=";
            }
            if ((defined($version)) && ("$version" ne "") && (defined($release)) && ("$release" ne "")){ # rpm style for version-release
                $release="-".$release;
            } 
            $patchlevel="" if (! defined($patchlevel));
            $release="" if (! defined($release));
            $flavor="" if (! defined($flavor));
            
            $product_flavors.="$relship:       product(".$dependency->{'name'}."$patchlevel$flavor) $flag $version$release\n";
        }
      }
      foreach my $summary ( @{$product->{'summary'}} ){
        $product_flavors.="Summary:        $summary->{_content}\n" if ( ! $summary->{'language'} );
      }
      $product_flavors.="\n";
      $product_flavors.="%description $flavor->{flavor}\n";
      foreach my $description ( @{$product->{'description'}} ){
        $product_flavors.="$description->{_content}\n" if ( ! $description->{'description'} );
      }
      $product_flavors.="\n";
      $product_flavors.="%files $flavor->{flavor}\n";
      $product_flavors.="%defattr(-,root,root)\n";
      $product_flavors.="%doc %{_defaultdocdir}/$product->{name}-release-$flavor->{flavor}\n";
      $product_flavors.="\n"
    }
    return $product_flavors;
}

sub createSPECfileInstallSection ( $ ) {
        my ($product) = @_;
        my $content="";
        my $is_main_product=0;
        if ( $is_main_product ){
                my $greeting = "%{product} %{version}";
                foreach my $summary ( @{$product->{'summary'}} ){
                   $greeting = $summary->{'_content'} if ( ! $summary->{'language'} );
                }

                my $content="mkdir -p %{buildroot}/%{_sysconfdir}
echo -e 'Welcome to ".$greeting." %{?betaversion:%{betaversion} }- Kernel \\r (\\l).\n\n' > %{buildroot}/etc/issue
echo \"Welcome to ".$greeting." %{?betaversion:%{betaversion} }- Kernel %%r (%%t).\" > %{buildroot}/etc/issue.net
echo \"#".$greeting." %{?betaversion:%{betaversion} }(%{_target_cpu})\" > %{buildroot}/etc/SuSE-release
echo \"VERSION = %{version}\" >> %{buildroot}/etc/SuSE-release\n";

                $content.="PATCHLEVEL = ".$product->{'patchlevel'}."\n" if (defined($product->{'patchlevel'}));
                $content.="mkdir -p %{buildroot}/%{_sysconfdir}
echo \"Have a lot of fun...\" > %{buildroot}/etc/motd
# Bug 404141 - /etc/YaST/control.xml should be owned by some package
mkdir -p %{buildroot}/etc/YaST2/
install -m 644 /CD1/control.xml %{buildroot}/etc/YaST2/
install -m 644 -D /CD1/EULA.txt %{buildroot}/%{_docdir}/%{name}/%{product}-EULA.txt
";
	}
        $content="mkdir -p %{buildroot}/etc/products.d";
        return $content;
}

sub createProductFile ( $$ ) {
    my ($prodRef, $product) = @_;
    my $zypp_product_file = "";
    my $zypp_product = Storable::dclone($product);
    my $d;
    my $pfile = "\$RPM_BUILD_ROOT/etc/products.d/$product->{name}.prod";

    $zypp_product_file = "mkdir -p \$RPM_BUILD_ROOT/etc/products.d\n";
    $zypp_product->{'arch'} = '%{_target_cpu}'; # write product architecture during rpm build
    $zypp_product->{'schemeversion'} = "0";

    $d->{"target"}  = $product->{'register'}->{'target'};
    $d->{"release"} = $product->{'register'}->{'release'};
    my @r;
    foreach my $repo ( @{$prodRef->{repositories}{repository} } ) {
        next if defined($repo->{product_file}) && $repo->{product_file} eq "ignore";
        # do only export when build name is specified
        push @r, { "path" => $repo->{path} } if $repo->{path} =~ /^obs:\/\/(.*)\/(.*)\/(.*)/ && $1 && $2 && $3 ;
    };
    $d->{"repositories"}{"repository"} = \@r;
    $zypp_product->{'register'} = $d;

    # The generated prod file differes from input by this:
    $zypp_product->{'release'} = "%{release}";
    $zypp_product->{'baseversion'} = $zypp_product->{'version'};
    $zypp_product->{'version'} = "%{version}";
    $zypp_product->{'release'} = "%{release}";

    my $xml = XMLout( $BSProductXML::product, $zypp_product );
    die ( "ERROR: Unable to create xml for $product->{name} !" ) unless $xml;
    $xml = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n$xml";
    $zypp_product_file .= "cat >$pfile << EOF\n";
    $zypp_product_file .= "$xml\nEOF\n\n";
}

# Process the commandline arguments.
getopts('dlhm:');

usage() if $opt_h;
$runOnServer = "true" if $opt_l;

my ($infile, $outdir, $project) = @ARGV;

die( "Please specify input file, output directory (and project name)\n" ) unless $infile;
die( "Please specify output directory (and project) name\n" ) unless $outdir;

my $d;
# global indir
($d, $indir) = fileparse( $infile );

my $prodRef = readProductFile( $infile );

#
# Sanity checks
#
die("product definition contains no products\n") unless $prodRef->{'products'};
die("product definition contains multiple products, this is not yet supported \n") if @{$prodRef->{'products'}->{'product'}} > 1;
my $product = $prodRef->{'products'}->{'product'}[0];
die("no product name set\n") unless $product->{'name'};
die("illegal product name: $product->{'name'}\n") if $product->{'name'} =~ /^[_\.]/;
die("illegal product name: $product->{'name'}\n") if $product->{'name'} =~ /[\/\000-\037]/;
die("ERROR: File name does not match to product name ($infile/$prodRef->{'products'}->{'product'}[0]->{'name'}.product)\n") if not $infile =~ /.*\/$prodRef->{'products'}->{'product'}[0]->{'name'}.product$/;

#
# Create a kiwi configuration for each distribution flavor
#

my $productRef = $prodRef->{products}->{product}->[0]; # FIXME: Support multiple products.

my $kiwiImage = {};
$kiwiImage->{schemeversion} = "2.4"; # ???
my $name = sprintf( "%s %s %s, Rel. %s",
		    $productRef->{vendor},
		    $productRef->{name},
		    $productRef->{version},
		    $productRef->{release} );

$kiwiImage->{name} = $name;

$kiwiImage->{description} = createDescription( $productRef );
$kiwiImage->{preferences} = createPreferences( $productRef );
# so far for all media types identical. Now loop over the media types
# to create media type specific versions;

parseConditionals( $prodRef->{conditionals}->{conditional} );
parseArchsets( $prodRef->{archsets}{archset} );

#
# Create $product-release packages
#

my $SPECtemplateFile;
if ($infile =~ /(.*\/)(.+)$/) {
  $SPECtemplateFile = $1."/".$product->{name}."-release.spec";
};
if ( !$SPECtemplateFile || ! -e $SPECtemplateFile ) {
  if ($infile =~ /(.*\/)(.+)$/) {
    $SPECtemplateFile = "$1/release.spec";
  };
};
if ( ! $SPECtemplateFile || ! -e $SPECtemplateFile ) {
  $SPECtemplateFile="";
  print "No release template file $SPECtemplateFile exists --> generating SPEC file $product->{name}-release.spec automatically\n";
}
mkdir_p( "$outdir/_product:$product->{name}-release" ) || die ("Unable to create $outdir\n");
writeProductSPECfile( "$outdir/_product:$product->{name}-release/$product->{name}-release.spec", $SPECtemplateFile, $prodRef, $product );

if (defined($product->{patchlevel}) && $product->{patchlevel} ne '0'){
mkdir_p( "$outdir/_product:".$product->{name}."-SP".$product->{patchlevel}."-migration" ) || die ("Unable to create $outdir\n");
 writeMigrationSPECfile( "$outdir/_product:".$product->{name}."-SP".$product->{patchlevel}."-migration/".$product->{name}."-SP".$product->{patchlevel}."-migration.spec", $prodRef, $product );
}

#
# Create kiwi images
#

my %generalImage = %{$kiwiImage};

my $media = $prodRef->{mediasets}->{media};

if( $opt_m ) {
    print "Generating only media set $opt_m, due to commandline switch\n";
}

foreach my $medium ( @$media ){
    my $type = $medium->{type};
    my $flavor = $medium->{flavor};
    my $product = $medium->{product};  # note: this needs to reference a product from the products section 
    $product = $prodRef->{'products'}->{'product'}[0]->{'name'} unless $product; # use global name as fallback
    my $name = $medium->{name};
   
    next if( $opt_m && $name ne $opt_m );

    # create one kiwi file each for every of the archsets
    if ( defined(@{$medium->{archsets}}) ) {
      my @archSets = @{$medium->{archsets}};
      foreach my $arch ( @archSets ) {
          my $buildflags;
          my @archs;
          $buildflags->{'disable'} = [{}]; # disabled by default
      
          my $kiwi = \%generalImage;
      
          $kiwi->{instsource} = createInstsource ( $prodRef, $medium, $arch->{archset} );
          $kiwi->{repository} = createRepository ( $prodRef );
      
          my $archStr;
          my @archsets = @{$arch->{archset}};
          my @productarch;
          foreach my $ar ( @archsets ) {
              if( $archSets{$ar->{'ref'}} ) {
          	  my $architecture = "$archSets{$ar->{'ref'}}->{'productarch'}";
          	  $archStr .= "_" if $archStr;
          	  $archStr .= "$architecture";
                  # enable this architecture in scheduler
                  # FIXME: the scheduler arch may have a different name than the rpm archs !
                  push @archs, { 'arch' => $architecture };
                  push @productarch, $architecture;
                  # Heuristic: we need to make this configurable at a more central place
#                  push @archs, { 'arch' => 'local' }; # activate this, if you run with local scheduler
                  push @archs, { 'arch' => 'i586' } if ( $architecture eq "x86_64" );
                  push @archs, { 'arch' => 'i586' } if ( $architecture eq "ia64" );
                  push @archs, { 'arch' => 'ppc' } if ( $architecture eq "ppc64" );
                  push @archs, { 'arch' => 'ppc64' } if ( $architecture eq "ppc" ); # ppc is using ppc64 stuff in openSUSE
                  push @archs, { 'arch' => 's390' } if ( $architecture eq "s390x" );
              }
          }
          $buildflags->{'enable'} = \@archs;

          # add implicit the release packages to media
#          if ( $SPECtemplateFile ne "" && $kiwi->{instsource}->{repopackages}[0] ){
          if ( $kiwi->{instsource}->{repopackages}[0] ){
            my %product_pack;
            my $addarch = join( ",", @productarch );
            # FIXME: Shouldn't we simply use local $product here ?
            my $name = $prodRef->{'products'}->{'product'}[0]->{'name'}."-release";
            push @{$kiwi->{instsource}->{repopackages}[0]->{repopackage}}, { "name" => $name, addarch => $addarch };
            # add the flavor package
            $name = $prodRef->{'products'}->{'product'}[0]->{'name'}."-release-".$flavor;
            push @{$kiwi->{instsource}->{repopackages}[0]->{repopackage}}, { "name" => $name, addarch => $addarch };
          }

          my $file = "$product-$type-$flavor-$archStr";
          die("illegal kiwi product: $file\n") if $file =~ /^[_\.]/;
          die("illegal kiwi product: $file\n") if $file =~ /[\/\000-\037]/;
      
          my $pkgName = "_product:$file";
          my $kiwiDir = "$outdir/$pkgName/";
          my $outFile = "$kiwiDir/$file.kiwi";
          my $metaFile = "$kiwiDir/_meta";
      
          mkdir_p( $kiwiDir ) || die ("Unable to create $kiwiDir\n");
          writexml( "$outFile$$", $outFile, $kiwi, $BSKiwiXML::kiwidesc );
          print "$outFile written.\n";
      
          # Create meta file to enable it only for needed architectures
          if ( $project ) {
            my $pkgmeta;
            $pkgmeta->{'name'} = $pkgName;
            $pkgmeta->{'project'} = $project;
            $pkgmeta->{'title'} = "KIWI product image build" ;
            $pkgmeta->{'bcntsynctag'} = "_product:".$product;  # all images for one product shall get the same build number
            $pkgmeta->{'description'} = "Automatically generated from _product by product converter." ;
            $pkgmeta->{'build'} = $buildflags;
            $prodRef->{'project'}->{'name'}="$project";
            $prodRef->{'project'}->{'buildflags'}=$buildflags;
            writexml( "$metaFile$$", $metaFile, $pkgmeta, $BSXML::pack );
#            print "metafile written.\n";
          } else {
            print "metafile SKIPPED ! (need project name argument for it)\n";
          }
      }
    }
}



# end
