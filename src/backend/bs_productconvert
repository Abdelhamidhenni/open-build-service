#!/usr/bin/perl -w
#
# Copyright (c) 2008 Klaas Freitag, Novell Inc.
# Copyright (c) 2008 Adrian Schroeter, Novell Inc.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License version 2 as
# published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program (see the file COPYING); if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA
#
################################################################
#
# Converter to create Kiwi- and Spec files from product definition
#
use strict;
use Getopt::Std;
use Data::Dumper;

use XML::Structured ':bytes';
use BSUtil;
use BSProductXML;
use BSKiwiXML;


# read the product xml file

use vars qw ( $opt_h @errors %groupRefs );

sub usage()
{
  print<<END

  bs_productconvert

  convert a product definition file to a spec- and a kiwi source file.

  Options:

  -h:   help, print this text.

END
;

  exit;
}

sub readProductFile( $ )
{
    my ($filename) = @_;

    print "parsing product definition... ";
    my $xml = BSProductXML::readproductxml( "$filename", 0 );

    if( defined($xml) ) {
	print "success!\n";
    } else {
	print "FAILED: Unable to parse $filename\n";
	die;
    }
    return $xml;
}


sub createDescription( $ )
{
    my( $prodRef ) = @_;
    my $re;

    $re->{type} = "system";
    $re->{author} = "The SUSE Team";
    $re->{contact} = "build\@opensuse.org";
    $re->{specification} = $prodRef->{general}->{summary}[0]->{_content};

    return $re;
}

sub createPreferences( $ )
{
    my( $prodRef ) = @_;
    my $re = {};

    $re->{type} = [{_content => "dummy"}];
    $re->{version} = sprintf( "%s.%s",
			      $prodRef->{general}->{version},
			      $prodRef->{general}->{release}  );

    # $re->{size} = ; do not give the optional size
    $re->{packagemanager} = "zypper" ;

    return $re;
}

sub createArchitectures()
{
    my $re = {};

    my $archfallbacks = { 'ppc64' => { name => 'Motorola 64 Bit', fallback => 'ppc' },
			  'ppc' =>   { name => 'Motorola 32 Bit', fallback => 'noarch' },
			  'i686' =>  { name => 'Intel x86', fallback => 'i586' },
			  'i586' =>  { name => 'Intel x86', fallback => 'i486' },
			  'i486' =>  { name => 'Intel x86', fallback => 'i386' },
			  'i386' =>  { name => 'Intel x86', fallback => 'noarch' },
			  'x86_64' =>{ name => 'AMD 64 bit', fallback => 'i686' },
			  'src'  =>  { name => 'Source rpms', fallback => undef } };
    my @archs;
    foreach my $arch ( keys %$archfallbacks ) {
	my %h;
	$h{id} = $arch;
	$h{name} = $archfallbacks->{$arch}->{name};
	$h{fallback} = $archfallbacks->{$arch}->{fallback} if( $archfallbacks->{$arch}->{fallback});
	push @archs, \%h;
    }
    $re->{arch} = \@archs;

    my @reqXml;
    my @reqArchs = ( 'ppc64', 'ppc', 'i686', 'x86_64' ); # We need to specify in PD which architectures should
                                                         # be used and in which combination.
    foreach ( @reqArchs ) {
	my %h;
	$h{ref} = $_;
	push @reqXml, \%h;
    }
    $re->{requiredarch} = \@reqXml;

    return $re;
}

sub createProductOptions()
{
    my $re = {};
    my %options;

    $options{PRODUCT_THEME} = "SuSE";
    $options{MEDIUM_NAME} = "FTP";
    $options{MULTIPLE_MEDIUM} = "no";
    $options{SHA1_OPT} = "-x";
    # add more as needed.
    my @vars;
    foreach my $opt ( keys %options ) {
	push @vars, { name => $opt, _content => $options{$opt} };
    }

    $re->{productvar} = \@vars;

    my %info;
    $info{'ARCH.x86_64'} = "x86_64 i686 i586 i486 i386 noarch";
    $info{'ARCH.ppc64'}  = "ppc64 ppc noarch";
    $info{'ARCH.ppc'}    = "ppc noarch";
    $info{'ARCH.i686'}   = "i686 i586 i486 i386 noarch";
    $info{'ARCH.i586'}   = "i586 i486 i386 noarch";
    $info{'ARCH.i486'}   = "i486 i386 noarch";
    $info{'ARCH.i386'}   = "i386 noarch";
    $info{'DEFAULTBASE'} = "i586";
    # add more ...
    my @info;
    foreach my $opt ( keys %info) {
	push @info, { name => $opt, _content => $info{$opt} };
    }

    $re->{productinfo} = \@info;

    return $re;

}

sub createMetadata( $$ )
{
    my( $prodRef, $medium ) = @_;
    
    return undef unless( $medium->{'metadata'} );
    my $re = {};

    # print "> " . Dumper $medium->{metadata};

    my @packages;
    my @files;
    foreach my $pack ( @{ $medium->{metadata}->{package} } ) {
	push @packages, { name => $pack->{name}, 
			  medium => "0", 
			  removearch => "src" };
    }

    my @a;
    return { repopackage => \@packages };
    
#     my @files;
#     foreach my $file ( @{ $medium->{metadata}->{file} } ) {
# 	push @files, { name => $file->{name} };
#     }
#     # push @a, { file => \@files }; CHECK: Needed?
# 
#     return \@a;
}

sub useToPackages( $$ )
{
    my ($prodRef, $medium ) = @_;

    return unless $medium;
    
    return unless $medium->{use};
    my @useStatements = @{$medium->{use} };

    my @packages;

    foreach my $useState ( @useStatements ) {

	my $useRequired = $useState->{use_required};
	my $useSuggested = $useState->{use_suggested};
	my $useRecommended = $useState->{use_recommended};

	if( $useState->{group} ) {
	    push @packages, groupToPackages( $useState->{group}, 
					     $useRequired, 
					     $useRecommended, 
					     $useSuggested );
	} elsif( $useState->{pattern} ) {
# 	    push @packages, PatternToPackages( $useState->{pattern}, 
# 					       $useRequired, 
# 					       $useRecommended, 
# 					       $useSuggested );
# 	    
	}
    }
    
}

sub groupToPackages( $$$$ ) 
{
    my ($group, $useReq, $useRec, $useSug ) = @_;

    my $groupsBaseDir = "testdata/productdefinition";
    my $file = "$groupsBaseDir/groups/$group.xml";
    unless( -r $file ) {
	print "ERR: Could not find group definition named <$file>\n";
	return ();
    }

    my $groupRef;

    unless( $groupRefs{$group} ) {

	$groupRef = readxml( $file, $BSProductXML::group );
	$groupRefs{$group} = $groupRef;
	    
	expandPackages( $groupRef );
	
    }
    $groupRef = $groupRefs{$group};

    return () unless $groupRefs{ $group };

    return $groupRef->{package};
}

#
# This sub expands the patterns 
sub expandPackages( $ )
{
    my ($groupRef) = @_;
    
    my $name = $groupRef->{name};

    print "Working on group $name\n";
    
    my @patterns = @{$groupRef->{pattern}};
    
    my $pat = @{$groupRef->{pattern}}[0];
    $groupRef->{_pattern} = $pat;
    $groupRef->{_packages} = ('no package yet');

    my @resultPacks;

    foreach my $pack ( @{$groupRef->{group}} ) {
	my $packListRef = $pack->{package};
	my $relation = $pack->{relationship};
	foreach my $packRef ( @${packListRef} ) {
	    push @resultPacks, $packRef->{name};
	}
	$groupRef->{$relation} = \@resultPacks;
    }

}

sub createInstsource( $$ )
{
    my( $prodRef, $medium ) = @_;
    my $re = {};

    $re->{architectures} = createArchitectures();
    $re->{productoptions} = createProductOptions();
    # instrepo can be copied, but lets check if only obs:// is used.
    my @r;
    foreach my $repo ( @{$prodRef->{instrepo}} ){
      die "ERROR: Non obs:// repo used in $repo->{'name'}\n" if ( $repo->{'source'}->{'path'} !~ "^obs://.+" );
      push @r, $repo;
    }
    # Hm, should we implicit add our own Project ?
    $re->{instrepo} = \@r;
    
    # metadata, media dependant
    my $ref = createMetadata( $prodRef, $medium );
    if( $ref ) {
	$re->{metadata} = createMetadata( $prodRef, $medium );
    }

    # repopackages
    my @packages;
    push @packages, useToPackages( $prodRef, $medium );

    return $re;
}

sub createRepository
{
    # This is for a dummy entry, it is required by the kiwi DTD, but not used
    # for installation medias.
    my( $prodRef ) = @_;
    my @repository;
    my $source;
    my $dummydir = "/var/lib/empty";

    # Do we have ever a different repo type than "yast" on products ?
    $source->{ 'path' } = $dummydir;
    push @repository, { 'type' => 'yast2', 'source' => $source };

    return \@repository;
}

sub writeProductFile
{
    my( $file, $prodRef ) = @_;

}

sub writeProductSPECfile
{
    my( $file, $prodRef ) = @_;

    my $str="";
    $str.="Name:           $prodRef->{general}->{name}-release\n";
    $str.="%define product $prodRef->{general}->{name}\n";
    $str.="# what's the default flavor ?\n";
    $str.="%define flavor  none\n";
    $str.="License:        BSD 3-Clause\n";
    $str.="Group:          System/Fhs\n";
    $str.="Version:        $prodRef->{general}->{version}\n";
    $str.="Release:        0\n";
    $str.="Provides:       aaa_version distribution-release\n";
    $str.="Provides:       suse-release-oss = %{version}-%{release}\n";
    $str.="Provides:       suse-release = %{version}-%{release}\n";
    $str.="# Code11 product\n";
    $str.="Provides:       product()\n";
    $str.="Provides:       product(%{product}) = %{version}-%{release}\n";
    $str.="Obsoletes:      aaa_version\n";
    $str.="Obsoletes:      suse-release-oss <= 10.0 suse-release <= 10.1.42\n";
    $str.="Conflicts:      sles-release <= 10 sled-release <= 10 core-release <= 10\n";
#FIXME: add Requires based on required packages/groups in PD
    $str.="BuildRequires:  skelcd-control-$prodRef->{general}->{name}\n";
    $str.="AutoReqProv:    on\n";
    $str.="Summary:        $prodRef->{general}->{summary}[0]->{_content}\n"; #FIXME: search for non-lang 
    $str.="BuildRoot:      %{_tmppath}/%{name}-%{version}-build\n";
    $str.="PreReq:         coreutils\n";
    $str.="%define betaversion \"$prodRef->{general}->{buildconfig}->{betaversion}\"\n";
    $str.="\n";
    $str.="%description\n";
    $str.="$prodRef->{general}->{description}[0]->{_content}\n"; #FIXME: search for non-lang 
    $str.="\n";

    foreach my $flavor ( @{$prodRef->{mediasets}->{media}} ){
      $str.="%package $flavor->{type}\n";
      $str.="%define flavor $flavor->{type}\n";
      $str.="License:        BSD 3-Clause\n";
      $str.="Group:          System/Fhs\n";
      $str.="Summary:        $prodRef->{general}->{summary}[0]->{_content}\n"; #FIXME: search for non-lang 
      $str.="\n";
      $str.="%description $flavor->{type}\n";
      $str.="$prodRef->{general}->{description}[0]->{_content}\n"; #FIXME: search for non-lang 
      $str.="\n";
      $str.="%files $flavor->{type}\n";
      $str.="%defattr(-,root,root)\n";
      $str.="%dir /etc/products.d\n";
      $str.="/etc/products.d/$prodRef->{general}->{name}-$flavor->{type}.prod\n";
      $str.="\n"
    }

    $str.="\n";
    $str.="%prep\n";
    $str.="\n";
    $str.="%build\n";
    $str.="\n";
    $str.="%install\n";
    $str.="mkdir -p \$RPM_BUILD_ROOT/etc\n";
    $str.="echo -e \'Welcome to %{product} %{betaversion} - Kernel \\\\r (\\\\l).\\n\\n\' > \$RPM_BUILD_ROOT/etc/issue\n";
    $str.="echo \"Welcome to %{product} %{betaversion} - Kernel %%r (%%t).\" > \$RPM_BUILD_ROOT/etc/issue.net\n";
    $str.="echo %{product} \"%{betaversion}\" > \$RPM_BUILD_ROOT/etc/SuSE-release\n";
    $str.="echo VERSION = %{version} >> \$RPM_BUILD_ROOT/etc/SuSE-release\n";
    $str.="echo \"Have a lot of fun...\" > \$RPM_BUILD_ROOT/etc/motd\n";
    $str.="# Bug 404141 - /etc/YaST/control.xml should be owned by some package\n";
    $str.="mkdir -p \$RPM_BUILD_ROOT/etc/YaST2/\n";
    $str.="echo \$RPM_BUILD_ROOT\n";
    $str.="cp -av /CD1/control.xml \$RPM_BUILD_ROOT/etc/YaST2/\n";
    $str.="\n";

    foreach my $flavor ( @{$prodRef->{mediasets}->{media}} ){
      my $pfile = "\$RPM_BUILD_ROOT/etc/products.d/$prodRef->{general}->{name}-$flavor->{type}.prod";
      $str = "${str}mkdir -p \$RPM_BUILD_ROOT/etc/products.d\n";
#   INI file syntax
#      $str = "${str}echo -e \"[product]\" > $pfile\n";
#      $str = "${str}echo -e \"name = %{product}\" >> $pfile\n";
#      $str = "${str}echo -e \"version = %{version}-%{release}\" >> $pfile\n";
#      $str = "${str}#%{arch} doesn't expand ?!\n";
#      $str = "${str}#echo -e \"arch = %{arch} \ >> $pfile\n";
#      $str = "${str}echo -e \"flavor = %{flavor}\" >> $pfile\n";
#      $str = "${str}echo -e \"distribution = %{distribution}\" >> $pfile\n";
#      $str = "${str}echo -e \"vendor = %{vendor}\" >> $pfile\n";
#      $str = "${str}echo -e \"\" >> $pfile\n";
#      $str = "${str}echo -e \"[translated]\" >> $pfile\n";
#      foreach my $element ( "summary", "description" ){
#        foreach my $text ( @{$prodRef->{general}->{$element}} ){
#          $str = "$str\n echo -e \"$element";
#          $str = "$str\[$text->{lang}\]" if ( $text->{lang} );
#          $str = "$str = $text->{_content}\" >> $pfile\n";
#        }
#      }

#   XML file syntax
      my $product;
      $product->{'general'} = $prodRef->{general};
      $product->{'schemeversion'} = "0.0"; # FIXME: moving target, still in development.
      my $d = {};
      $d->{'type'} = $flavor->{type};
      $d->{'flavor'} = "build.suse.de_SUSE_Factory_HEAD-%arch"; # FIXME
      $product->{'general'}->{'distribution'} = $d;

      my $xml = XMLout( $BSProductXML::productdesc, $product );
      $xml = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n$xml";
      die ( "ERROR: Unable to create xml for $flavor->{type} !" ) unless $xml;
      $str = "${str}cat >$pfile << EOF\n";
      $str = "${str}$xml\nEOF\n\n";
    }

    $str.="\n";
    $str.="%post\n";
    $str.="rm -rf /etc/zypp/products.d\n";
    $str.="\n";
    $str.="%files\n";
    $str.="%defattr(644,root,root,755)\n";
    $str.="%config /etc/SuSE-release\n";
    $str.="# Bug 404141 - /etc/YaST/control.xml should be owned by some package\n";
    $str.="%dir /etc/YaST2/\n";
    $str.="%config /etc/YaST2/control.xml\n";
    $str.="%config /etc/motd\n";
    $str.="%config(noreplace) /etc/issue\n";
    $str.="%config(noreplace) /etc/issue.net\n";
    $str.="\n";

    local *F;
    open(F, '>', $file) || die("$file: $!\n");
    (syswrite(F, $str) || 0) == length($str) || die("$file write: $!\n");
    close(F) || die("$file close: $!\n");
}

# Process the commandline arguments.
getopts('h');

usage() if ($opt_h );

my ($infile) = @ARGV;

die( "Please specify input file" ) unless $infile;

my $prodRef = readProductFile( $infile );

#
# Create a kiwi configuration for each distribution flavor
#

my $kiwiImage;
$kiwiImage->{schemeversion} = "2.4"; # ???
my $name = sprintf( "%s %s %s, Rel. %s",
		    $prodRef->{general}->{vendor},
		    $prodRef->{general}->{name},
		    $prodRef->{general}->{version},
		    $prodRef->{general}->{release} );

$kiwiImage->{name} = $name;

$kiwiImage->{description} = createDescription( $prodRef );
$kiwiImage->{preferences} = createPreferences( $prodRef );
# so far for all media types identical. Now loop over the media types
# to create media type specific versions;

my %generalImage = %{$kiwiImage};

my $media = $prodRef->{mediasets}->{media};

foreach my $medium ( @$media ){
    my $type = $medium->{type};
    my $kiwi = \%generalImage;

    $kiwi->{instsource}  = createInstsource ( $prodRef, $medium );
    $kiwi->{repository}  = createRepository ( $prodRef );

    my $outFile = "$prodRef->{general}->{name}-$type.kiwi";

    writexml( "$outFile$$", $outFile, $kiwi, $BSKiwiXML::kiwidesc );
    print "$outFile written.\n";
}

#
# Create $product-release packages
#

#writeProductFile( "product.file", $prodRef );
writeProductSPECfile( "$prodRef->{general}->{name}-release.spec", $prodRef );




# end
